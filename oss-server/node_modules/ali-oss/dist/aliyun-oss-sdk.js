// Aliyun OSS SDK for JavaScript v6.1.1
// Copyright Aliyun.com, Inc. or its affiliates. All Rights Reserved.
// License at https://github.com/ali-sdk/ali-oss/blob/master/LICENSE
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.OSS = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var OSS = require('./browser/client');
OSS.Buffer = require('buffer').Buffer;
OSS.urllib = require('../shims/xhr');
OSS.version = require('./browser/version').version;

module.exports = OSS;

},{"../shims/xhr":242,"./browser/client":2,"./browser/version":5,"buffer":37}],2:[function(require,module,exports){
(function (process,Buffer){
'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('ali-oss');
var crypto = require('./../../shims/crypto/crypto.js');
var path = require('path');
var copy = require('copy-to');
var mime = require('mime');
var xml = require('xml2js');
var ms = require('humanize-ms');
var AgentKeepalive = require('agentkeepalive');
var merge = require('merge-descriptors');
var urlutil = require('url');
var is = require('is-type-of');
var platform = require('platform');
var utility = require('utility');
var urllib = require('urllib');
var pkg = require('./version');
var dateFormat = require('dateformat');
var bowser = require('bowser');
var signUtils = require('../common/signUtils');
var utils = require('../common/utils');

var globalHttpAgent = new AgentKeepalive();

function getHeader(headers, name) {
  return headers[name] || headers[name.toLowerCase()];
}

function setEndpoint(endpoint, secure) {
  var url = urlutil.parse(endpoint);

  if (!url.protocol) {
    var protocol = secure ? 'https://' : 'http://';
    url = urlutil.parse(protocol + endpoint);
  }

  if (url.protocol !== 'http:' && url.protocol !== 'https:') {
    throw new Error('Endpoint protocol must be http or https.');
  }

  return url;
}

function setRegion(region, internal, secure) {
  var protocol = secure ? 'https://' : 'http://';
  var suffix = internal ? '-internal.aliyuncs.com' : '.aliyuncs.com';
  var prefix = 'vpc100-oss-cn-';
  // aliyun VPC region: https://help.aliyun.com/knowledge_detail/38740.html
  if (region.substr(0, prefix.length) === prefix) {
    suffix = '.aliyuncs.com';
  }

  return urlutil.parse(protocol + region + suffix);
}

// check local web protocol,if https secure default set true , if http secure default set false
function isHttpsWebProtocol() {
  return document && document.location && document.location.protocol === 'https:';
}

function Client(options, ctx) {
  if (!(this instanceof Client)) {
    return new Client(options, ctx);
  }
  if (options && options.inited) {
    this.options = options;
  } else {
    this.options = Client.initOptions(options);
  }

  this.options.cancelFlag = false; // cancel flag: if true need to be cancelled, default false

  // support custom agent and urllib client
  if (this.options.urllib) {
    this.urllib = this.options.urllib;
  } else {
    this.urllib = urllib;
    this.agent = this.options.agent || globalHttpAgent;
  }
  this.ctx = ctx;
  this.userAgent = this._getUserAgent();

  // record the time difference between client and server
  this.options.amendTimeSkewed = 0;
}

/**
 * Expose `Client`
 */

module.exports = Client;

Client.initOptions = function initOptions(options) {
  if (!options || !options.accessKeyId || !options.accessKeySecret) {
    throw new Error('require accessKeyId, accessKeySecret');
  }

  var isHttpsProtocol = isHttpsWebProtocol();
  var opts = {
    region: 'oss-cn-hangzhou',
    internal: false,
    secure: isHttpsProtocol,
    bucket: null,
    endpoint: null,
    cname: false,
    isRequestPay: false,
    useFetch: true
  };

  (0, _keys2.default)(options).forEach(function (key) {
    if (options[key] !== undefined) {
      opts[key] = options[key];
    }
  });
  opts.accessKeyId = opts.accessKeyId.trim();
  opts.accessKeySecret = opts.accessKeySecret.trim();

  if (opts.timeout) {
    opts.timeout = ms(opts.timeout);
  }

  if (opts.endpoint) {
    opts.endpoint = setEndpoint(opts.endpoint, opts.secure);
  } else if (opts.region) {
    opts.endpoint = setRegion(opts.region, opts.internal, opts.secure);
  } else {
    throw new Error('require options.endpoint or options.region');
  }

  opts.inited = true;
  return opts;
};

/**
 * prototype
 */

var proto = Client.prototype;

// mount debug on proto
proto.debug = debug;

/**
 * Object operations
 */
merge(proto, require('./object'));
// /**
//  * Bucket operations
//  */
// merge(proto, require('./bucket'));
// multipart upload
merge(proto, require('./managed-upload'));
/**
 * Multipart operations
 */
merge(proto, require('../common/multipart'));

/**
 * Common module parallel
 */
merge(proto, require('../common/parallel'));

/**
 * get OSS signature
 * @param {String} stringToSign
 * @return {String} the signature
 */
proto.signature = function signature(stringToSign) {
  this.debug('authorization stringToSign: %s', stringToSign, 'info');

  return signUtils.computeSignature(this.options.accessKeySecret, stringToSign);
};

/**
 * get author header
 *
 * "Authorization: OSS " + Access Key Id + ":" + Signature
 *
 * Signature = base64(hmac-sha1(Access Key Secret + "\n"
 *  + VERB + "\n"
 *  + CONTENT-MD5 + "\n"
 *  + CONTENT-TYPE + "\n"
 *  + DATE + "\n"
 *  + CanonicalizedOSSHeaders
 *  + CanonicalizedResource))
 *
 * @param {String} method
 * @param {String} resource
 * @param {Object} header
 * @return {String}
 *
 * @api private
 */

proto.authorization = function authorization(method, resource, subres, headers) {
  var stringToSign = signUtils.buildCanonicalString(method.toUpperCase(), resource, {
    headers: headers,
    parameters: subres
  });

  return signUtils.authorization(this.options.accessKeyId, this.options.accessKeySecret, stringToSign);
};

/**
 * create request params
 * See `request`
 * @api private
 */

proto.createRequest = function createRequest(params) {
  var headers = {
    'x-oss-date': dateFormat(+new Date() + this.options.amendTimeSkewed, 'UTC:ddd, dd mmm yyyy HH:MM:ss \'GMT\''),
    'x-oss-user-agent': this.userAgent
  };

  if (this.options.isRequestPay) {
    (0, _assign2.default)(headers, { 'x-oss-request-payer': 'requester' });
  }

  if (this.options.stsToken) {
    headers['x-oss-security-token'] = this.options.stsToken;
  }

  copy(params.headers).to(headers);

  if (!getHeader(headers, 'Content-Type')) {
    if (params.mime === mime.default_type) {
      params.mime = '';
    }

    if (params.mime && params.mime.indexOf('/') > 0) {
      headers['Content-Type'] = params.mime;
    } else {
      headers['Content-Type'] = mime.getType(params.mime || path.extname(params.object || '')) || 'application/octet-stream';
    }
  }

  if (params.content) {
    headers['Content-Md5'] = crypto.createHash('md5').update(new Buffer(params.content, 'utf8')).digest('base64');
    if (!headers['Content-Length']) {
      headers['Content-Length'] = params.content.length;
    }
  }

  var authResource = this._getResource(params);
  headers.authorization = this.authorization(params.method, authResource, params.subres, headers);

  var url = this._getReqUrl(params);
  this.debug('request %s %s, with headers %j, !!stream: %s', params.method, url, headers, !!params.stream, 'info');
  var timeout = params.timeout || this.options.timeout;
  var reqParams = {
    agent: this.agent,
    method: params.method,
    content: params.content,
    stream: params.stream,
    headers: headers,
    timeout: timeout,
    writeStream: params.writeStream,
    customResponse: params.customResponse,
    ctx: params.ctx || this.ctx
  };

  return {
    url: url,
    params: reqParams
  };
};

/**
 * request oss server
 * @param {Object} params
 *   - {String} object
 *   - {String} bucket
 *   - {Object} [headers]
 *   - {Object} [query]
 *   - {Buffer} [content]
 *   - {Stream} [stream]
 *   - {Stream} [writeStream]
 *   - {String} [mime]
 *   - {Boolean} [xmlResponse]
 *   - {Boolean} [customResponse]
 *   - {Number} [timeout]
 *   - {Object} [ctx] request context, default is `this.ctx`
 *
 * @api private
 */

proto.request = function request(params) {
  var reqParams, result, reqErr, err, parseData;
  return _regenerator2.default.async(function request$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          reqParams = this.createRequest(params);


          if (!this.options.useFetch) {
            reqParams.params.mode = 'disable-fetch';
          }
          result = void 0;
          reqErr = void 0;
          _context.prev = 4;
          _context.next = 7;
          return _regenerator2.default.awrap(this.urllib.request(reqParams.url, reqParams.params));

        case 7:
          result = _context.sent;

          this.debug('response %s %s, got %s, headers: %j', params.method, reqParams.url, result.status, result.headers, 'info');
          _context.next = 14;
          break;

        case 11:
          _context.prev = 11;
          _context.t0 = _context['catch'](4);

          reqErr = _context.t0;

        case 14:
          err = void 0;

          if (!(result && params.successStatuses && params.successStatuses.indexOf(result.status) === -1)) {
            _context.next = 27;
            break;
          }

          _context.next = 18;
          return _regenerator2.default.awrap(this.requestError(result));

        case 18:
          err = _context.sent;

          if (!(err.code === 'RequestTimeTooSkewed')) {
            _context.next = 24;
            break;
          }

          this.options.amendTimeSkewed = +new Date(err.serverTime) - new Date();
          _context.next = 23;
          return _regenerator2.default.awrap(this.request(params));

        case 23:
          return _context.abrupt('return', _context.sent);

        case 24:
          err.params = params;
          _context.next = 31;
          break;

        case 27:
          if (!reqErr) {
            _context.next = 31;
            break;
          }

          _context.next = 30;
          return _regenerator2.default.awrap(this.requestError(reqErr));

        case 30:
          err = _context.sent;

        case 31:
          if (!err) {
            _context.next = 33;
            break;
          }

          throw err;

        case 33:
          if (!params.xmlResponse) {
            _context.next = 38;
            break;
          }

          _context.next = 36;
          return _regenerator2.default.awrap(this.parseXML(result.data));

        case 36:
          parseData = _context.sent;

          result.data = parseData;

        case 38:
          return _context.abrupt('return', result);

        case 39:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this, [[4, 11]]);
};

proto._getResource = function _getResource(params) {
  var resource = '/';
  if (params.bucket) resource += params.bucket + '/';
  if (params.object) resource += params.object;

  return resource;
};

proto._isIP = function _isIP(host) {
  return utils._isIP(host);
};

proto._escape = function _escape(name) {
  return utility.encodeURIComponent(name).replace(/%2F/g, '/');
};

proto._getReqUrl = function _getReqUrl(params) {
  var ep = {};
  copy(this.options.endpoint).to(ep);
  var isIP = this._isIP(ep.hostname);
  var isCname = this.options.cname;
  if (params.bucket && !isCname && !isIP) {
    ep.host = params.bucket + '.' + ep.host;
  }

  var reourcePath = '/';
  if (params.bucket && isIP) {
    reourcePath += params.bucket + '/';
  }

  if (params.object) {
    // Preserve '/' in result url
    reourcePath += this._escape(params.object).replace(/\+/g, '%2B');
  }
  ep.pathname = reourcePath;

  var query = {};
  if (params.query) {
    merge(query, params.query);
  }

  if (params.subres) {
    var subresAsQuery = {};
    if (is.string(params.subres)) {
      subresAsQuery[params.subres] = '';
    } else if (is.array(params.subres)) {
      params.subres.forEach(function (k) {
        subresAsQuery[k] = '';
      });
    } else {
      subresAsQuery = params.subres;
    }
    merge(query, subresAsQuery);
  }

  ep.query = query;

  return urlutil.format(ep);
};

/*
 * Get User-Agent for browser & node.js
 * @example
 *   aliyun-sdk-nodejs/4.1.2 Node.js 5.3.0 on Darwin 64-bit
 *   aliyun-sdk-js/4.1.2 Safari 9.0 on Apple iPhone(iOS 9.2.1)
 *   aliyun-sdk-js/4.1.2 Chrome 43.0.2357.134 32-bit on Windows Server 2008 R2 / 7 64-bit
 */

proto._getUserAgent = function _getUserAgent() {
  var agent = process && process.browser ? 'js' : 'nodejs';
  var sdk = 'aliyun-sdk-' + agent + '/' + pkg.version;
  var plat = platform.description;
  if (!plat && process) {
    plat = 'Node.js ' + process.version.slice(1) + ' on ' + process.platform + ' ' + process.arch;
  }

  return this._checkUserAgent(sdk + ' ' + plat);
};

proto._checkUserAgent = function _checkUserAgent(ua) {
  var userAgent = ua.replace(/\u03b1/, 'alpha').replace(/\u03b2/, 'beta');
  return userAgent;
};

/*
 * Check Browser And Version
 * @param {String} [name] browser name: like IE, Chrome, Firefox
 * @param {String} [version] browser major version: like 10(IE 10.x), 55(Chrome 55.x), 50(Firefox 50.x)
 * @return {Bool} true or false
 * @api private
 */

proto.checkBrowserAndVersion = function checkBrowserAndVersion(name, version) {
  return bowser.name === name && bowser.version.split('.')[0] === version;
};

/**
 * thunkify xml.parseString
 * @param {String|Buffer} str
 *
 * @api private
 */

proto.parseXML = function parseXMLThunk(str) {
  return new _promise2.default(function (resolve, reject) {
    if (Buffer.isBuffer(str)) {
      str = str.toString();
    }
    xml.parseString(str, {
      explicitRoot: false,
      explicitArray: false
    }, function (err, result) {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
};

/**
 * generater a request error with request response
 * @param {Object} result
 *
 * @api private
 */

proto.requestError = function requestError(result) {
  var err, message, info, msg;
  return _regenerator2.default.async(function requestError$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          err = null;

          if (!(!result.data || !result.data.length)) {
            _context2.next = 5;
            break;
          }

          if (result.status === -1 || result.status === -2) {
            // -1 is net error , -2 is timeout
            err = new Error(result.message);
            err.name = result.name;
            err.status = result.status;
            err.code = result.name;
          } else {
            // HEAD not exists resource
            if (result.status === 404) {
              err = new Error('Object not exists');
              err.name = 'NoSuchKeyError';
              err.status = 404;
              err.code = 'NoSuchKey';
            } else if (result.status === 412) {
              err = new Error('Pre condition failed');
              err.name = 'PreconditionFailedError';
              err.status = 412;
              err.code = 'PreconditionFailed';
            } else {
              err = new Error('Unknow error, status: ' + result.status);
              err.name = 'UnknowError';
              err.status = result.status;
            }
            err.requestId = result.headers['x-oss-request-id'];
            err.host = '';
          }
          _context2.next = 33;
          break;

        case 5:
          message = String(result.data);

          this.debug('request response error data: %s', message, 'error');

          info = void 0;
          _context2.prev = 8;
          _context2.next = 11;
          return _regenerator2.default.awrap(this.parseXML(message));

        case 11:
          _context2.t0 = _context2.sent;

          if (_context2.t0) {
            _context2.next = 14;
            break;
          }

          _context2.t0 = {};

        case 14:
          info = _context2.t0;
          _context2.next = 24;
          break;

        case 17:
          _context2.prev = 17;
          _context2.t1 = _context2['catch'](8);

          this.debug(message, 'error');
          _context2.t1.message += '\nraw xml: ' + message;
          _context2.t1.status = result.status;
          _context2.t1.requestId = result.headers['x-oss-request-id'];
          return _context2.abrupt('return', _context2.t1);

        case 24:
          msg = info.Message || 'unknow request error, status: ' + result.status;

          if (info.Condition) {
            msg += ' (condition: ' + info.Condition + ')';
          }
          err = new Error(msg);
          err.name = info.Code ? info.Code + 'Error' : 'UnknowError';
          err.status = result.status;
          err.code = info.Code;
          err.requestId = info.RequestId;
          err.hostId = info.HostId;
          err.serverTime = info.ServerTime;

        case 33:

          this.debug('generate error %j', err, 'error');
          return _context2.abrupt('return', err);

        case 35:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, this, [[8, 17]]);
};

}).call(this,require('_process'),require("buffer").Buffer)

},{"../common/multipart":7,"../common/parallel":8,"../common/signUtils":9,"../common/utils":10,"./../../shims/crypto/crypto.js":235,"./managed-upload":3,"./object":4,"./version":5,"_process":171,"agentkeepalive":11,"babel-runtime/core-js/object/assign":17,"babel-runtime/core-js/object/keys":22,"babel-runtime/core-js/promise":23,"babel-runtime/regenerator":32,"bowser":34,"buffer":37,"copy-to":40,"dateformat":151,"debug":153,"humanize-ms":158,"is-type-of":163,"merge-descriptors":166,"mime":240,"path":168,"platform":169,"url":201,"urllib":242,"utility":241,"xml2js":211}],3:[function(require,module,exports){
(function (Buffer){
'use strict';

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// var debug = require('debug')('ali-oss:multipart');
var is = require('is-type-of');
var util = require('util');
var path = require('path');
var mime = require('mime');
var copy = require('copy-to');

var proto = exports;

/**
 * Multipart operations
 */

/**
 * Upload a file to OSS using multipart uploads
 * @param {String} name
 * @param {String|File} file
 * @param {Object} options
 *        {Object} options.callback The callback parameter is composed of a JSON string encoded in Base64
 *        {String} options.callback.url the OSS sends a callback request to this URL
 *        {String} options.callback.host The host header value for initiating callback requests
 *        {String} options.callback.body The value of the request body when a callback is initiated
 *        {String} options.callback.contentType The Content-Type of the callback requests initiatiated
 *        {Object} options.callback.customValue Custom parameters are a map of key-values, e.g:
 *                  customValue = {
 *                    key1: 'value1',
 *                    key2: 'value2'
 *                  }
 */
proto.multipartUpload = function multipartUpload(name, file, options) {
  var minPartSize, fileSize, stream, result, ret, initResult, uploadId, partSize, checkpoint;
  return _regenerator2.default.async(function multipartUpload$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          this.resetCancelFlag();
          options = options || {};

          if (!(options.checkpoint && options.checkpoint.uploadId)) {
            _context.next = 6;
            break;
          }

          _context.next = 5;
          return _regenerator2.default.awrap(this._resumeMultipart(options.checkpoint, options));

        case 5:
          return _context.abrupt('return', _context.sent);

        case 6:
          minPartSize = 100 * 1024;


          if (!options.mime) {
            if (is.file(file)) {
              options.mime = mime.getType(path.extname(file.name));
            } else if (is.blob(file)) {
              options.mime = file.type;
            } else {
              options.mime = mime.getType(path.extname(file));
            }
          }

          options.headers = options.headers || {};
          this._convertMetaToHeaders(options.meta, options.headers);

          _context.next = 12;
          return _regenerator2.default.awrap(this._getFileSize(file));

        case 12:
          fileSize = _context.sent;

          if (!(fileSize < minPartSize)) {
            _context.next = 25;
            break;
          }

          stream = this._createStream(file, 0, fileSize);

          options.contentLength = fileSize;

          _context.next = 18;
          return _regenerator2.default.awrap(this.putStream(name, stream, options));

        case 18:
          result = _context.sent;

          if (!(options && options.progress)) {
            _context.next = 22;
            break;
          }

          _context.next = 22;
          return _regenerator2.default.awrap(options.progress(1));

        case 22:
          ret = {
            res: result.res,
            bucket: this.options.bucket,
            name: name,
            etag: result.res.headers.etag
          };


          if (options.headers && options.headers['x-oss-callback'] || options.callback) {
            ret.data = result.data;
          }

          return _context.abrupt('return', ret);

        case 25:
          if (!(options.partSize && !(parseInt(options.partSize, 10) === options.partSize))) {
            _context.next = 27;
            break;
          }

          throw new Error('partSize must be int number');

        case 27:
          if (!(options.partSize && options.partSize < minPartSize)) {
            _context.next = 29;
            break;
          }

          throw new Error('partSize must not be smaller than ' + minPartSize);

        case 29:
          _context.next = 31;
          return _regenerator2.default.awrap(this.initMultipartUpload(name, options));

        case 31:
          initResult = _context.sent;
          uploadId = initResult.uploadId;
          partSize = this._getPartSize(fileSize, options.partSize);
          checkpoint = {
            file: file,
            name: name,
            fileSize: fileSize,
            partSize: partSize,
            uploadId: uploadId,
            doneParts: []
          };

          if (!(options && options.progress)) {
            _context.next = 38;
            break;
          }

          _context.next = 38;
          return _regenerator2.default.awrap(options.progress(0, checkpoint, initResult.res));

        case 38:
          _context.next = 40;
          return _regenerator2.default.awrap(this._resumeMultipart(checkpoint, options));

        case 40:
          return _context.abrupt('return', _context.sent);

        case 41:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
};

/*
 * Resume multipart upload from checkpoint. The checkpoint will be
 * updated after each successful part upload.
 * @param {Object} checkpoint the checkpoint
 * @param {Object} options
 */
proto._resumeMultipart = function _resumeMultipart(checkpoint, options) {
  var that, file, fileSize, partSize, uploadId, doneParts, name, internalDoneParts, partOffs, numParts, multipartFinish, uploadPartJob, all, done, todo, defaultParallel, parallel, jobErr;
  return _regenerator2.default.async(function _resumeMultipart$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          that = this;

          if (!this.isCancel()) {
            _context3.next = 3;
            break;
          }

          throw this._makeCancelEvent();

        case 3:
          file = checkpoint.file, fileSize = checkpoint.fileSize, partSize = checkpoint.partSize, uploadId = checkpoint.uploadId, doneParts = checkpoint.doneParts, name = checkpoint.name;
          internalDoneParts = [];


          if (doneParts.length > 0) {
            copy(doneParts).to(internalDoneParts);
          }

          partOffs = this._divideParts(fileSize, partSize);
          numParts = partOffs.length;
          multipartFinish = false;

          uploadPartJob = function uploadPartJob(self, partNo) {
            var _this = this;

            return new _promise2.default(function _callee(resolve, reject) {
              var pi, data, result, tempErr;
              return _regenerator2.default.async(function _callee$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.prev = 0;

                      if (self.isCancel()) {
                        _context2.next = 18;
                        break;
                      }

                      pi = partOffs[partNo - 1];
                      data = {
                        stream: self._createStream(file, pi.start, pi.end),
                        size: pi.end - pi.start
                      };
                      _context2.next = 6;
                      return _regenerator2.default.awrap(self._uploadPart(name, uploadId, partNo, data));

                    case 6:
                      result = _context2.sent;

                      if (!(!self.isCancel() && !multipartFinish)) {
                        _context2.next = 15;
                        break;
                      }

                      checkpoint.doneParts.push({
                        number: partNo,
                        etag: result.res.headers.etag
                      });

                      if (!options.progress) {
                        _context2.next = 12;
                        break;
                      }

                      _context2.next = 12;
                      return _regenerator2.default.awrap(options.progress(doneParts.length / numParts, checkpoint, result.res));

                    case 12:

                      resolve({
                        number: partNo,
                        etag: result.res.headers.etag
                      });
                      _context2.next = 16;
                      break;

                    case 15:
                      resolve();

                    case 16:
                      _context2.next = 19;
                      break;

                    case 18:
                      resolve();

                    case 19:
                      _context2.next = 30;
                      break;

                    case 21:
                      _context2.prev = 21;
                      _context2.t0 = _context2['catch'](0);
                      tempErr = new Error();

                      tempErr.name = _context2.t0.name;
                      tempErr.message = _context2.t0.message;
                      tempErr.stack = _context2.t0.stack;
                      tempErr.partNum = partNo;
                      copy(_context2.t0).to(tempErr);
                      reject(tempErr);

                    case 30:
                    case 'end':
                      return _context2.stop();
                  }
                }
              }, null, _this, [[0, 21]]);
            });
          };

          all = (0, _from2.default)(new Array(numParts), function (x, i) {
            return i + 1;
          });
          done = internalDoneParts.map(function (p) {
            return p.number;
          });
          todo = all.filter(function (p) {
            return done.indexOf(p) < 0;
          });
          defaultParallel = 5;
          parallel = options.parallel || defaultParallel;

          // upload in parallel

          _context3.next = 17;
          return _regenerator2.default.awrap(this._parallel(todo, parallel, function (value) {
            return new _promise2.default(function (resolve, reject) {
              uploadPartJob(that, value).then(function (result) {
                if (result) {
                  internalDoneParts.push(result);
                }
                resolve();
              }).catch(function (err) {
                reject(err);
              });
            });
          }));

        case 17:
          jobErr = _context3.sent;

          multipartFinish = true;

          if (!this.isCancel()) {
            _context3.next = 22;
            break;
          }

          uploadPartJob = null;
          throw this._makeCancelEvent();

        case 22:
          if (!(jobErr && jobErr.length > 0)) {
            _context3.next = 25;
            break;
          }

          jobErr[0].message = 'Failed to upload some parts with error: ' + jobErr[0].toString() + ' part_num: ' + jobErr[0].partNum;
          throw jobErr[0];

        case 25:
          _context3.next = 27;
          return _regenerator2.default.awrap(this.completeMultipartUpload(name, uploadId, internalDoneParts, options));

        case 27:
          return _context3.abrupt('return', _context3.sent);

        case 28:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, this);
};

is.file = function file(obj) {
  return typeof File !== 'undefined' && obj instanceof File;
};

is.blob = function (blob) {
  return typeof Blob !== 'undefined' && blob instanceof Blob;
};

/**
 * Get file size
 */
proto._getFileSize = function _getFileSize(file) {
  var stat;
  return _regenerator2.default.async(function _getFileSize$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (!is.buffer(file)) {
            _context4.next = 4;
            break;
          }

          return _context4.abrupt('return', file.length);

        case 4:
          if (!(is.blob(file) || is.file(file))) {
            _context4.next = 6;
            break;
          }

          return _context4.abrupt('return', file.size);

        case 6:
          if (!is.string(file)) {
            _context4.next = 11;
            break;
          }

          _context4.next = 9;
          return _regenerator2.default.awrap(this._statFile(file));

        case 9:
          stat = _context4.sent;
          return _context4.abrupt('return', stat.size);

        case 11:
          throw new Error('_getFileSize requires Buffer/File/String.');

        case 12:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, this);
};

/*
 * Readable stream for Web File
 */

var _require = require('stream'),
    Readable = _require.Readable;

function WebFileReadStream(file, options) {
  if (!(this instanceof WebFileReadStream)) {
    return new WebFileReadStream(file, options);
  }

  Readable.call(this, options);

  this.file = file;
  this.reader = new FileReader();
  this.start = 0;
  this.finish = false;
  this.fileBuffer = null;
}
util.inherits(WebFileReadStream, Readable);

WebFileReadStream.prototype.readFileAndPush = function readFileAndPush(size) {
  if (this.fileBuffer) {
    var pushRet = true;
    while (pushRet && this.fileBuffer && this.start < this.fileBuffer.length) {
      var start = this.start;

      var end = start + size;
      end = end > this.fileBuffer.length ? this.fileBuffer.length : end;
      this.start = end;
      pushRet = this.push(this.fileBuffer.slice(start, end));
    }
  }
};

WebFileReadStream.prototype._read = function _read(size) {
  if (this.file && this.start >= this.file.size || this.fileBuffer && this.start >= this.fileBuffer.length || this.finish || this.start === 0 && !this.file) {
    if (!this.finish) {
      this.fileBuffer = null;
      this.finish = true;
    }
    this.push(null);
    return;
  }

  var defaultReadSize = 16 * 1024;
  size = size || defaultReadSize;

  var that = this;
  this.reader.onload = function onload(e) {
    that.fileBuffer = new Buffer(new Uint8Array(e.target.result));
    that.file = null;
    that.readFileAndPush(size);
  };

  if (this.start === 0) {
    this.reader.readAsArrayBuffer(this.file);
  } else {
    this.readFileAndPush(size);
  }
};

proto._createStream = function _createStream(file, start, end) {
  if (is.blob(file) || is.file(file)) {
    return new WebFileReadStream(file.slice(start, end));
  }
  // else if (is.string(file)) {
  //   return fs.createReadStream(file, {
  //     start: start,
  //     end: end - 1
  //   });
  // }

  throw new Error('_createStream requires File/String.');
};

proto._getPartSize = function _getPartSize(fileSize, partSize) {
  var maxNumParts = 10 * 1000;
  var defaultPartSize = 1024 * 1024;

  if (!partSize) {
    return defaultPartSize;
  }

  return Math.max(Math.ceil(fileSize / maxNumParts), partSize);
};

proto._divideParts = function _divideParts(fileSize, partSize) {
  var numParts = Math.ceil(fileSize / partSize);

  var partOffs = [];
  for (var i = 0; i < numParts; i++) {
    var start = partSize * i;
    var end = Math.min(start + partSize, fileSize);

    partOffs.push({
      start: start,
      end: end
    });
  }

  return partOffs;
};

}).call(this,require("buffer").Buffer)

},{"babel-runtime/core-js/array/from":15,"babel-runtime/core-js/promise":23,"babel-runtime/regenerator":32,"buffer":37,"copy-to":40,"is-type-of":163,"mime":240,"path":168,"stream":193,"util":205}],4:[function(require,module,exports){
'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// const debug = require('debug')('ali-oss:object');
var utility = require('utility');
var fs = require('fs');
var is = require('is-type-of');
var urlutil = require('url');
var copy = require('copy-to');
var path = require('path');
var mime = require('mime');
var callback = require('../common/callback');
var signHelper = require('../common/signUtils');

// var assert = require('assert');


var proto = exports;

/**
 * Object operations
 */

/**
  * append an object from String(file path)/Buffer/ReadableStream
  * @param {String} name the object key
  * @param {Mixed} file String(file path)/Buffer/ReadableStream
  * @param {Object} options
  * @return {Object}
  */
proto.append = function append(name, file, options) {
  var result;
  return _regenerator2.default.async(function append$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = options || {};
          if (options.position === undefined) options.position = '0';
          options.subres = {
            append: '',
            position: options.position
          };
          options.method = 'POST';

          _context.next = 6;
          return _regenerator2.default.awrap(this.put(name, file, options));

        case 6:
          result = _context.sent;

          result.nextAppendPosition = result.res.headers['x-oss-next-append-position'];
          return _context.abrupt('return', result);

        case 9:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
};

/**
 * put an object from String(file path)/Buffer/ReadableStream
 * @param {String} name the object key
 * @param {Mixed} file String(file path)/Buffer/ReadableStream
 * @param {Object} options
 *        {Object} options.callback The callback parameter is composed of a JSON string encoded in Base64
 *        {String} options.callback.url  the OSS sends a callback request to this URL
 *        {String} options.callback.host  The host header value for initiating callback requests
 *        {String} options.callback.body  The value of the request body when a callback is initiated
 *        {String} options.callback.contentType  The Content-Type of the callback requests initiatiated
 *        {Object} options.callback.customValue  Custom parameters are a map of key-values, e.g:
 *                  customValue = {
 *                    key1: 'value1',
 *                    key2: 'value2'
 *                  }
 * @return {Object}
 */
proto.put = function put(name, file, options) {
  var content, stream, _result, method, params, result, ret;

  return _regenerator2.default.async(function put$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          content = void 0;


          options = options || {};

          if (!is.buffer(file)) {
            _context2.next = 6;
            break;
          }

          content = file;
          _context2.next = 19;
          break;

        case 6:
          if (!(is.blob(file) || is.file(file))) {
            _context2.next = 18;
            break;
          }

          if (!options.mime) {
            if (is.file(file)) {
              options.mime = mime.getType(path.extname(file.name));
            } else {
              options.mime = file.type;
            }
          }

          stream = this._createStream(file, 0, file.size);
          _context2.next = 11;
          return _regenerator2.default.awrap(this._getFileSize(file));

        case 11:
          options.contentLength = _context2.sent;
          _context2.next = 14;
          return _regenerator2.default.awrap(this.putStream(name, stream, options));

        case 14:
          _result = _context2.sent;
          return _context2.abrupt('return', _result);

        case 18:
          throw new TypeError('Must provide Buffer/Blob for put.');

        case 19:

          options.headers = options.headers || {};
          this._convertMetaToHeaders(options.meta, options.headers);

          method = options.method || 'PUT';
          params = this._objectRequestParams(method, name, options);

          callback.encodeCallback(params, options);
          params.mime = options.mime;
          params.content = content;
          params.successStatuses = [200];

          _context2.next = 29;
          return _regenerator2.default.awrap(this.request(params));

        case 29:
          result = _context2.sent;
          ret = {
            name: name,
            url: this._objectUrl(name),
            res: result.res
          };


          if (params.headers && params.headers['x-oss-callback']) {
            ret.data = JSON.parse(result.data.toString());
          }

          return _context2.abrupt('return', ret);

        case 33:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, this);
};

/**
 * put an object from ReadableStream. If `options.contentLength` is
 * not provided, chunked encoding is used.
 * @param {String} name the object key
 * @param {Readable} stream the ReadableStream
 * @param {Object} options
 * @return {Object}
 */
proto.putStream = function putStream(name, stream, options) {
  var method, params, result, ret;
  return _regenerator2.default.async(function putStream$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          options = options || {};
          options.headers = options.headers || {};
          if (options.contentLength) {
            options.headers['Content-Length'] = options.contentLength;
          } else {
            options.headers['Transfer-Encoding'] = 'chunked';
          }
          this._convertMetaToHeaders(options.meta, options.headers);

          method = options.method || 'PUT';
          params = this._objectRequestParams(method, name, options);

          callback.encodeCallback(params, options);
          params.mime = options.mime;
          params.stream = stream;
          params.successStatuses = [200];

          _context3.next = 12;
          return _regenerator2.default.awrap(this.request(params));

        case 12:
          result = _context3.sent;
          ret = {
            name: name,
            url: this._objectUrl(name),
            res: result.res
          };


          if (params.headers && params.headers['x-oss-callback']) {
            ret.data = JSON.parse(result.data.toString());
          }

          return _context3.abrupt('return', ret);

        case 16:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, this);
};

proto.head = function head(name, options) {
  var params, result, data;
  return _regenerator2.default.async(function head$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          params = this._objectRequestParams('HEAD', name, options);

          params.successStatuses = [200, 304];

          _context4.next = 4;
          return _regenerator2.default.awrap(this.request(params));

        case 4:
          result = _context4.sent;
          data = {
            meta: null,
            res: result.res,
            status: result.status
          };


          if (result.status === 200) {
            (0, _keys2.default)(result.headers).forEach(function (k) {
              if (k.indexOf('x-oss-meta-') === 0) {
                if (!data.meta) {
                  data.meta = {};
                }
                data.meta[k.substring(11)] = result.headers[k];
              }
            });
          }
          return _context4.abrupt('return', data);

        case 8:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, this);
};

proto.get = function get(name, file, options) {
  var writeStream, needDestroy, result, params;
  return _regenerator2.default.async(function get$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          writeStream = null;
          needDestroy = false;


          if (is.writableStream(file)) {
            writeStream = file;
          } else if (is.string(file)) {
            writeStream = fs.createWriteStream(file);
            needDestroy = true;
          } else {
            // get(name, options)
            options = file;
          }

          options = options || {};
          if (options.process) {
            options.subres = options.subres || {};
            options.subres['x-oss-process'] = options.process;
          }

          result = void 0;
          _context5.prev = 6;
          params = this._objectRequestParams('GET', name, options);

          params.writeStream = writeStream;
          params.successStatuses = [200, 206, 304];

          _context5.next = 12;
          return _regenerator2.default.awrap(this.request(params));

        case 12:
          result = _context5.sent;


          if (needDestroy) {
            writeStream.destroy();
          }
          _context5.next = 24;
          break;

        case 16:
          _context5.prev = 16;
          _context5.t0 = _context5['catch'](6);

          if (!needDestroy) {
            _context5.next = 23;
            break;
          }

          writeStream.destroy();
          // should delete the exists file before throw error
          this.debug('get error: %s, delete the exists file %s', _context5.t0, file, 'error');
          _context5.next = 23;
          return _regenerator2.default.awrap(this._deleteFileSafe(file));

        case 23:
          throw _context5.t0;

        case 24:
          return _context5.abrupt('return', {
            res: result.res,
            content: result.data
          });

        case 25:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, this, [[6, 16]]);
};

proto.delete = function _delete(name, options) {
  var params, result;
  return _regenerator2.default.async(function _delete$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          params = this._objectRequestParams('DELETE', name, options);

          params.successStatuses = [204];

          _context6.next = 4;
          return _regenerator2.default.awrap(this.request(params));

        case 4:
          result = _context6.sent;
          return _context6.abrupt('return', {
            res: result.res
          });

        case 6:
        case 'end':
          return _context6.stop();
      }
    }
  }, null, this);
};

proto.deleteMulti = function deleteMulti(names, options) {
  var xml, i, params, result, r, deleted;
  return _regenerator2.default.async(function deleteMulti$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          options = options || {};
          xml = '<?xml version="1.0" encoding="UTF-8"?>\n<Delete>\n';

          if (options.quiet) {
            xml += '  <Quiet>true</Quiet>\n';
          } else {
            xml += '  <Quiet>false</Quiet>\n';
          }
          for (i = 0; i < names.length; i++) {
            xml += '  <Object><Key>' + utility.escape(this._objectName(names[i])) + '</Key></Object>\n';
          }
          xml += '</Delete>';
          this.debug('delete multi objects: %s', xml, 'info');

          options.subres = 'delete';
          params = this._objectRequestParams('POST', '', options);

          params.mime = 'xml';
          params.content = xml;
          params.xmlResponse = true;
          params.successStatuses = [200];
          _context7.next = 14;
          return _regenerator2.default.awrap(this.request(params));

        case 14:
          result = _context7.sent;
          r = result.data;
          deleted = r && r.Deleted || null;

          if (deleted) {
            if (!Array.isArray(deleted)) {
              deleted = [deleted];
            }
            deleted = deleted.map(function (item) {
              return item.Key;
            });
          }
          return _context7.abrupt('return', {
            res: result.res,
            deleted: deleted
          });

        case 19:
        case 'end':
          return _context7.stop();
      }
    }
  }, null, this);
};

/* eslint no-shadow: [0] */
proto.copy = function copy(name, sourceName, options) {
  var params, result, data;
  return _regenerator2.default.async(function copy$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          options = options || {};
          options.headers = options.headers || {};
          (0, _keys2.default)(options.headers).forEach(function (key) {
            options.headers['x-oss-copy-source-' + key.toLowerCase()] = options.headers[key];
          });

          if (options.meta) {
            options.headers['x-oss-metadata-directive'] = 'REPLACE';
          }
          this._convertMetaToHeaders(options.meta, options.headers);

          if (sourceName[0] !== '/') {
            // no specify bucket name
            sourceName = '/' + this.options.bucket + '/' + encodeURIComponent(sourceName);
          } else {
            sourceName = '/' + encodeURIComponent(sourceName.slice(1));
          }

          options.headers['x-oss-copy-source'] = sourceName;

          params = this._objectRequestParams('PUT', name, options);

          params.xmlResponse = true;
          params.successStatuses = [200, 304];

          _context8.next = 12;
          return _regenerator2.default.awrap(this.request(params));

        case 12:
          result = _context8.sent;
          data = result.data;

          if (data) {
            data = {
              etag: data.ETag,
              lastModified: data.LastModified
            };
          }

          return _context8.abrupt('return', {
            data: data,
            res: result.res
          });

        case 16:
        case 'end':
          return _context8.stop();
      }
    }
  }, null, this);
};

proto.putMeta = function putMeta(name, meta, options) {
  var copyResult;
  return _regenerator2.default.async(function putMeta$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          _context9.next = 2;
          return _regenerator2.default.awrap(this.copy(name, name, {
            meta: meta || {},
            timeout: options && options.timeout,
            ctx: options && options.ctx
          }));

        case 2:
          copyResult = _context9.sent;
          return _context9.abrupt('return', copyResult);

        case 4:
        case 'end':
          return _context9.stop();
      }
    }
  }, null, this);
};

proto.list = function list(query, options) {
  var params, result, objects, that, prefixes;
  return _regenerator2.default.async(function list$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          // prefix, marker, max-keys, delimiter

          params = this._objectRequestParams('GET', '', options);

          params.query = query;
          params.xmlResponse = true;
          params.successStatuses = [200];

          _context10.next = 6;
          return _regenerator2.default.awrap(this.request(params));

        case 6:
          result = _context10.sent;
          objects = result.data.Contents;
          that = this;

          if (objects) {
            if (!Array.isArray(objects)) {
              objects = [objects];
            }
            objects = objects.map(function (obj) {
              return {
                name: obj.Key,
                url: that._objectUrl(obj.Key),
                lastModified: obj.LastModified,
                etag: obj.ETag,
                type: obj.Type,
                size: Number(obj.Size),
                storageClass: obj.StorageClass,
                owner: {
                  id: obj.Owner.ID,
                  displayName: obj.Owner.DisplayName
                }
              };
            });
          }
          prefixes = result.data.CommonPrefixes || null;

          if (prefixes) {
            if (!Array.isArray(prefixes)) {
              prefixes = [prefixes];
            }
            prefixes = prefixes.map(function (item) {
              return item.Prefix;
            });
          }
          return _context10.abrupt('return', {
            res: result.res,
            objects: objects,
            prefixes: prefixes,
            nextMarker: result.data.NextMarker || null,
            isTruncated: result.data.IsTruncated === 'true'
          });

        case 13:
        case 'end':
          return _context10.stop();
      }
    }
  }, null, this);
};

/*
 * Set object's ACL
 * @param {String} name the object key
 * @param {String} acl the object ACL
 * @param {Object} options
 */
proto.putACL = function putACL(name, acl, options) {
  var params, result;
  return _regenerator2.default.async(function putACL$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          options = options || {};
          options.subres = 'acl';
          options.headers = options.headers || {};
          options.headers['x-oss-object-acl'] = acl;
          name = this._objectName(name);

          params = this._objectRequestParams('PUT', name, options);

          params.successStatuses = [200];

          _context11.next = 9;
          return _regenerator2.default.awrap(this.request(params));

        case 9:
          result = _context11.sent;
          return _context11.abrupt('return', {
            res: result.res
          });

        case 11:
        case 'end':
          return _context11.stop();
      }
    }
  }, null, this);
};

/*
 * Get object's ACL
 * @param {String} name the object key
 * @param {Object} options
 * @return {Object}
 */
proto.getACL = function getACL(name, options) {
  var params, result;
  return _regenerator2.default.async(function getACL$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          options = options || {};
          options.subres = 'acl';
          name = this._objectName(name);

          params = this._objectRequestParams('GET', name, options);

          params.successStatuses = [200];
          params.xmlResponse = true;

          _context12.next = 8;
          return _regenerator2.default.awrap(this.request(params));

        case 8:
          result = _context12.sent;
          return _context12.abrupt('return', {
            acl: result.data.AccessControlList.Grant,
            owner: {
              id: result.data.Owner.ID,
              displayName: result.data.Owner.DisplayName
            },
            res: result.res
          });

        case 10:
        case 'end':
          return _context12.stop();
      }
    }
  }, null, this);
};

/**
 * Restore Object
 * @param {String} name the object key
 * @param {Object} options
 * @returns {{res}}
 */
proto.restore = function restore(name, options) {
  var params, result;
  return _regenerator2.default.async(function restore$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          options = options || {};
          options.subres = 'restore';
          params = this._objectRequestParams('POST', name, options);

          params.successStatuses = [202];

          _context13.next = 6;
          return _regenerator2.default.awrap(this.request(params));

        case 6:
          result = _context13.sent;
          return _context13.abrupt('return', {
            res: result.res
          });

        case 8:
        case 'end':
          return _context13.stop();
      }
    }
  }, null, this);
};

proto.signatureUrl = function signatureUrl(name, options) {
  options = options || {};
  name = this._objectName(name);
  options.method = options.method || 'GET';
  var expires = utility.timestamp() + (options.expires || 1800);
  var params = {
    bucket: this.options.bucket,
    object: name
  };

  var resource = this._getResource(params);

  if (this.options.stsToken) {
    options['security-token'] = this.options.stsToken;
  }

  var signRes = signHelper._signatureForURL(this.options.accessKeySecret, options, resource, expires);

  var url = urlutil.parse(this._getReqUrl(params));
  url.query = {
    OSSAccessKeyId: this.options.accessKeyId,
    Expires: expires,
    Signature: signRes.Signature
  };

  copy(signRes.subResource).to(url.query);

  return url.format();
};

/**
 * Get Object url by name
 * @param {String} name - object name
 * @param {String} [baseUrl] - If provide `baseUrl`,
 *        will use `baseUrl` instead the default `endpoint`.
 * @return {String} object url
 */
proto.getObjectUrl = function getObjectUrl(name, baseUrl) {
  if (!baseUrl) {
    baseUrl = this.options.endpoint.format();
  } else if (baseUrl[baseUrl.length - 1] !== '/') {
    baseUrl += '/';
  }
  return baseUrl + this._escape(this._objectName(name));
};

proto._objectUrl = function _objectUrl(name) {
  return this._getReqUrl({ bucket: this.options.bucket, object: name });
};

/**
 * Get Object url by name
 * @param {String} name - object name
 * @param {String} [baseUrl] - If provide `baseUrl`, will use `baseUrl` instead the default `endpoint and bucket`.
 * @return {String} object url include bucket
 */
proto.generateObjectUrl = function (name, baseUrl) {
  if (!baseUrl) {
    baseUrl = this.options.endpoint.format();
    var copyUrl = urlutil.parse(baseUrl);
    var bucket = this.options.bucket;


    copyUrl.hostname = bucket + '.' + copyUrl.hostname;
    copyUrl.host = bucket + '.' + copyUrl.host;
    baseUrl = copyUrl.format();
  } else if (baseUrl[baseUrl.length - 1] !== '/') {
    baseUrl += '/';
  }
  return baseUrl + this._escape(this._objectName(name));
};

/**
 * generator request params
 * @return {Object} params
 *
 * @api private
 */

proto._objectRequestParams = function _objectRequestParams(method, name, options) {
  if (!this.options.bucket) {
    throw new Error('Please create a bucket first');
  }

  options = options || {};
  name = this._objectName(name);
  var params = {
    object: name,
    bucket: this.options.bucket,
    method: method,
    subres: options && options.subres,
    timeout: options && options.timeout,
    ctx: options && options.ctx
  };

  if (options.headers) {
    params.headers = {};
    copy(options.headers).to(params.headers);
  }
  return params;
};

proto._objectName = function _objectName(name) {
  return name.replace(/^\/+/, '');
};

proto._statFile = function _statFile(filepath) {
  return new _promise2.default(function (resolve, reject) {
    fs.stat(filepath, function (err, stats) {
      if (err) {
        reject(err);
      } else {
        resolve(stats);
      }
    });
  });
};

proto._convertMetaToHeaders = function _convertMetaToHeaders(meta, headers) {
  if (!meta) {
    return;
  }

  (0, _keys2.default)(meta).forEach(function (k) {
    headers['x-oss-meta-' + k] = meta[k];
  });
};

proto._deleteFileSafe = function _deleteFileSafe(filepath) {
  var _this = this;

  return new _promise2.default(function (resolve) {
    fs.exists(filepath, function (exists) {
      if (!exists) {
        resolve();
      } else {
        fs.unlink(filepath, function (err) {
          if (err) {
            _this.debug('unlink %j error: %s', filepath, err, 'error');
          }
          resolve();
        });
      }
    });
  });
};

},{"../common/callback":6,"../common/signUtils":9,"babel-runtime/core-js/object/keys":22,"babel-runtime/core-js/promise":23,"babel-runtime/regenerator":32,"copy-to":40,"fs":35,"is-type-of":163,"mime":240,"path":168,"url":201,"utility":241}],5:[function(require,module,exports){
"use strict";

exports.version = "6.1.1";

},{}],6:[function(require,module,exports){
(function (Buffer){
'use strict';

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.encodeCallback = function encodeCallback(reqParams, options) {
  reqParams.headers = reqParams.headers || {};
  if (!Object.prototype.hasOwnProperty.call(reqParams.headers, 'x-oss-callback')) {
    if (options.callback) {
      var json = {
        callbackUrl: encodeURI(options.callback.url),
        callbackBody: options.callback.body
      };
      if (options.callback.host) {
        json.callbackHost = options.callback.host;
      }
      if (options.callback.contentType) {
        json.callbackBodyType = options.callback.contentType;
      }
      var callback = new Buffer((0, _stringify2.default)(json)).toString('base64');
      reqParams.headers['x-oss-callback'] = callback;

      if (options.callback.customValue) {
        var callbackVar = {};
        (0, _keys2.default)(options.callback.customValue).forEach(function (key) {
          callbackVar['x:' + key] = options.callback.customValue[key];
        });
        reqParams.headers['x-oss-callback-var'] = new Buffer((0, _stringify2.default)(callbackVar)).toString('base64');
      }
    }
  }
};

}).call(this,require("buffer").Buffer)

},{"babel-runtime/core-js/json/stringify":16,"babel-runtime/core-js/object/keys":22,"buffer":37}],7:[function(require,module,exports){
'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var copy = require('copy-to');
var callback = require('./callback');

var proto = exports;

/**
 * List the on-going multipart uploads
 * https://help.aliyun.com/document_detail/31997.html
 * @param {Object} options
 * @return {Array} the multipart uploads
 */
proto.listUploads = function listUploads(query, options) {
  var opt, params, result, uploads;
  return _regenerator2.default.async(function listUploads$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = options || {};
          opt = {};

          copy(options).to(opt);
          opt.subres = 'uploads';
          params = this._objectRequestParams('GET', '', opt);

          params.query = query;
          params.xmlResponse = true;
          params.successStatuses = [200];

          _context.next = 10;
          return _regenerator2.default.awrap(this.request(params));

        case 10:
          result = _context.sent;
          uploads = result.data.Upload || [];

          if (!Array.isArray(uploads)) {
            uploads = [uploads];
          }
          uploads = uploads.map(function (up) {
            return {
              name: up.Key,
              uploadId: up.UploadId,
              initiated: up.Initiated
            };
          });

          return _context.abrupt('return', {
            res: result.res,
            uploads: uploads,
            bucket: result.data.Bucket,
            nextKeyMarker: result.data.NextKeyMarker,
            nextUploadIdMarker: result.data.NextUploadIdMarker,
            isTruncated: result.data.IsTruncated === 'true'
          });

        case 15:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
};

/**
 * List the done uploadPart parts
 * @param {String} name object name
 * @param {String} uploadId multipart upload id
 * @param {Object} query
 * {Number} query.max-parts The maximum part number in the response of the OSS. Default value: 1000
 * {Number} query.part-number-marker Starting position of a specific list.
 * {String} query.encoding-type Specify the encoding of the returned content and the encoding type.
 * @param {Object} options
 * @return {Object} result
 */
proto.listParts = function listParts(name, uploadId, query, options) {
  var opt, params, result;
  return _regenerator2.default.async(function listParts$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          options = options || {};
          opt = {};

          copy(options).to(opt);
          opt.subres = {
            uploadId: uploadId
          };
          params = this._objectRequestParams('GET', name, opt);

          params.query = query;
          params.xmlResponse = true;
          params.successStatuses = [200];

          _context2.next = 10;
          return _regenerator2.default.awrap(this.request(params));

        case 10:
          result = _context2.sent;
          return _context2.abrupt('return', {
            res: result.res,
            uploadId: result.data.UploadId,
            bucket: result.data.Bucket,
            name: result.data.Key,
            partNumberMarker: result.data.PartNumberMarker,
            nextPartNumberMarker: result.data.NextPartNumberMarker,
            maxParts: result.data.MaxParts,
            isTruncated: result.data.IsTruncated,
            parts: result.data.Part || []
          });

        case 12:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, this);
};

/**
 * Abort a multipart upload transaction
 * @param {String} name the object name
 * @param {String} uploadId the upload id
 * @param {Object} options
 */
proto.abortMultipartUpload = function abortMultipartUpload(name, uploadId, options) {
  var opt, params, result;
  return _regenerator2.default.async(function abortMultipartUpload$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          this._stop();
          options = options || {};
          opt = {};

          copy(options).to(opt);
          opt.subres = { uploadId: uploadId };
          params = this._objectRequestParams('DELETE', name, opt);

          params.successStatuses = [204];

          _context3.next = 9;
          return _regenerator2.default.awrap(this.request(params));

        case 9:
          result = _context3.sent;
          return _context3.abrupt('return', {
            res: result.res
          });

        case 11:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, this);
};

/**
 * Initiate a multipart upload transaction
 * @param {String} name the object name
 * @param {Object} options
 * @return {String} upload id
 */
proto.initMultipartUpload = function initMultipartUpload(name, options) {
  var opt, params, result;
  return _regenerator2.default.async(function initMultipartUpload$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          options = options || {};
          opt = {};

          copy(options).to(opt);
          opt.headers = opt.headers || {};
          this._convertMetaToHeaders(options.meta, opt.headers);

          opt.subres = 'uploads';
          params = this._objectRequestParams('POST', name, opt);

          params.mime = options.mime;
          params.xmlResponse = true;
          params.successStatuses = [200];

          _context4.next = 12;
          return _regenerator2.default.awrap(this.request(params));

        case 12:
          result = _context4.sent;
          return _context4.abrupt('return', {
            res: result.res,
            bucket: result.data.Bucket,
            name: result.data.Key,
            uploadId: result.data.UploadId
          });

        case 14:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, this);
};

/**
 * Upload a part in a multipart upload transaction
 * @param {String} name the object name
 * @param {String} uploadId the upload id
 * @param {Integer} partNo the part number
 * @param {File} file upload File, whole File
 * @param {Integer} start  part start bytes  e.g: 102400
 * @param {Integer} end  part end bytes  e.g: 204800
 * @param {Object} options
 */
proto.uploadPart = function uploadPart(name, uploadId, partNo, file, start, end, options) {
  var data;
  return _regenerator2.default.async(function uploadPart$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          data = {
            stream: this._createStream(file, start, end),
            size: end - start
          };
          _context5.next = 3;
          return _regenerator2.default.awrap(this._uploadPart(name, uploadId, partNo, data, options));

        case 3:
          return _context5.abrupt('return', _context5.sent);

        case 4:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, this);
};

/**
 * Complete a multipart upload transaction
 * @param {String} name the object name
 * @param {String} uploadId the upload id
 * @param {Array} parts the uploaded parts, each in the structure:
 *        {Integer} number partNo
 *        {String} etag  part etag  uploadPartCopy result.res.header.etag
 * @param {Object} options
 *         {Object} options.callback The callback parameter is composed of a JSON string encoded in Base64
 *         {String} options.callback.url  the OSS sends a callback request to this URL
 *         {String} options.callback.host  The host header value for initiating callback requests
 *         {String} options.callback.body  The value of the request body when a callback is initiated
 *         {String} options.callback.contentType  The Content-Type of the callback requests initiatiated
 *         {Object} options.callback.customValue  Custom parameters are a map of key-values, e.g:
 *                   customValue = {
 *                     key1: 'value1',
 *                     key2: 'value2'
 *                   }
 */
proto.completeMultipartUpload = function completeMultipartUpload(name, uploadId, parts, options) {
  var completeParts, xml, i, p, opt, params, result, ret;
  return _regenerator2.default.async(function completeMultipartUpload$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          completeParts = parts.concat().sort(function (a, b) {
            return a.number - b.number;
          }).filter(function (item, index, arr) {
            return !index || item.number !== arr[index - 1].number;
          });
          xml = '<?xml version="1.0" encoding="UTF-8"?>\n<CompleteMultipartUpload>\n';

          for (i = 0; i < completeParts.length; i++) {
            p = completeParts[i];

            xml += '<Part>\n';
            xml += '<PartNumber>' + p.number + '</PartNumber>\n';
            xml += '<ETag>' + p.etag + '</ETag>\n';
            xml += '</Part>\n';
          }
          xml += '</CompleteMultipartUpload>';

          options = options || {};
          opt = {};

          copy(options).to(opt);
          opt.subres = { uploadId: uploadId };

          params = this._objectRequestParams('POST', name, opt);

          callback.encodeCallback(params, opt);
          params.mime = 'xml';
          params.content = xml;

          if (!(params.headers && params.headers['x-oss-callback'])) {
            params.xmlResponse = true;
          }
          params.successStatuses = [200];
          _context6.next = 16;
          return _regenerator2.default.awrap(this.request(params));

        case 16:
          result = _context6.sent;
          ret = {
            res: result.res,
            bucket: params.bucket,
            name: name,
            etag: result.res.headers.etag
          };


          if (params.headers && params.headers['x-oss-callback']) {
            ret.data = JSON.parse(result.data.toString());
          }

          return _context6.abrupt('return', ret);

        case 20:
        case 'end':
          return _context6.stop();
      }
    }
  }, null, this);
};

/**
 * Upload a part in a multipart upload transaction
 * @param {String} name the object name
 * @param {String} uploadId the upload id
 * @param {Integer} partNo the part number
 * @param {Object} data the body data
 * @param {Object} options
 */
proto._uploadPart = function _uploadPart(name, uploadId, partNo, data, options) {
  var opt, params, result;
  return _regenerator2.default.async(function _uploadPart$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          options = options || {};
          opt = {};

          copy(options).to(opt);
          opt.headers = {
            'Content-Length': data.size
          };

          opt.subres = {
            partNumber: partNo,
            uploadId: uploadId
          };
          params = this._objectRequestParams('PUT', name, opt);

          params.mime = opt.mime;
          params.stream = data.stream;
          params.successStatuses = [200];

          _context7.next = 11;
          return _regenerator2.default.awrap(this.request(params));

        case 11:
          result = _context7.sent;


          data.stream = null;
          params.stream = null;
          return _context7.abrupt('return', {
            name: name,
            etag: result.res.headers.etag,
            res: result.res
          });

        case 15:
        case 'end':
          return _context7.stop();
      }
    }
  }, null, this);
};

},{"./callback":6,"babel-runtime/regenerator":32,"copy-to":40}],8:[function(require,module,exports){
'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var proto = exports;

proto._parallelNode = function _parallelNode(todo, parallel, fn, sourceData) {
  var that, jobErr, jobs, tempBatch, remainder, batch, taskIndex, i;
  return _regenerator2.default.async(function _parallelNode$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          that = this;
          // upload in parallel

          jobErr = [];
          jobs = [];
          tempBatch = todo.length / parallel;
          remainder = todo.length % parallel;
          batch = remainder === 0 ? tempBatch : (todo.length - remainder) / parallel + 1;
          taskIndex = 1;
          i = 0;

        case 8:
          if (!(i < todo.length)) {
            _context.next = 26;
            break;
          }

          if (!that.isCancel()) {
            _context.next = 11;
            break;
          }

          return _context.abrupt('break', 26);

        case 11:

          if (sourceData) {
            jobs.push(fn(that, todo[i], sourceData));
          } else {
            jobs.push(fn(that, todo[i]));
          }

          if (!(jobs.length === parallel || taskIndex === batch && i === todo.length - 1)) {
            _context.next = 23;
            break;
          }

          _context.prev = 13;

          taskIndex += 1;
          /* eslint no-await-in-loop: [0] */
          _context.next = 17;
          return _regenerator2.default.awrap(_promise2.default.all(jobs));

        case 17:
          _context.next = 22;
          break;

        case 19:
          _context.prev = 19;
          _context.t0 = _context['catch'](13);

          jobErr.push(_context.t0);

        case 22:
          jobs = [];

        case 23:
          i++;
          _context.next = 8;
          break;

        case 26:
          return _context.abrupt('return', jobErr);

        case 27:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this, [[13, 19]]);
};

proto._parallel = function _parallel(todo, parallel, jobPromise) {
  var that = this;
  return new _promise2.default(function (resolve) {
    var _jobErr = [];
    if (parallel <= 0 || !todo) {
      resolve(_jobErr);
      return;
    }

    function onlyOnce(fn) {
      return function () {
        if (fn === null) throw new Error('Callback was already called.');
        var callFn = fn;
        fn = null;

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        callFn.apply(this, args);
      };
    }

    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len && !that.isCancel() ? { value: coll[i], key: i } : null;
      };
    }

    var nextElem = createArrayIterator(todo);
    var done = false;
    var running = 0;
    var looping = false;

    function iterateeCallback(err, value) {
      running -= 1;
      if (err) {
        done = true;
        _jobErr.push(err);
        resolve(_jobErr);
      } else if (value === {} || done && running <= 0) {
        done = true;
        resolve(_jobErr);
      } else if (!looping) {
        /* eslint no-use-before-define: [0] */
        if (that.isCancel()) {
          resolve(_jobErr);
        } else {
          replenish();
        }
      }
    }

    function iteratee(value, callback) {
      jobPromise(value).then(function (result) {
        callback(null, result);
      }).catch(function (err) {
        callback(err);
      });
    }

    function replenish() {
      looping = true;
      while (running < parallel && !done && !that.isCancel()) {
        var elem = nextElem();
        if (elem === null || _jobErr.length > 0) {
          done = true;
          if (running <= 0) {
            resolve(_jobErr);
          }
          return;
        }
        running += 1;
        iteratee(elem.value, onlyOnce(iterateeCallback));
      }
      looping = false;
    }

    replenish();
  });
};

/**
 * cancel operation, now can use with multipartUpload
 * @param {Object} abort
 *        {String} anort.name object key
 *        {String} anort.uploadId upload id
 *        {String} anort.options timeout
 */
proto.cancel = function cancel(abort) {
  this.options.cancelFlag = true;
  if (abort) {
    this.abortMultipartUpload(abort.name, abort.uploadId, abort.options);
  }
};

proto.isCancel = function isCancel() {
  return this.options.cancelFlag;
};

proto.resetCancelFlag = function resetCancelFlag() {
  this.options.cancelFlag = false;
};

proto._stop = function _stop() {
  this.options.cancelFlag = true;
};

// cancel is not error , so create an object
proto._makeCancelEvent = function _makeCancelEvent() {
  var cancelEvent = {
    status: 0,
    name: 'cancel'
  };
  return cancelEvent;
};

},{"babel-runtime/core-js/promise":23,"babel-runtime/regenerator":32}],9:[function(require,module,exports){
(function (Buffer){
'use strict';

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var crypto = require('./../../shims/crypto/crypto.js');
var is = require('is-type-of');

/**
 *
 * @param {String} resourcePath
 * @param {Object} parameters
 * @return
 */
exports.buildCanonicalizedResource = function buildCanonicalizedResource(resourcePath, parameters) {
  var canonicalizedResource = '' + resourcePath;
  var separatorString = '?';

  if (is.string(parameters) && parameters.trim() !== '') {
    canonicalizedResource += separatorString + parameters;
  } else if (is.array(parameters)) {
    parameters.sort();
    canonicalizedResource += separatorString + parameters.join('&');
  } else if (parameters) {
    var compareFunc = function compareFunc(entry1, entry2) {
      if (entry1[0] > entry2[0]) {
        return 1;
      } else if (entry1[0] < entry2[0]) {
        return -1;
      }
      return 0;
    };
    var processFunc = function processFunc(key) {
      canonicalizedResource += separatorString + key;
      if (parameters[key]) {
        canonicalizedResource += '=' + parameters[key];
      }
      separatorString = '&';
    };
    (0, _keys2.default)(parameters).sort(compareFunc).forEach(processFunc);
  }

  return canonicalizedResource;
};

/**
 * @param {String} method
 * @param {String} resourcePath
 * @param {Object} request
 * @param {String} expires
 * @return {String} canonicalString
 */
exports.buildCanonicalString = function canonicalString(method, resourcePath, request, expires) {
  request = request || {};
  var headers = request.headers || {};
  var OSS_PREFIX = 'x-oss-';
  var ossHeaders = [];
  var headersToSign = {};

  var signContent = [method.toUpperCase(), headers['Content-Md5'] || '', headers['Content-Type'] || headers['Content-Type'.toLowerCase()], expires || headers['x-oss-date']];

  (0, _keys2.default)(headers).forEach(function (key) {
    var lowerKey = key.toLowerCase();
    if (lowerKey.indexOf(OSS_PREFIX) === 0) {
      headersToSign[lowerKey] = String(headers[key]).trim();
    }
  });

  (0, _keys2.default)(headersToSign).sort().forEach(function (key) {
    ossHeaders.push(key + ':' + headersToSign[key]);
  });

  signContent = signContent.concat(ossHeaders);

  signContent.push(this.buildCanonicalizedResource(resourcePath, request.parameters));

  return signContent.join('\n');
};

/**
 * @param {String} accessKeySecret
 * @param {String} canonicalString
 */
exports.computeSignature = function computeSignature(accessKeySecret, canonicalString) {
  var signature = crypto.createHmac('sha1', accessKeySecret);
  return signature.update(new Buffer(canonicalString, 'utf8')).digest('base64');
};

/**
 * @param {String} accessKeyId
 * @param {String} accessKeySecret
 * @param {String} canonicalString
 */
exports.authorization = function authorization(accessKeyId, accessKeySecret, canonicalString) {
  return 'OSS ' + accessKeyId + ':' + this.computeSignature(accessKeySecret, canonicalString);
};

/**
 *
 * @param {String} accessKeySecret
 * @param {Object} options
 * @param {String} resource
 * @param {Number} expires
 */
exports._signatureForURL = function _signatureForURL(accessKeySecret, options, resource, expires) {
  var headers = {};
  var subResource = {};

  if (options.process) {
    var processKeyword = 'x-oss-process';
    subResource[processKeyword] = options.process;
  }

  if (options.response) {
    (0, _keys2.default)(options.response).forEach(function (k) {
      var key = 'response-' + k.toLowerCase();
      subResource[key] = options.response[k];
    });
  }

  (0, _keys2.default)(options).forEach(function (key) {
    var lowerKey = key.toLowerCase();
    var value = options[key];
    if (lowerKey.indexOf('x-oss-') === 0) {
      headers[lowerKey] = value;
    } else if (lowerKey.indexOf('content-md5') === 0) {
      headers[key] = value;
    } else if (lowerKey.indexOf('content-type') === 0) {
      headers[key] = value;
    } else if (lowerKey !== 'expires' && lowerKey !== 'response' && lowerKey !== 'process' && lowerKey !== 'method') {
      subResource[lowerKey] = value;
    }
  });

  if (Object.prototype.hasOwnProperty.call(options, 'security-token')) {
    subResource['security-token'] = options['security-token'];
  }

  if (Object.prototype.hasOwnProperty.call(options, 'callback')) {
    var json = {
      callbackUrl: encodeURI(options.callback.url),
      callbackBody: options.callback.body
    };
    if (options.callback.host) {
      json.callbackHost = options.callback.host;
    }
    if (options.callback.contentType) {
      json.callbackBodyType = options.callback.contentType;
    }
    subResource.callback = new Buffer((0, _stringify2.default)(json)).toString('base64');

    if (options.callback.customValue) {
      var callbackVar = {};
      (0, _keys2.default)(options.callback.customValue).forEach(function (key) {
        callbackVar['x:' + key] = options.callback.customValue[key];
      });
      subResource['callback-var'] = new Buffer((0, _stringify2.default)(callbackVar)).toString('base64');
    }
  }

  var canonicalString = this.buildCanonicalString(options.method, resource, {
    headers: headers,
    parameters: subResource
  }, expires.toString());

  return {
    Signature: this.computeSignature(accessKeySecret, canonicalString),
    subResource: subResource
  };
};

}).call(this,require("buffer").Buffer)

},{"./../../shims/crypto/crypto.js":235,"babel-runtime/core-js/json/stringify":16,"babel-runtime/core-js/object/keys":22,"buffer":37,"is-type-of":163}],10:[function(require,module,exports){
"use strict";

// it provide commont methods for node and browser , we will add more solutions later in this file

/**
 * Judge isIP include ipv4 or ipv6
 * @param {String} options
 * @return {Array} the multipart uploads
 */
exports._isIP = function (host) {
  var ipv4Regex = /^(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}$/;
  var ipv6Regex = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
  var isIP = ipv4Regex.test(host) || ipv6Regex.test(host);
  return isIP;
};

},{}],11:[function(require,module,exports){
module.exports = noop;
module.exports.HttpsAgent = noop;

// Noop function for browser since native api's don't use agents.
function noop () {}

},{}],12:[function(require,module,exports){
module.exports = require('./register')().Promise

},{"./register":14}],13:[function(require,module,exports){
"use strict"
    // global key for user preferred registration
var REGISTRATION_KEY = '@@any-promise/REGISTRATION',
    // Prior registration (preferred or detected)
    registered = null

/**
 * Registers the given implementation.  An implementation must
 * be registered prior to any call to `require("any-promise")`,
 * typically on application load.
 *
 * If called with no arguments, will return registration in
 * following priority:
 *
 * For Node.js:
 *
 * 1. Previous registration
 * 2. global.Promise if node.js version >= 0.12
 * 3. Auto detected promise based on first sucessful require of
 *    known promise libraries. Note this is a last resort, as the
 *    loaded library is non-deterministic. node.js >= 0.12 will
 *    always use global.Promise over this priority list.
 * 4. Throws error.
 *
 * For Browser:
 *
 * 1. Previous registration
 * 2. window.Promise
 * 3. Throws error.
 *
 * Options:
 *
 * Promise: Desired Promise constructor
 * global: Boolean - Should the registration be cached in a global variable to
 * allow cross dependency/bundle registration?  (default true)
 */
module.exports = function(root, loadImplementation){
  return function register(implementation, opts){
    implementation = implementation || null
    opts = opts || {}
    // global registration unless explicitly  {global: false} in options (default true)
    var registerGlobal = opts.global !== false;

    // load any previous global registration
    if(registered === null && registerGlobal){
      registered = root[REGISTRATION_KEY] || null
    }

    if(registered !== null
        && implementation !== null
        && registered.implementation !== implementation){
      // Throw error if attempting to redefine implementation
      throw new Error('any-promise already defined as "'+registered.implementation+
        '".  You can only register an implementation before the first '+
        ' call to require("any-promise") and an implementation cannot be changed')
    }

    if(registered === null){
      // use provided implementation
      if(implementation !== null && typeof opts.Promise !== 'undefined'){
        registered = {
          Promise: opts.Promise,
          implementation: implementation
        }
      } else {
        // require implementation if implementation is specified but not provided
        registered = loadImplementation(implementation)
      }

      if(registerGlobal){
        // register preference globally in case multiple installations
        root[REGISTRATION_KEY] = registered
      }
    }

    return registered
  }
}

},{}],14:[function(require,module,exports){
"use strict";
module.exports = require('./loader')(window, loadImplementation)

/**
 * Browser specific loadImplementation.  Always uses `window.Promise`
 *
 * To register a custom implementation, must register with `Promise` option.
 */
function loadImplementation(){
  if(typeof window.Promise === 'undefined'){
    throw new Error("any-promise browser requires a polyfill or explicit registration"+
      " e.g: require('any-promise/register/bluebird')")
  }
  return {
    Promise: window.Promise,
    implementation: 'window.Promise'
  }
}

},{"./loader":13}],15:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":41}],16:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/json/stringify"), __esModule: true };
},{"core-js/library/fn/json/stringify":42}],17:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":43}],18:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":44}],19:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":45}],20:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-names"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-names":46}],21:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/get-prototype-of":47}],22:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":48}],23:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":49}],24:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set-immediate"), __esModule: true };
},{"core-js/library/fn/set-immediate":50}],25:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/string/from-code-point"), __esModule: true };
},{"core-js/library/fn/string/from-code-point":51}],26:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":53}],27:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/has-instance"), __esModule: true };
},{"core-js/library/fn/symbol/has-instance":52}],28:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":54}],29:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],30:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
},{"../core-js/object/define-property":19}],31:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":26,"../core-js/symbol/iterator":28}],32:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":189}],33:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],34:[function(require,module,exports){
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (root, name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(name, definition)
  else root[name] = definition()
}(this, 'bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
      , chromeos = /CrOS/.test(ua)
      , silk = /silk/i.test(ua)
      , sailfish = /sailfish/i.test(ua)
      , tizen = /tizen/i.test(ua)
      , webos = /(web|hpw)(o|0)s/i.test(ua)
      , windowsphone = /windows phone/i.test(ua)
      , samsungBrowser = /SamsungBrowser/i.test(ua)
      , windows = !windowsphone && /windows/i.test(ua)
      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
      , edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , xbox = /xbox/i.test(ua)
      , result

    if (/opera/i.test(ua)) {
      //  an old Opera
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      }
    } else if (/opr\/|opios/i.test(ua)) {
      // a new Opera
      result = {
        name: 'Opera'
        , opera: t
        , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/SamsungBrowser/i.test(ua)) {
      result = {
        name: 'Samsung Internet for Android'
        , samsungBrowser: t
        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/Whale/i.test(ua)) {
      result = {
        name: 'NAVER Whale browser'
        , whale: t
        , version: getFirstMatch(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/MZBrowser/i.test(ua)) {
      result = {
        name: 'MZ Browser'
        , mzbrowser: t
        , version: getFirstMatch(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/coast/i.test(ua)) {
      result = {
        name: 'Opera Coast'
        , coast: t
        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/focus/i.test(ua)) {
      result = {
        name: 'Focus'
        , focus: t
        , version: getFirstMatch(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/ucbrowser/i.test(ua)) {
      result = {
          name: 'UC Browser'
        , ucbrowser: t
        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/mxios/i.test(ua)) {
      result = {
        name: 'Maxthon'
        , maxthon: t
        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/epiphany/i.test(ua)) {
      result = {
        name: 'Epiphany'
        , epiphany: t
        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/puffin/i.test(ua)) {
      result = {
        name: 'Puffin'
        , puffin: t
        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      }
    }
    else if (/sleipnir/i.test(ua)) {
      result = {
        name: 'Sleipnir'
        , sleipnir: t
        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/k-meleon/i.test(ua)) {
      result = {
        name: 'K-Meleon'
        , kMeleon: t
        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (windowsphone) {
      result = {
        name: 'Windows Phone'
      , osname: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeos) {
      result = {
        name: 'Chrome'
      , osname: 'Chrome OS'
      , chromeos: t
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/edg([ea]|ios)/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/vivaldi/i.test(ua)) {
      result = {
        name: 'Vivaldi'
        , vivaldi: t
        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (sailfish) {
      result = {
        name: 'Sailfish'
      , osname: 'Sailfish OS'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel|fxios/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
        result.osname = 'Firefox OS'
      }
    }
    else if (silk) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/slimerjs/i.test(ua)) {
      result = {
        name: 'SlimerJS'
        , slimer: t
        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , osname: 'BlackBerry OS'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (webos) {
      result = {
        name: 'WebOS'
      , osname: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , osname: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (tizen) {
      result = {
        name: 'Tizen'
      , osname: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/qupzilla/i.test(ua)) {
      result = {
        name: 'QupZilla'
        , qupzilla: t
        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
      }
    }
    else if (/chromium/i.test(ua)) {
      result = {
        name: 'Chromium'
        , chromium: t
        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
        , chrome: t
        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
        , version: versionIdentifier
      }
    }
    else if (/safari|applewebkit/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      }
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if(/googlebot/i.test(ua)) {
      result = {
        name: 'Googlebot'
      , googlebot: t
      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      if (/(apple)?webkit\/537\.36/i.test(ua)) {
        result.name = result.name || "Blink"
        result.blink = t
      } else {
        result.name = result.name || "Webkit"
        result.webkit = t
      }
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.windowsphone && (android || result.silk)) {
      result.android = t
      result.osname = 'Android'
    } else if (!result.windowsphone && iosdevice) {
      result[iosdevice] = t
      result.ios = t
      result.osname = 'iOS'
    } else if (mac) {
      result.mac = t
      result.osname = 'macOS'
    } else if (xbox) {
      result.xbox = t
      result.osname = 'Xbox'
    } else if (windows) {
      result.windows = t
      result.osname = 'Windows'
    } else if (linux) {
      result.linux = t
      result.osname = 'Linux'
    }

    function getWindowsVersion (s) {
      switch (s) {
        case 'NT': return 'NT'
        case 'XP': return 'XP'
        case 'NT 5.0': return '2000'
        case 'NT 5.1': return 'XP'
        case 'NT 5.2': return '2003'
        case 'NT 6.0': return 'Vista'
        case 'NT 6.1': return '7'
        case 'NT 6.2': return '8'
        case 'NT 6.3': return '8.1'
        case 'NT 10.0': return '10'
        default: return undefined
      }
    }

    // OS version extraction
    var osVersion = '';
    if (result.windows) {
      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i))
    } else if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (result.mac) {
      osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = !result.windows && osVersion.split('.')[0];
    if (
         tablet
      || nexusTablet
      || iosdevice == 'ipad'
      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
      || result.silk
    ) {
      result.tablet = t
    } else if (
         mobile
      || iosdevice == 'iphone'
      || iosdevice == 'ipod'
      || android
      || nexusMobile
      || result.blackberry
      || result.webos
      || result.bada
    ) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
		    (result.vivaldi && result.version >= 1.0) ||
        (result.chrome && result.version >= 20) ||
        (result.samsungBrowser && result.version >= 4) ||
        (result.whale && compareVersions([result.version, '1.0']) === 1) ||
        (result.mzbrowser && compareVersions([result.version, '6.0']) === 1) ||
        (result.focus && compareVersions([result.version, '1.0']) === 1) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        || (result.chromium && result.version >= 20)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        || (result.chromium && result.version < 20)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  function getVersionPrecision(version) {
    return version.split(".").length;
  }

  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  function map(arr, iterator) {
    var result = [], i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i++) {
      result.push(iterator(arr[i]));
    }
    return result;
  }

  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
   *
   * @param  {Array<String>} versions versions to compare
   * @return {Number} comparison result
   */
  function compareVersions(versions) {
    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
    var chunks = map(versions, function (version) {
      var delta = precision - getVersionPrecision(version);

      // 2) "9" -> "9.0" (for precision = 2)
      version = version + new Array(delta + 1).join(".0");

      // 3) "9.0" -> ["000000000"", "000000009"]
      return map(version.split("."), function (chunk) {
        return new Array(20 - chunk.length).join("0") + chunk;
      }).reverse();
    });

    // iterate in reverse order by reversed chunks array
    while (--precision >= 0) {
      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      else if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === 0) {
          // all version chunks are same
          return 0;
        }
      }
      else {
        return -1;
      }
    }
  }

  /**
   * Check if browser is unsupported
   *
   * @example
   *   bowser.isUnsupportedBrowser({
   *     msie: "10",
   *     firefox: "23",
   *     chrome: "29",
   *     safari: "5.1",
   *     opera: "16",
   *     phantom: "534"
   *   });
   *
   * @param  {Object}  minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function isUnsupportedBrowser(minVersions, strictMode, ua) {
    var _bowser = bowser;

    // make strictMode param optional with ua param usage
    if (typeof strictMode === 'string') {
      ua = strictMode;
      strictMode = void(0);
    }

    if (strictMode === void(0)) {
      strictMode = false;
    }
    if (ua) {
      _bowser = detect(ua);
    }

    var version = "" + _bowser.version;
    for (var browser in minVersions) {
      if (minVersions.hasOwnProperty(browser)) {
        if (_bowser[browser]) {
          if (typeof minVersions[browser] !== 'string') {
            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
          }

          // browser version and min supported version.
          return compareVersions([version, minVersions[browser]]) < 0;
        }
      }
    }

    return strictMode; // not found
  }

  /**
   * Check if browser is supported
   *
   * @param  {Object} minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function check(minVersions, strictMode, ua) {
    return !isUnsupportedBrowser(minVersions, strictMode, ua);
  }

  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
  bowser.compareVersions = compareVersions;
  bowser.check = check;

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  /*
   * Set our detect public method to the main bowser object
   * This is needed to implement bowser in server side
   */
  bowser.detect = detect;
  return bowser
});

},{}],35:[function(require,module,exports){

},{}],36:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":37}],37:[function(require,module,exports){
(function (global,Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"base64-js":33,"buffer":37,"ieee754":159,"isarray":164}],38:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],39:[function(require,module,exports){
module.exports={
  "O_RDONLY": 0,
  "O_WRONLY": 1,
  "O_RDWR": 2,
  "S_IFMT": 61440,
  "S_IFREG": 32768,
  "S_IFDIR": 16384,
  "S_IFCHR": 8192,
  "S_IFBLK": 24576,
  "S_IFIFO": 4096,
  "S_IFLNK": 40960,
  "S_IFSOCK": 49152,
  "O_CREAT": 512,
  "O_EXCL": 2048,
  "O_NOCTTY": 131072,
  "O_TRUNC": 1024,
  "O_APPEND": 8,
  "O_DIRECTORY": 1048576,
  "O_NOFOLLOW": 256,
  "O_SYNC": 128,
  "O_SYMLINK": 2097152,
  "O_NONBLOCK": 4,
  "S_IRWXU": 448,
  "S_IRUSR": 256,
  "S_IWUSR": 128,
  "S_IXUSR": 64,
  "S_IRWXG": 56,
  "S_IRGRP": 32,
  "S_IWGRP": 16,
  "S_IXGRP": 8,
  "S_IRWXO": 7,
  "S_IROTH": 4,
  "S_IWOTH": 2,
  "S_IXOTH": 1,
  "E2BIG": 7,
  "EACCES": 13,
  "EADDRINUSE": 48,
  "EADDRNOTAVAIL": 49,
  "EAFNOSUPPORT": 47,
  "EAGAIN": 35,
  "EALREADY": 37,
  "EBADF": 9,
  "EBADMSG": 94,
  "EBUSY": 16,
  "ECANCELED": 89,
  "ECHILD": 10,
  "ECONNABORTED": 53,
  "ECONNREFUSED": 61,
  "ECONNRESET": 54,
  "EDEADLK": 11,
  "EDESTADDRREQ": 39,
  "EDOM": 33,
  "EDQUOT": 69,
  "EEXIST": 17,
  "EFAULT": 14,
  "EFBIG": 27,
  "EHOSTUNREACH": 65,
  "EIDRM": 90,
  "EILSEQ": 92,
  "EINPROGRESS": 36,
  "EINTR": 4,
  "EINVAL": 22,
  "EIO": 5,
  "EISCONN": 56,
  "EISDIR": 21,
  "ELOOP": 62,
  "EMFILE": 24,
  "EMLINK": 31,
  "EMSGSIZE": 40,
  "EMULTIHOP": 95,
  "ENAMETOOLONG": 63,
  "ENETDOWN": 50,
  "ENETRESET": 52,
  "ENETUNREACH": 51,
  "ENFILE": 23,
  "ENOBUFS": 55,
  "ENODATA": 96,
  "ENODEV": 19,
  "ENOENT": 2,
  "ENOEXEC": 8,
  "ENOLCK": 77,
  "ENOLINK": 97,
  "ENOMEM": 12,
  "ENOMSG": 91,
  "ENOPROTOOPT": 42,
  "ENOSPC": 28,
  "ENOSR": 98,
  "ENOSTR": 99,
  "ENOSYS": 78,
  "ENOTCONN": 57,
  "ENOTDIR": 20,
  "ENOTEMPTY": 66,
  "ENOTSOCK": 38,
  "ENOTSUP": 45,
  "ENOTTY": 25,
  "ENXIO": 6,
  "EOPNOTSUPP": 102,
  "EOVERFLOW": 84,
  "EPERM": 1,
  "EPIPE": 32,
  "EPROTO": 100,
  "EPROTONOSUPPORT": 43,
  "EPROTOTYPE": 41,
  "ERANGE": 34,
  "EROFS": 30,
  "ESPIPE": 29,
  "ESRCH": 3,
  "ESTALE": 70,
  "ETIME": 101,
  "ETIMEDOUT": 60,
  "ETXTBSY": 26,
  "EWOULDBLOCK": 35,
  "EXDEV": 18,
  "SIGHUP": 1,
  "SIGINT": 2,
  "SIGQUIT": 3,
  "SIGILL": 4,
  "SIGTRAP": 5,
  "SIGABRT": 6,
  "SIGIOT": 6,
  "SIGBUS": 10,
  "SIGFPE": 8,
  "SIGKILL": 9,
  "SIGUSR1": 30,
  "SIGSEGV": 11,
  "SIGUSR2": 31,
  "SIGPIPE": 13,
  "SIGALRM": 14,
  "SIGTERM": 15,
  "SIGCHLD": 20,
  "SIGCONT": 19,
  "SIGSTOP": 17,
  "SIGTSTP": 18,
  "SIGTTIN": 21,
  "SIGTTOU": 22,
  "SIGURG": 16,
  "SIGXCPU": 24,
  "SIGXFSZ": 25,
  "SIGVTALRM": 26,
  "SIGPROF": 27,
  "SIGWINCH": 28,
  "SIGIO": 23,
  "SIGSYS": 12,
  "SSL_OP_ALL": 2147486719,
  "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
  "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
  "SSL_OP_CISCO_ANYCONNECT": 32768,
  "SSL_OP_COOKIE_EXCHANGE": 8192,
  "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
  "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
  "SSL_OP_EPHEMERAL_RSA": 0,
  "SSL_OP_LEGACY_SERVER_CONNECT": 4,
  "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 32,
  "SSL_OP_MICROSOFT_SESS_ID_BUG": 1,
  "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
  "SSL_OP_NETSCAPE_CA_DN_BUG": 536870912,
  "SSL_OP_NETSCAPE_CHALLENGE_BUG": 2,
  "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 1073741824,
  "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 8,
  "SSL_OP_NO_COMPRESSION": 131072,
  "SSL_OP_NO_QUERY_MTU": 4096,
  "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
  "SSL_OP_NO_SSLv2": 16777216,
  "SSL_OP_NO_SSLv3": 33554432,
  "SSL_OP_NO_TICKET": 16384,
  "SSL_OP_NO_TLSv1": 67108864,
  "SSL_OP_NO_TLSv1_1": 268435456,
  "SSL_OP_NO_TLSv1_2": 134217728,
  "SSL_OP_PKCS1_CHECK_1": 0,
  "SSL_OP_PKCS1_CHECK_2": 0,
  "SSL_OP_SINGLE_DH_USE": 1048576,
  "SSL_OP_SINGLE_ECDH_USE": 524288,
  "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 128,
  "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
  "SSL_OP_TLS_BLOCK_PADDING_BUG": 512,
  "SSL_OP_TLS_D5_BUG": 256,
  "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
  "ENGINE_METHOD_DSA": 2,
  "ENGINE_METHOD_DH": 4,
  "ENGINE_METHOD_RAND": 8,
  "ENGINE_METHOD_ECDH": 16,
  "ENGINE_METHOD_ECDSA": 32,
  "ENGINE_METHOD_CIPHERS": 64,
  "ENGINE_METHOD_DIGESTS": 128,
  "ENGINE_METHOD_STORE": 256,
  "ENGINE_METHOD_PKEY_METHS": 512,
  "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
  "ENGINE_METHOD_ALL": 65535,
  "ENGINE_METHOD_NONE": 0,
  "DH_CHECK_P_NOT_SAFE_PRIME": 2,
  "DH_CHECK_P_NOT_PRIME": 1,
  "DH_UNABLE_TO_CHECK_GENERATOR": 4,
  "DH_NOT_SUITABLE_GENERATOR": 8,
  "NPN_ENABLED": 1,
  "RSA_PKCS1_PADDING": 1,
  "RSA_SSLV23_PADDING": 2,
  "RSA_NO_PADDING": 3,
  "RSA_PKCS1_OAEP_PADDING": 4,
  "RSA_X931_PADDING": 5,
  "RSA_PKCS1_PSS_PADDING": 6,
  "POINT_CONVERSION_COMPRESSED": 2,
  "POINT_CONVERSION_UNCOMPRESSED": 4,
  "POINT_CONVERSION_HYBRID": 6,
  "F_OK": 0,
  "R_OK": 4,
  "W_OK": 2,
  "X_OK": 1,
  "UV_UDP_REUSEADDR": 4
}

},{}],40:[function(require,module,exports){
/*!
 * copy-to - index.js
 * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
 * MIT Licensed
 */

'use strict';

/**
 * slice() reference.
 */

var slice = Array.prototype.slice;

/**
 * Expose copy
 *
 * ```
 * copy({foo: 'nar', hello: 'copy'}).to({hello: 'world'});
 * copy({foo: 'nar', hello: 'copy'}).toCover({hello: 'world'});
 * ```
 *
 * @param {Object} src
 * @return {Copy}
 */

module.exports = Copy;


/**
 * Copy
 * @param {Object} src
 * @param {Boolean} withAccess
 */

function Copy(src, withAccess) {
  if (!(this instanceof Copy)) return new Copy(src, withAccess);
  this.src = src;
  this._withAccess = withAccess;
}

/**
 * copy properties include getter and setter
 * @param {[type]} val [description]
 * @return {[type]} [description]
 */

Copy.prototype.withAccess = function (w) {
  this._withAccess = w !== false;
  return this;
};

/**
 * pick keys in src
 *
 * @api: public
 */

Copy.prototype.pick = function(keys) {
  if (!Array.isArray(keys)) {
    keys = slice.call(arguments);
  }
  if (keys.length) {
    this.keys = keys;
  }
  return this;
};

/**
 * copy src to target,
 * do not cover any property target has
 * @param {Object} to
 *
 * @api: public
 */

Copy.prototype.to = function(to) {
  to = to || {};

  if (!this.src) return to;
  var keys = this.keys || Object.keys(this.src);

  if (!this._withAccess) {
    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      if (to[key] !== undefined) continue;
      to[key] = this.src[key];
    }
    return to;
  }

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!notDefined(to, key)) continue;
    var getter = this.src.__lookupGetter__(key);
    var setter = this.src.__lookupSetter__(key);
    if (getter) to.__defineGetter__(key, getter);
    if (setter) to.__defineSetter__(key, setter);

    if (!getter && !setter) {
      to[key] = this.src[key];
    }
  }
  return to;
};

/**
 * copy src to target,
 * override any property target has
 * @param {Object} to
 *
 * @api: public
 */

Copy.prototype.toCover = function(to) {
  var keys = this.keys || Object.keys(this.src);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    delete to[key];
    var getter = this.src.__lookupGetter__(key);
    var setter = this.src.__lookupSetter__(key);
    if (getter) to.__defineGetter__(key, getter);
    if (setter) to.__defineSetter__(key, setter);

    if (!getter && !setter) {
      to[key] = this.src[key];
    }
  }
};

Copy.prototype.override = Copy.prototype.toCover;

/**
 * append another object to src
 * @param {Obj} obj
 * @return {Copy}
 */

Copy.prototype.and = function (obj) {
  var src = {};
  this.to(src);
  this.src = obj;
  this.to(src);
  this.src = src;

  return this;
};

/**
 * check obj[key] if not defiend
 * @param {Object} obj
 * @param {String} key
 * @return {Boolean}
 */

function notDefined(obj, key) {
  return obj[key] === undefined
    && obj.__lookupGetter__(key) === undefined
    && obj.__lookupSetter__(key) === undefined;
}

},{}],41:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;

},{"../../modules/_core":62,"../../modules/es6.array.from":130,"../../modules/es6.string.iterator":142}],42:[function(require,module,exports){
var core = require('../../modules/_core');
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};

},{"../../modules/_core":62}],43:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;

},{"../../modules/_core":62,"../../modules/es6.object.assign":133}],44:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};

},{"../../modules/_core":62,"../../modules/es6.object.create":134}],45:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

},{"../../modules/_core":62,"../../modules/es6.object.define-property":135}],46:[function(require,module,exports){
require('../../modules/es6.object.get-own-property-names');
var $Object = require('../../modules/_core').Object;
module.exports = function getOwnPropertyNames(it) {
  return $Object.getOwnPropertyNames(it);
};

},{"../../modules/_core":62,"../../modules/es6.object.get-own-property-names":136}],47:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/_core').Object.getPrototypeOf;

},{"../../modules/_core":62,"../../modules/es6.object.get-prototype-of":137}],48:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;

},{"../../modules/_core":62,"../../modules/es6.object.keys":138}],49:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
require('../modules/es7.promise.finally');
require('../modules/es7.promise.try');
module.exports = require('../modules/_core').Promise;

},{"../modules/_core":62,"../modules/es6.object.to-string":139,"../modules/es6.promise":140,"../modules/es6.string.iterator":142,"../modules/es7.promise.finally":144,"../modules/es7.promise.try":145,"../modules/web.dom.iterable":148}],50:[function(require,module,exports){
require('../modules/web.immediate');
module.exports = require('../modules/_core').setImmediate;

},{"../modules/_core":62,"../modules/web.immediate":149}],51:[function(require,module,exports){
require('../../modules/es6.string.from-code-point');
module.exports = require('../../modules/_core').String.fromCodePoint;

},{"../../modules/_core":62,"../../modules/es6.string.from-code-point":141}],52:[function(require,module,exports){
require('../../modules/es6.function.has-instance');
module.exports = require('../../modules/_wks-ext').f('hasInstance');

},{"../../modules/_wks-ext":127,"../../modules/es6.function.has-instance":132}],53:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":62,"../../modules/es6.object.to-string":139,"../../modules/es6.symbol":143,"../../modules/es7.symbol.async-iterator":146,"../../modules/es7.symbol.observable":147}],54:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":127,"../../modules/es6.string.iterator":142,"../../modules/web.dom.iterable":148}],55:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],56:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],57:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],58:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":82}],59:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":118,"./_to-iobject":120,"./_to-length":121}],60:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":61,"./_wks":128}],61:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],62:[function(require,module,exports){
var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],63:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":95,"./_property-desc":108}],64:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":55}],65:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],66:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":71}],67:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":73,"./_is-object":82}],68:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],69:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":100,"./_object-keys":103,"./_object-pie":104}],70:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":62,"./_ctx":64,"./_global":73,"./_has":74,"./_hide":75}],71:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],72:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":58,"./_ctx":64,"./_is-array-iter":80,"./_iter-call":83,"./_to-length":121,"./core.get-iterator-method":129}],73:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],74:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],75:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":66,"./_object-dp":95,"./_property-desc":108}],76:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":73}],77:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":66,"./_dom-create":67,"./_fails":71}],78:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],79:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":61}],80:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":88,"./_wks":128}],81:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":61}],82:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],83:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":58}],84:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":75,"./_object-create":94,"./_property-desc":108,"./_set-to-string-tag":112,"./_wks":128}],85:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":70,"./_hide":75,"./_iter-create":84,"./_iterators":88,"./_library":89,"./_object-gpo":101,"./_redefine":110,"./_set-to-string-tag":112,"./_wks":128}],86:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":128}],87:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],88:[function(require,module,exports){
module.exports = {};

},{}],89:[function(require,module,exports){
module.exports = true;

},{}],90:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":71,"./_has":74,"./_is-object":82,"./_object-dp":95,"./_uid":124}],91:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":61,"./_global":73,"./_task":117}],92:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":55}],93:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":71,"./_iobject":79,"./_object-gops":100,"./_object-keys":103,"./_object-pie":104,"./_to-object":122}],94:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":58,"./_dom-create":67,"./_enum-bug-keys":68,"./_html":76,"./_object-dps":96,"./_shared-key":113}],95:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":58,"./_descriptors":66,"./_ie8-dom-define":77,"./_to-primitive":123}],96:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":58,"./_descriptors":66,"./_object-dp":95,"./_object-keys":103}],97:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":66,"./_has":74,"./_ie8-dom-define":77,"./_object-pie":104,"./_property-desc":108,"./_to-iobject":120,"./_to-primitive":123}],98:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":99,"./_to-iobject":120}],99:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":68,"./_object-keys-internal":102}],100:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],101:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":74,"./_shared-key":113,"./_to-object":122}],102:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":59,"./_has":74,"./_shared-key":113,"./_to-iobject":120}],103:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":68,"./_object-keys-internal":102}],104:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],105:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":62,"./_export":70,"./_fails":71}],106:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],107:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":58,"./_is-object":82,"./_new-promise-capability":92}],108:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],109:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

},{"./_hide":75}],110:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":75}],111:[function(require,module,exports){
'use strict';
var global = require('./_global');
var core = require('./_core');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_core":62,"./_descriptors":66,"./_global":73,"./_object-dp":95,"./_wks":128}],112:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":74,"./_object-dp":95,"./_wks":128}],113:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":114,"./_uid":124}],114:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":62,"./_global":73,"./_library":89}],115:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":55,"./_an-object":58,"./_wks":128}],116:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":65,"./_to-integer":119}],117:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":61,"./_ctx":64,"./_dom-create":67,"./_global":73,"./_html":76,"./_invoke":78}],118:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":119}],119:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],120:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":65,"./_iobject":79}],121:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":119}],122:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":65}],123:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":82}],124:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],125:[function(require,module,exports){
var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":73}],126:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":62,"./_global":73,"./_library":89,"./_object-dp":95,"./_wks-ext":127}],127:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":128}],128:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":73,"./_shared":114,"./_uid":124}],129:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":60,"./_core":62,"./_iterators":88,"./_wks":128}],130:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":63,"./_ctx":64,"./_export":70,"./_is-array-iter":80,"./_iter-call":83,"./_iter-detect":86,"./_to-length":121,"./_to-object":122,"./core.get-iterator-method":129}],131:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":56,"./_iter-define":85,"./_iter-step":87,"./_iterators":88,"./_to-iobject":120}],132:[function(require,module,exports){
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":82,"./_object-dp":95,"./_object-gpo":101,"./_wks":128}],133:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":70,"./_object-assign":93}],134:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":70,"./_object-create":94}],135:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":66,"./_export":70,"./_object-dp":95}],136:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-gopn-ext":98,"./_object-sap":105}],137:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":101,"./_object-sap":105,"./_to-object":122}],138:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":103,"./_object-sap":105,"./_to-object":122}],139:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],140:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":55,"./_an-instance":57,"./_classof":60,"./_core":62,"./_ctx":64,"./_export":70,"./_for-of":72,"./_global":73,"./_is-object":82,"./_iter-detect":86,"./_library":89,"./_microtask":91,"./_new-promise-capability":92,"./_perform":106,"./_promise-resolve":107,"./_redefine-all":109,"./_set-species":111,"./_set-to-string-tag":112,"./_species-constructor":115,"./_task":117,"./_user-agent":125,"./_wks":128}],141:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":70,"./_to-absolute-index":118}],142:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":85,"./_string-at":116}],143:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":58,"./_descriptors":66,"./_enum-keys":69,"./_export":70,"./_fails":71,"./_global":73,"./_has":74,"./_hide":75,"./_is-array":81,"./_is-object":82,"./_library":89,"./_meta":90,"./_object-create":94,"./_object-dp":95,"./_object-gopd":97,"./_object-gopn":99,"./_object-gopn-ext":98,"./_object-gops":100,"./_object-keys":103,"./_object-pie":104,"./_property-desc":108,"./_redefine":110,"./_set-to-string-tag":112,"./_shared":114,"./_to-iobject":120,"./_to-primitive":123,"./_uid":124,"./_wks":128,"./_wks-define":126,"./_wks-ext":127}],144:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":62,"./_export":70,"./_global":73,"./_promise-resolve":107,"./_species-constructor":115}],145:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":70,"./_new-promise-capability":92,"./_perform":106}],146:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":126}],147:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":126}],148:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":73,"./_hide":75,"./_iterators":88,"./_wks":128,"./es6.array.iterator":131}],149:[function(require,module,exports){
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":70,"./_task":117}],150:[function(require,module,exports){
(function (Buffer){
'use strict';

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":161,"babel-runtime/helpers/typeof":31}],151:[function(require,module,exports){
'use strict';

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */

(function (global) {
  'use strict';

  var dateFormat = function () {
    var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|'[^']*'|'[^']*'/g;
    var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
    var timezoneClip = /[^-+\dA-Z]/g;

    // Regexes and supporting functions are cached through closure
    return function (date, mask, utc, gmt) {

      // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
      if (arguments.length === 1 && kindOf(date) === 'string' && !/\d/.test(date)) {
        mask = date;
        date = undefined;
      }

      date = date || new Date();

      if (!(date instanceof Date)) {
        date = new Date(date);
      }

      if (isNaN(date)) {
        throw TypeError('Invalid date');
      }

      mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);

      // Allow setting the utc/gmt argument via the mask
      var maskSlice = mask.slice(0, 4);
      if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {
        mask = mask.slice(4);
        utc = true;
        if (maskSlice === 'GMT:') {
          gmt = true;
        }
      }

      var _ = utc ? 'getUTC' : 'get';
      var d = date[_ + 'Date']();
      var D = date[_ + 'Day']();
      var m = date[_ + 'Month']();
      var y = date[_ + 'FullYear']();
      var H = date[_ + 'Hours']();
      var M = date[_ + 'Minutes']();
      var s = date[_ + 'Seconds']();
      var L = date[_ + 'Milliseconds']();
      var o = utc ? 0 : date.getTimezoneOffset();
      var W = getWeek(date);
      var N = getDayOfWeek(date);
      var flags = {
        d: d,
        dd: pad(d),
        ddd: dateFormat.i18n.dayNames[D],
        dddd: dateFormat.i18n.dayNames[D + 7],
        m: m + 1,
        mm: pad(m + 1),
        mmm: dateFormat.i18n.monthNames[m],
        mmmm: dateFormat.i18n.monthNames[m + 12],
        yy: String(y).slice(2),
        yyyy: y,
        h: H % 12 || 12,
        hh: pad(H % 12 || 12),
        H: H,
        HH: pad(H),
        M: M,
        MM: pad(M),
        s: s,
        ss: pad(s),
        l: pad(L, 3),
        L: pad(Math.round(L / 10)),
        t: H < 12 ? 'a' : 'p',
        tt: H < 12 ? 'am' : 'pm',
        T: H < 12 ? 'A' : 'P',
        TT: H < 12 ? 'AM' : 'PM',
        Z: gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
        o: (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
        S: ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
        W: W,
        N: N
      };

      return mask.replace(token, function (match) {
        if (match in flags) {
          return flags[match];
        }
        return match.slice(1, match.length - 1);
      });
    };
  }();

  dateFormat.masks = {
    'default': 'ddd mmm dd yyyy HH:MM:ss',
    'shortDate': 'm/d/yy',
    'mediumDate': 'mmm d, yyyy',
    'longDate': 'mmmm d, yyyy',
    'fullDate': 'dddd, mmmm d, yyyy',
    'shortTime': 'h:MM TT',
    'mediumTime': 'h:MM:ss TT',
    'longTime': 'h:MM:ss TT Z',
    'isoDate': 'yyyy-mm-dd',
    'isoTime': 'HH:MM:ss',
    'isoDateTime': 'yyyy-mm-dd\'T\'HH:MM:sso',
    'isoUtcDateTime': 'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
    'expiresHeaderFormat': 'ddd, dd mmm yyyy HH:MM:ss Z'
  };

  // Internationalization strings
  dateFormat.i18n = {
    dayNames: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    monthNames: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  };

  function pad(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = '0' + val;
    }
    return val;
  }

  /**
   * Get the ISO 8601 week number
   * Based on comments from
   * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
   *
   * @param  {Object} `date`
   * @return {Number}
   */
  function getWeek(date) {
    // Remove time components of date
    var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

    // Change date to Thursday same week
    targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3);

    // Take January 4th as it is always in week 1 (see ISO 8601)
    var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

    // Change date to Thursday same week
    firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);

    // Check if daylight-saving-time-switch occurred and correct for it
    var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
    targetThursday.setHours(targetThursday.getHours() - ds);

    // Number of weeks between target Thursday and first Thursday
    var weekDiff = (targetThursday - firstThursday) / (86400000 * 7);
    return 1 + Math.floor(weekDiff);
  }

  /**
   * Get ISO-8601 numeric representation of the day of the week
   * 1 (for Monday) through 7 (for Sunday)
   * 
   * @param  {Object} `date`
   * @return {Number}
   */
  function getDayOfWeek(date) {
    var dow = date.getDay();
    if (dow === 0) {
      dow = 7;
    }
    return dow;
  }

  /**
   * kind-of shortcut
   * @param  {*} val
   * @return {String}
   */
  function kindOf(val) {
    if (val === null) {
      return 'null';
    }

    if (val === undefined) {
      return 'undefined';
    }

    if ((typeof val === 'undefined' ? 'undefined' : (0, _typeof3.default)(val)) !== 'object') {
      return typeof val === 'undefined' ? 'undefined' : (0, _typeof3.default)(val);
    }

    if (Array.isArray(val)) {
      return 'array';
    }

    return {}.toString.call(val).slice(8, -1).toLowerCase();
  };

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return dateFormat;
    });
  } else if ((typeof exports === 'undefined' ? 'undefined' : (0, _typeof3.default)(exports)) === 'object') {
    module.exports = dateFormat;
  } else {
    global.dateFormat = dateFormat;
  }
})(undefined);

},{"babel-runtime/helpers/typeof":31}],152:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],153:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":154,"_process":171}],154:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":152}],155:[function(require,module,exports){
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

'use strict';

/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}

},{}],156:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],157:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    params.protocol = 'https:';
    return http.request.call(this, params, cb);
}

},{"http":194}],158:[function(require,module,exports){
/*!
 * humanize-ms - index.js
 * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
 * MIT Licensed
 */

'use strict';

/**
 * Module dependencies.
 */

var util = require('util');
var ms = require('ms');

module.exports = function (t) {
  if (typeof t === 'number') return t;
  var r = ms(t);
  if (r === undefined) {
    var err = new Error(util.format('humanize-ms(%j) result undefined', t));
    console.warn(err.stack);
  }
  return r;
};

},{"ms":167,"util":205}],159:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],160:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],161:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],162:[function(require,module,exports){
(function(root) {
  var toString = Function.prototype.toString;

  function fnBody(fn) {
    return toString.call(fn).replace(/^[^{]*{\s*/,'').replace(/\s*}[^}]*$/,'');
  }

  function isClass(fn) {
    return (typeof fn === 'function' &&
            (/^class(?:\s|{)/.test(toString.call(fn)) ||
              (/^.*classCallCheck\(/.test(fnBody(fn)))) // babel.js
            );
  }

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = isClass;
    }
    exports.isClass = isClass;
  } else if (typeof define === 'function' && define.amd) {
    define([], function() {
      return isClass;
    });
  } else {
    root.isClass = isClass;
  }

})(this);

},{}],163:[function(require,module,exports){
'use strict';

var utils = require('core-util-is');
var isStearm = require('isstream');
// wait for https://github.com/miguelmota/is-class/pull/6 merge
var isClass = require('is-class-hotfix');

/**
 * Expose all methods in core-util-is
 */

Object.keys(utils).map(function (name) {
  exports[transform(name)] = utils[name];
});

/**
 * Stream detected by isstream
 */

exports.stream = isStearm;
exports.readableStream = isStearm.isReadable;
exports.writableStream = isStearm.isWritable;
exports.duplexStream = isStearm.isDuplex;

/**
 * Class detected by is-class
 */
 exports.class = isClass;

/**
 * Extend method
 */

exports.finite = Number.isFinite;

exports.NaN = Number.isNaN

exports.generator = function (obj) {
  return obj
    && 'function' === typeof obj.next
    && 'function' === typeof obj.throw;
};

exports.generatorFunction = function (obj) {
  return obj
    && obj.constructor
    && 'GeneratorFunction' === obj.constructor.name;
};

exports.asyncFunction = function (obj) {
  return obj
    && obj.constructor
    && 'AsyncFunction' === obj.constructor.name;
};

exports.promise = function (obj) {
  return obj
    && 'function' === typeof obj.then;
};

var MAX_INT_31 = Math.pow(2, 31);

exports.int = function (obj) {
  return utils.isNumber(obj)
    && obj % 1 === 0;
};

exports.int32 = function (obj) {
  return exports.int(obj)
    && obj < MAX_INT_31
    && obj >= -MAX_INT_31;
};

exports.long = function (obj) {
  return exports.int(obj)
    && (obj >= MAX_INT_31 || obj < -MAX_INT_31);
};

exports.Long = function (obj) {
  return exports.object(obj)
    && exports.number(obj.high)
    && exports.number(obj.low);
};

exports.double = function (obj) {
  return utils.isNumber(obj)
    && !isNaN(obj)
    && obj % 1 !== 0;
};

/**
 * override core-util-is
 */

exports.date = function isDate(obj) {
  return obj instanceof Date;
};

exports.regExp = function isRegExp(obj) {
  return obj instanceof RegExp;
};
exports.regexp = exports.regExp;

exports.error = function isError(obj) {
  return obj instanceof Error;
};

exports.array = Array.isArray;

/**
 * transform isNull type to null
 * @param {[type]} m [description]
 * @return {[type]} [description]
 */

function transform(m) {
  var name = m.slice(2);
  name = name[0].toLowerCase() + name.slice(1);
  return name;
}

},{"core-util-is":150,"is-class-hotfix":162,"isstream":165}],164:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],165:[function(require,module,exports){
var stream = require('stream')


function isStream (obj) {
  return obj instanceof stream.Stream
}


function isReadable (obj) {
  return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
}


function isWritable (obj) {
  return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
}


function isDuplex (obj) {
  return isReadable(obj) && isWritable(obj)
}


module.exports            = isStream
module.exports.isReadable = isReadable
module.exports.isWritable = isWritable
module.exports.isDuplex   = isDuplex

},{"stream":193}],166:[function(require,module,exports){
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module exports.
 * @public
 */

module.exports = merge

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * Merge the property descriptors of `src` into `dest`
 *
 * @param {object} dest Object to add descriptors to
 * @param {object} src Object to clone descriptors from
 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
 * @returns {object} Reference to dest
 * @public
 */

function merge(dest, src, redefine) {
  if (!dest) {
    throw new TypeError('argument dest is required')
  }

  if (!src) {
    throw new TypeError('argument src is required')
  }

  if (redefine === undefined) {
    // Default to true
    redefine = true
  }

  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
    if (!redefine && hasOwnProperty.call(dest, name)) {
      // Skip desriptor
      return
    }

    // Copy descriptor
    var descriptor = Object.getOwnPropertyDescriptor(src, name)
    Object.defineProperty(dest, name, descriptor)
  })

  return dest
}

},{}],167:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],168:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":171}],169:[function(require,module,exports){
(function (global){
/*!
 * Platform.js <https://mths.be/platform>
 * Copyright 2014-2018 Benjamin Tan <https://bnjmnt4n.now.sh/>
 * Copyright 2011-2013 John-David Dalton <http://allyoucanleet.com/>
 * Available under MIT license <https://mths.be/mit>
 */
;(function() {
  'use strict';

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object. */
  var root = (objectTypes[typeof window] && window) || this;

  /** Backup possible global object. */
  var oldRoot = root;

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /**
   * Used as the maximum length of an array-like object.
   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   */
  var maxSafeInteger = Math.pow(2, 53) - 1;

  /** Regular expression to detect Opera. */
  var reOpera = /\bOpera/;

  /** Possible global object. */
  var thisBinding = this;

  /** Used for native method references. */
  var objectProto = Object.prototype;

  /** Used to check for own properties of an object. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to resolve the internal `[[Class]]` of values. */
  var toString = objectProto.toString;

  /*--------------------------------------------------------------------------*/

  /**
   * Capitalizes a string value.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} The capitalized string.
   */
  function capitalize(string) {
    string = String(string);
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * A utility function to clean up the OS name.
   *
   * @private
   * @param {string} os The OS name to clean up.
   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
   * @param {string} [label] A label for the OS.
   */
  function cleanupOS(os, pattern, label) {
    // Platform tokens are defined at:
    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    var data = {
      '10.0': '10',
      '6.4':  '10 Technical Preview',
      '6.3':  '8.1',
      '6.2':  '8',
      '6.1':  'Server 2008 R2 / 7',
      '6.0':  'Server 2008 / Vista',
      '5.2':  'Server 2003 / XP 64-bit',
      '5.1':  'XP',
      '5.01': '2000 SP1',
      '5.0':  '2000',
      '4.0':  'NT',
      '4.90': 'ME'
    };
    // Detect Windows version from platform tokens.
    if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) &&
        (data = data[/[\d.]+$/.exec(os)])) {
      os = 'Windows ' + data;
    }
    // Correct character case and cleanup string.
    os = String(os);

    if (pattern && label) {
      os = os.replace(RegExp(pattern, 'i'), label);
    }

    os = format(
      os.replace(/ ce$/i, ' CE')
        .replace(/\bhpw/i, 'web')
        .replace(/\bMacintosh\b/, 'Mac OS')
        .replace(/_PowerPC\b/i, ' OS')
        .replace(/\b(OS X) [^ \d]+/i, '$1')
        .replace(/\bMac (OS X)\b/, '$1')
        .replace(/\/(\d)/, ' $1')
        .replace(/_/g, '.')
        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
        .replace(/\bx86\.64\b/gi, 'x86_64')
        .replace(/\b(Windows Phone) OS\b/, '$1')
        .replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1')
        .split(' on ')[0]
    );

    return os;
  }

  /**
   * An iteration utility for arrays and objects.
   *
   * @private
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   */
  function each(object, callback) {
    var index = -1,
        length = object ? object.length : 0;

    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
      while (++index < length) {
        callback(object[index], index, object);
      }
    } else {
      forOwn(object, callback);
    }
  }

  /**
   * Trim and conditionally capitalize string values.
   *
   * @private
   * @param {string} string The string to format.
   * @returns {string} The formatted string.
   */
  function format(string) {
    string = trim(string);
    return /^(?:webOS|i(?:OS|P))/.test(string)
      ? string
      : capitalize(string);
  }

  /**
   * Iterates over an object's own properties, executing the `callback` for each.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   */
  function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }

  /**
   * Gets the internal `[[Class]]` of a value.
   *
   * @private
   * @param {*} value The value.
   * @returns {string} The `[[Class]]`.
   */
  function getClassOf(value) {
    return value == null
      ? capitalize(value)
      : toString.call(value).slice(8, -1);
  }

  /**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of "object", "function", or "unknown".
   *
   * @private
   * @param {*} object The owner of the property.
   * @param {string} property The property to check.
   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
   */
  function isHostType(object, property) {
    var type = object != null ? typeof object[property] : 'number';
    return !/^(?:boolean|number|string|undefined)$/.test(type) &&
      (type == 'object' ? !!object[property] : true);
  }

  /**
   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
   *
   * @private
   * @param {string} string The string to qualify.
   * @returns {string} The qualified string.
   */
  function qualify(string) {
    return String(string).replace(/([ -])(?!$)/g, '$1?');
  }

  /**
   * A bare-bones `Array#reduce` like utility function.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @returns {*} The accumulated result.
   */
  function reduce(array, callback) {
    var accumulator = null;
    each(array, function(value, index) {
      accumulator = callback(accumulator, value, index, array);
    });
    return accumulator;
  }

  /**
   * Removes leading and trailing whitespace from a string.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} The trimmed string.
   */
  function trim(string) {
    return String(string).replace(/^ +| +$/g, '');
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a new platform object.
   *
   * @memberOf platform
   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
   *  context object.
   * @returns {Object} A platform object.
   */
  function parse(ua) {

    /** The environment context object. */
    var context = root;

    /** Used to flag when a custom context is provided. */
    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

    // Juggle arguments.
    if (isCustomContext) {
      context = ua;
      ua = null;
    }

    /** Browser navigator object. */
    var nav = context.navigator || {};

    /** Browser user agent string. */
    var userAgent = nav.userAgent || '';

    ua || (ua = userAgent);

    /** Used to flag when `thisBinding` is the [ModuleScope]. */
    var isModuleScope = isCustomContext || thisBinding == oldRoot;

    /** Used to detect if browser is like Chrome. */
    var likeChrome = isCustomContext
      ? !!nav.likeChrome
      : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

    /** Internal `[[Class]]` value shortcuts. */
    var objectClass = 'Object',
        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
        enviroClass = isCustomContext ? objectClass : 'Environment',
        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

    /** Detect Java environments. */
    var java = /\bJava/.test(javaClass) && context.java;

    /** Detect Rhino. */
    var rhino = java && getClassOf(context.environment) == enviroClass;

    /** A character to represent alpha. */
    var alpha = java ? 'a' : '\u03b1';

    /** A character to represent beta. */
    var beta = java ? 'b' : '\u03b2';

    /** Browser document object. */
    var doc = context.document || {};

    /**
     * Detect Opera browser (Presto-based).
     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
     */
    var opera = context.operamini || context.opera;

    /** Opera `[[Class]]`. */
    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
      ? operaClass
      : (opera = null);

    /*------------------------------------------------------------------------*/

    /** Temporary variable used over the script's lifetime. */
    var data;

    /** The CPU architecture. */
    var arch = ua;

    /** Platform description array. */
    var description = [];

    /** Platform alpha/beta indicator. */
    var prerelease = null;

    /** A flag to indicate that environment features should be used to resolve the platform. */
    var useFeatures = ua == userAgent;

    /** The browser/environment version. */
    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

    /** A flag to indicate if the OS ends with "/ Version" */
    var isSpecialCasedOS;

    /* Detectable layout engines (order is important). */
    var layout = getLayout([
      { 'label': 'EdgeHTML', 'pattern': 'Edge' },
      'Trident',
      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
      'iCab',
      'Presto',
      'NetFront',
      'Tasman',
      'KHTML',
      'Gecko'
    ]);

    /* Detectable browser names (order is important). */
    var name = getName([
      'Adobe AIR',
      'Arora',
      'Avant Browser',
      'Breach',
      'Camino',
      'Electron',
      'Epiphany',
      'Fennec',
      'Flock',
      'Galeon',
      'GreenBrowser',
      'iCab',
      'Iceweasel',
      'K-Meleon',
      'Konqueror',
      'Lunascape',
      'Maxthon',
      { 'label': 'Microsoft Edge', 'pattern': 'Edge' },
      'Midori',
      'Nook Browser',
      'PaleMoon',
      'PhantomJS',
      'Raven',
      'Rekonq',
      'RockMelt',
      { 'label': 'Samsung Internet', 'pattern': 'SamsungBrowser' },
      'SeaMonkey',
      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Sleipnir',
      'SlimBrowser',
      { 'label': 'SRWare Iron', 'pattern': 'Iron' },
      'Sunrise',
      'Swiftfox',
      'Waterfox',
      'WebPositive',
      'Opera Mini',
      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
      'Opera',
      { 'label': 'Opera', 'pattern': 'OPR' },
      'Chrome',
      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
      { 'label': 'Firefox for iOS', 'pattern': 'FxiOS' },
      { 'label': 'IE', 'pattern': 'IEMobile' },
      { 'label': 'IE', 'pattern': 'MSIE' },
      'Safari'
    ]);

    /* Detectable products (order is important). */
    var product = getProduct([
      { 'label': 'BlackBerry', 'pattern': 'BB10' },
      'BlackBerry',
      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
      { 'label': 'Galaxy S5', 'pattern': 'SM-G900' },
      { 'label': 'Galaxy S6', 'pattern': 'SM-G920' },
      { 'label': 'Galaxy S6 Edge', 'pattern': 'SM-G925' },
      { 'label': 'Galaxy S7', 'pattern': 'SM-G930' },
      { 'label': 'Galaxy S7 Edge', 'pattern': 'SM-G935' },
      'Google TV',
      'Lumia',
      'iPad',
      'iPod',
      'iPhone',
      'Kindle',
      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Nexus',
      'Nook',
      'PlayBook',
      'PlayStation Vita',
      'PlayStation',
      'TouchPad',
      'Transformer',
      { 'label': 'Wii U', 'pattern': 'WiiU' },
      'Wii',
      'Xbox One',
      { 'label': 'Xbox 360', 'pattern': 'Xbox' },
      'Xoom'
    ]);

    /* Detectable manufacturers. */
    var manufacturer = getManufacturer({
      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
      'Archos': {},
      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
      'Asus': { 'Transformer': 1 },
      'Barnes & Noble': { 'Nook': 1 },
      'BlackBerry': { 'PlayBook': 1 },
      'Google': { 'Google TV': 1, 'Nexus': 1 },
      'HP': { 'TouchPad': 1 },
      'HTC': {},
      'LG': {},
      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
      'Motorola': { 'Xoom': 1 },
      'Nintendo': { 'Wii U': 1,  'Wii': 1 },
      'Nokia': { 'Lumia': 1 },
      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
      'Sony': { 'PlayStation': 1, 'PlayStation Vita': 1 }
    });

    /* Detectable operating systems (order is important). */
    var os = getOS([
      'Windows Phone',
      'Android',
      'CentOS',
      { 'label': 'Chrome OS', 'pattern': 'CrOS' },
      'Debian',
      'Fedora',
      'FreeBSD',
      'Gentoo',
      'Haiku',
      'Kubuntu',
      'Linux Mint',
      'OpenBSD',
      'Red Hat',
      'SuSE',
      'Ubuntu',
      'Xubuntu',
      'Cygwin',
      'Symbian OS',
      'hpwOS',
      'webOS ',
      'webOS',
      'Tablet OS',
      'Tizen',
      'Linux',
      'Mac OS X',
      'Macintosh',
      'Mac',
      'Windows 98;',
      'Windows '
    ]);

    /*------------------------------------------------------------------------*/

    /**
     * Picks the layout engine from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected layout engine.
     */
    function getLayout(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the manufacturer from an array of guesses.
     *
     * @private
     * @param {Array} guesses An object of guesses.
     * @returns {null|string} The detected manufacturer.
     */
    function getManufacturer(guesses) {
      return reduce(guesses, function(result, value, key) {
        // Lookup the manufacturer by product or scan the UA for the manufacturer.
        return result || (
          value[product] ||
          value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
          RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
        ) && key;
      });
    }

    /**
     * Picks the browser name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected browser name.
     */
    function getName(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the OS name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected OS name.
     */
    function getOS(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
            )) {
          result = cleanupOS(result, pattern, guess.label || guess);
        }
        return result;
      });
    }

    /**
     * Picks the product name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected product name.
     */
    function getProduct(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + ' *\\w+-[\\w]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
            )) {
          // Split by forward slash and append product version if needed.
          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
            result[0] += ' ' + result[1];
          }
          // Correct character case and cleanup string.
          guess = guess.label || guess;
          result = format(result[0]
            .replace(RegExp(pattern, 'i'), guess)
            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
            .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
        }
        return result;
      });
    }

    /**
     * Resolves the version using an array of UA patterns.
     *
     * @private
     * @param {Array} patterns An array of UA patterns.
     * @returns {null|string} The detected version.
     */
    function getVersion(patterns) {
      return reduce(patterns, function(result, pattern) {
        return result || (RegExp(pattern +
          '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
      });
    }

    /**
     * Returns `platform.description` when the platform object is coerced to a string.
     *
     * @name toString
     * @memberOf platform
     * @returns {string} Returns `platform.description` if available, else an empty string.
     */
    function toStringPlatform() {
      return this.description || '';
    }

    /*------------------------------------------------------------------------*/

    // Convert layout to an array so we can add extra details.
    layout && (layout = [layout]);

    // Detect product names that contain their manufacturer's name.
    if (manufacturer && !product) {
      product = getProduct([manufacturer]);
    }
    // Clean up Google TV.
    if ((data = /\bGoogle TV\b/.exec(product))) {
      product = data[0];
    }
    // Detect simulators.
    if (/\bSimulator\b/i.test(ua)) {
      product = (product ? product + ' ' : '') + 'Simulator';
    }
    // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
      description.push('running in Turbo/Uncompressed mode');
    }
    // Detect IE Mobile 11.
    if (name == 'IE' && /\blike iPhone OS\b/.test(ua)) {
      data = parse(ua.replace(/like iPhone OS/, ''));
      manufacturer = data.manufacturer;
      product = data.product;
    }
    // Detect iOS.
    else if (/^iP/.test(product)) {
      name || (name = 'Safari');
      os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
        ? ' ' + data[1].replace(/_/g, '.')
        : '');
    }
    // Detect Kubuntu.
    else if (name == 'Konqueror' && !/buntu/i.test(os)) {
      os = 'Kubuntu';
    }
    // Detect Android browsers.
    else if ((manufacturer && manufacturer != 'Google' &&
        ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) ||
        (/\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua))) {
      name = 'Android Browser';
      os = /\bAndroid\b/.test(os) ? os : 'Android';
    }
    // Detect Silk desktop/accelerated modes.
    else if (name == 'Silk') {
      if (!/\bMobi/i.test(ua)) {
        os = 'Android';
        description.unshift('desktop mode');
      }
      if (/Accelerated *= *true/i.test(ua)) {
        description.unshift('accelerated');
      }
    }
    // Detect PaleMoon identifying as Firefox.
    else if (name == 'PaleMoon' && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
      description.push('identifying as Firefox ' + data[1]);
    }
    // Detect Firefox OS and products running Firefox.
    else if (name == 'Firefox' && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
      os || (os = 'Firefox OS');
      product || (product = data[1]);
    }
    // Detect false positives for Firefox/Safari.
    else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
      // Escape the `/` for Firefox 1.
      if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
        // Clear name of false positives.
        name = null;
      }
      // Reassign a generic name.
      if ((data = product || manufacturer || os) &&
          (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
      }
    }
    // Add Chrome version to description for Electron.
    else if (name == 'Electron' && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
      description.push('Chromium ' + data);
    }
    // Detect non-Opera (Presto-based) versions (order is important).
    if (!version) {
      version = getVersion([
        '(?:Cloud9|CriOS|CrMo|Edge|FxiOS|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$))',
        'Version',
        qualify(name),
        '(?:Firefox|Minefield|NetFront)'
      ]);
    }
    // Detect stubborn layout engines.
    if ((data =
          layout == 'iCab' && parseFloat(version) > 3 && 'WebKit' ||
          /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
          /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && 'WebKit' ||
          !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident') ||
          layout == 'WebKit' && /\bPlayStation\b(?! Vita\b)/i.test(name) && 'NetFront'
        )) {
      layout = [data];
    }
    // Detect Windows Phone 7 desktop mode.
    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
      name += ' Mobile';
      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
      description.unshift('desktop mode');
    }
    // Detect Windows Phone 8.x desktop mode.
    else if (/\bWPDesktop\b/i.test(ua)) {
      name = 'IE Mobile';
      os = 'Windows Phone 8.x';
      description.unshift('desktop mode');
      version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
    }
    // Detect IE 11 identifying as other browsers.
    else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
      if (name) {
        description.push('identifying as ' + name + (version ? ' ' + version : ''));
      }
      name = 'IE';
      version = data[1];
    }
    // Leverage environment features.
    if (useFeatures) {
      // Detect server-side environments.
      // Rhino has a global function while others have a global object.
      if (isHostType(context, 'global')) {
        if (java) {
          data = java.lang.System;
          arch = data.getProperty('os.arch');
          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
        }
        if (rhino) {
          try {
            version = context.require('ringo/engine').version.join('.');
            name = 'RingoJS';
          } catch(e) {
            if ((data = context.system) && data.global.system == context.system) {
              name = 'Narwhal';
              os || (os = data[0].os || null);
            }
          }
          if (!name) {
            name = 'Rhino';
          }
        }
        else if (
          typeof context.process == 'object' && !context.process.browser &&
          (data = context.process)
        ) {
          if (typeof data.versions == 'object') {
            if (typeof data.versions.electron == 'string') {
              description.push('Node ' + data.versions.node);
              name = 'Electron';
              version = data.versions.electron;
            } else if (typeof data.versions.nw == 'string') {
              description.push('Chromium ' + version, 'Node ' + data.versions.node);
              name = 'NW.js';
              version = data.versions.nw;
            }
          }
          if (!name) {
            name = 'Node.js';
            arch = data.arch;
            os = data.platform;
            version = /[\d.]+/.exec(data.version);
            version = version ? version[0] : null;
          }
        }
      }
      // Detect Adobe AIR.
      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
        name = 'Adobe AIR';
        os = data.flash.system.Capabilities.os;
      }
      // Detect PhantomJS.
      else if (getClassOf((data = context.phantom)) == phantomClass) {
        name = 'PhantomJS';
        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
      }
      // Detect IE compatibility modes.
      else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
        // We're in compatibility mode when the Trident version + 4 doesn't
        // equal the document mode.
        version = [version, doc.documentMode];
        if ((data = +data[1] + 4) != version[1]) {
          description.push('IE ' + version[1] + ' mode');
          layout && (layout[1] = '');
          version[1] = data;
        }
        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
      }
      // Detect IE 11 masking as other browsers.
      else if (typeof doc.documentMode == 'number' && /^(?:Chrome|Firefox)\b/.test(name)) {
        description.push('masking as ' + name + ' ' + version);
        name = 'IE';
        version = '11.0';
        layout = ['Trident'];
        os = 'Windows';
      }
      os = os && format(os);
    }
    // Detect prerelease phases.
    if (version && (data =
          /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
          /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
          /\bMinefield\b/i.test(ua) && 'a'
        )) {
      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
      version = version.replace(RegExp(data + '\\+?$'), '') +
        (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
    }
    // Detect Firefox Mobile.
    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
      name = 'Firefox Mobile';
    }
    // Obscure Maxthon's unreliable version.
    else if (name == 'Maxthon' && version) {
      version = version.replace(/\.[\d.]+/, '.x');
    }
    // Detect Xbox 360 and Xbox One.
    else if (/\bXbox\b/i.test(product)) {
      if (product == 'Xbox 360') {
        os = null;
      }
      if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
        description.unshift('mobile mode');
      }
    }
    // Add mobile postfix.
    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
        (os == 'Windows CE' || /Mobi/i.test(ua))) {
      name += ' Mobile';
    }
    // Detect IE platform preview.
    else if (name == 'IE' && useFeatures) {
      try {
        if (context.external === null) {
          description.unshift('platform preview');
        }
      } catch(e) {
        description.unshift('embedded');
      }
    }
    // Detect BlackBerry OS version.
    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
    else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
          (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
          version
        )) {
      data = [data, /BB10/.test(ua)];
      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
      version = null;
    }
    // Detect Opera identifying/masking itself as another browser.
    // http://www.opera.com/support/kb/view/843/
    else if (this != forOwn && product != 'Wii' && (
          (useFeatures && opera) ||
          (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
          (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
          (name == 'IE' && (
            (os && !/^Win/.test(os) && version > 5.5) ||
            /\bWindows XP\b/.test(os) && version > 8 ||
            version == 8 && !/\bTrident\b/.test(ua)
          ))
        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {
      // When "identifying", the UA contains both Opera and the other browser's name.
      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
      if (reOpera.test(name)) {
        if (/\bIE\b/.test(data) && os == 'Mac OS') {
          os = null;
        }
        data = 'identify' + data;
      }
      // When "masking", the UA contains only the other browser's name.
      else {
        data = 'mask' + data;
        if (operaClass) {
          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
        } else {
          name = 'Opera';
        }
        if (/\bIE\b/.test(data)) {
          os = null;
        }
        if (!useFeatures) {
          version = null;
        }
      }
      layout = ['Presto'];
      description.push(data);
    }
    // Detect WebKit Nightly and approximate Chrome/Safari versions.
    if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
      // Correct build number for numeric comparison.
      // (e.g. "532.5" becomes "532.05")
      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
      // Nightly builds are postfixed with a "+".
      if (name == 'Safari' && data[1].slice(-1) == '+') {
        name = 'WebKit Nightly';
        prerelease = 'alpha';
        version = data[1].slice(0, -1);
      }
      // Clear incorrect browser versions.
      else if (version == data[1] ||
          version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
        version = null;
      }
      // Use the full Chrome version when available.
      data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
      // Detect Blink layout engine.
      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == 'WebKit') {
        layout = ['Blink'];
      }
      // Detect JavaScriptCore.
      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
      if (!useFeatures || (!likeChrome && !data[1])) {
        layout && (layout[1] = 'like Safari');
        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
      } else {
        layout && (layout[1] = 'like Chrome');
        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
      }
      // Add the postfix of ".x" or "+" for approximate versions.
      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
      // Obscure version for some Safari 1-2 releases.
      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
        version = data;
      }
    }
    // Detect Opera desktop modes.
    if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
      name += ' ';
      description.unshift('desktop mode');
      if (data == 'zvav') {
        name += 'Mini';
        version = null;
      } else {
        name += 'Mobile';
      }
      os = os.replace(RegExp(' *' + data + '$'), '');
    }
    // Detect Chrome desktop mode.
    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
      description.unshift('desktop mode');
      name = 'Chrome Mobile';
      version = null;

      if (/\bOS X\b/.test(os)) {
        manufacturer = 'Apple';
        os = 'iOS 4.3+';
      } else {
        os = null;
      }
    }
    // Strip incorrect OS versions.
    if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
        ua.indexOf('/' + data + '-') > -1) {
      os = trim(os.replace(data, ''));
    }
    // Add layout engine.
    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
        /Browser|Lunascape|Maxthon/.test(name) ||
        name != 'Safari' && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) ||
        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|Web)/.test(name) && layout[1])) {
      // Don't add layout details to description if they are falsey.
      (data = layout[layout.length - 1]) && description.push(data);
    }
    // Combine contextual information.
    if (description.length) {
      description = ['(' + description.join('; ') + ')'];
    }
    // Append manufacturer to description.
    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
      description.push('on ' + manufacturer);
    }
    // Append product to description.
    if (product) {
      description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
    }
    // Parse the OS into an object.
    if (os) {
      data = / ([\d.+]+)$/.exec(os);
      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
      os = {
        'architecture': 32,
        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
        'version': data ? data[1] : null,
        'toString': function() {
          var version = this.version;
          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
        }
      };
    }
    // Add browser/OS architecture.
    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
      if (os) {
        os.architecture = 64;
        os.family = os.family.replace(RegExp(' *' + data), '');
      }
      if (
          name && (/\bWOW64\b/i.test(ua) ||
          (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
      ) {
        description.unshift('32-bit');
      }
    }
    // Chrome 39 and above on OS X is always 64-bit.
    else if (
        os && /^OS X/.test(os.family) &&
        name == 'Chrome' && parseFloat(version) >= 39
    ) {
      os.architecture = 64;
    }

    ua || (ua = null);

    /*------------------------------------------------------------------------*/

    /**
     * The platform object.
     *
     * @name platform
     * @type Object
     */
    var platform = {};

    /**
     * The platform description.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.description = ua;

    /**
     * The name of the browser's layout engine.
     *
     * The list of common layout engines include:
     * "Blink", "EdgeHTML", "Gecko", "Trident" and "WebKit"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.layout = layout && layout[0];

    /**
     * The name of the product's manufacturer.
     *
     * The list of manufacturers include:
     * "Apple", "Archos", "Amazon", "Asus", "Barnes & Noble", "BlackBerry",
     * "Google", "HP", "HTC", "LG", "Microsoft", "Motorola", "Nintendo",
     * "Nokia", "Samsung" and "Sony"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.manufacturer = manufacturer;

    /**
     * The name of the browser/environment.
     *
     * The list of common browser names include:
     * "Chrome", "Electron", "Firefox", "Firefox for iOS", "IE",
     * "Microsoft Edge", "PhantomJS", "Safari", "SeaMonkey", "Silk",
     * "Opera Mini" and "Opera"
     *
     * Mobile versions of some browsers have "Mobile" appended to their name:
     * eg. "Chrome Mobile", "Firefox Mobile", "IE Mobile" and "Opera Mobile"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.name = name;

    /**
     * The alpha/beta release indicator.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.prerelease = prerelease;

    /**
     * The name of the product hosting the browser.
     *
     * The list of common products include:
     *
     * "BlackBerry", "Galaxy S4", "Lumia", "iPad", "iPod", "iPhone", "Kindle",
     * "Kindle Fire", "Nexus", "Nook", "PlayBook", "TouchPad" and "Transformer"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.product = product;

    /**
     * The browser's user agent string.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.ua = ua;

    /**
     * The browser/environment version.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.version = name && version;

    /**
     * The name of the operating system.
     *
     * @memberOf platform
     * @type Object
     */
    platform.os = os || {

      /**
       * The CPU architecture the OS is built for.
       *
       * @memberOf platform.os
       * @type number|null
       */
      'architecture': null,

      /**
       * The family of the OS.
       *
       * Common values include:
       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
       * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
       * "Android", "iOS" and "Windows Phone"
       *
       * @memberOf platform.os
       * @type string|null
       */
      'family': null,

      /**
       * The version of the OS.
       *
       * @memberOf platform.os
       * @type string|null
       */
      'version': null,

      /**
       * Returns the OS string.
       *
       * @memberOf platform.os
       * @returns {string} The OS string.
       */
      'toString': function() { return 'null'; }
    };

    platform.parse = parse;
    platform.toString = toStringPlatform;

    if (platform.version) {
      description.unshift(version);
    }
    if (platform.name) {
      description.unshift(name);
    }
    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
      description.push(product ? '(' + os + ')' : 'on ' + os);
    }
    if (description.length) {
      platform.description = description.join(' ');
    }
    return platform;
  }

  /*--------------------------------------------------------------------------*/

  // Export platform.
  var platform = parse();

  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose platform on the global object to prevent errors when platform is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    root.platform = platform;

    // Define as an anonymous module so platform can be aliased through path mapping.
    define(function() {
      return platform;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for CommonJS support.
    forOwn(platform, function(value, key) {
      freeExports[key] = value;
    });
  }
  else {
    // Export to the global object.
    root.platform = platform;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],170:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))

},{"_process":171}],171:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],172:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],173:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],174:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],175:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":173,"./encode":174}],176:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":177}],177:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = _keys2.default || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

},{"./_stream_readable":179,"./_stream_writable":181,"babel-runtime/core-js/object/keys":22,"core-util-is":150,"inherits":160,"process-nextick-args":170}],178:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":180,"core-util-is":150,"inherits":160}],179:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && (0, _getPrototypeOf2.default)(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":177,"./internal/streams/BufferList":182,"./internal/streams/destroy":183,"./internal/streams/stream":184,"_process":171,"babel-runtime/core-js/object/get-prototype-of":21,"core-util-is":150,"events":156,"inherits":160,"isarray":164,"process-nextick-args":170,"safe-buffer":191,"string_decoder/":198,"util":35}],180:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":177,"core-util-is":150,"inherits":160}],181:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _hasInstance = require('babel-runtime/core-js/symbol/has-instance');

var _hasInstance2 = _interopRequireDefault(_hasInstance);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _setImmediate2 = require('babel-runtime/core-js/set-immediate');

var _setImmediate3 = _interopRequireDefault(_setImmediate2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? _setImmediate3.default : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof _symbol2.default === 'function' && _hasInstance2.default && typeof Function.prototype[_hasInstance2.default] === 'function') {
  realHasInstance = Function.prototype[_hasInstance2.default];
  (0, _defineProperty2.default)(Writable, _hasInstance2.default, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":177,"./internal/streams/destroy":183,"./internal/streams/stream":184,"_process":171,"babel-runtime/core-js/object/define-property":19,"babel-runtime/core-js/set-immediate":24,"babel-runtime/core-js/symbol":26,"babel-runtime/core-js/symbol/has-instance":27,"core-util-is":150,"inherits":160,"process-nextick-args":170,"safe-buffer":191,"util-deprecate":203}],182:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

},{"safe-buffer":191,"util":35}],183:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

},{"process-nextick-args":170}],184:[function(require,module,exports){
'use strict';

module.exports = require('events').EventEmitter;

},{"events":156}],185:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":186}],186:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":177,"./lib/_stream_passthrough.js":178,"./lib/_stream_readable.js":179,"./lib/_stream_transform.js":180,"./lib/_stream_writable.js":181}],187:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":186}],188:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":181}],189:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

},{"./runtime":190}],190:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);

},{}],191:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":37}],192:[function(require,module,exports){
(function (Buffer){
'use strict';

var _fromCodePoint = require('babel-runtime/core-js/string/from-code-point');

var _fromCodePoint2 = _interopRequireDefault(_fromCodePoint);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;(function (sax) {
  // wrapper for non-node envs
  sax.parser = function (strict, opt) {
    return new SAXParser(strict, opt);
  };
  sax.SAXParser = SAXParser;
  sax.SAXStream = SAXStream;
  sax.createStream = createStream;

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024;

  var buffers = ['comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype', 'procInstName', 'procInstBody', 'entity', 'attribName', 'attribValue', 'cdata', 'script'];

  sax.EVENTS = ['text', 'processinginstruction', 'sgmldeclaration', 'doctype', 'comment', 'opentagstart', 'attribute', 'opentag', 'closetag', 'opencdata', 'cdata', 'closecdata', 'error', 'end', 'ready', 'script', 'opennamespace', 'closenamespace'];

  function SAXParser(strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt);
    }

    var parser = this;
    clearBuffers(parser);
    parser.q = parser.c = '';
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
    parser.opt = opt || {};
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
    parser.tags = [];
    parser.closed = parser.closedRoot = parser.sawRoot = false;
    parser.tag = parser.error = null;
    parser.strict = !!strict;
    parser.noscript = !!(strict || parser.opt.noscript);
    parser.state = S.BEGIN;
    parser.strictEntities = parser.opt.strictEntities;
    parser.ENTITIES = parser.strictEntities ? (0, _create2.default)(sax.XML_ENTITIES) : (0, _create2.default)(sax.ENTITIES);
    parser.attribList = [];

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = (0, _create2.default)(rootNS);
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false;
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0;
    }
    emit(parser, 'onready');
  }

  if (!_create2.default) {
    Object.create = function (o) {
      function F() {}
      F.prototype = o;
      var newf = new F();
      return newf;
    };
  }

  if (!_keys2.default) {
    Object.keys = function (o) {
      var a = [];
      for (var i in o) {
        if (o.hasOwnProperty(i)) a.push(i);
      }return a;
    };
  }

  function checkBufferLength(parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
    var maxActual = 0;
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length;
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser);
            break;

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
            break;

          case 'script':
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
            break;

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i]);
        }
      }
      maxActual = Math.max(maxActual, len);
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual;
    parser.bufferCheckPosition = m + parser.position;
  }

  function clearBuffers(parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = '';
    }
  }

  function flushBuffers(parser) {
    closeText(parser);
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata);
      parser.cdata = '';
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    }
  }

  SAXParser.prototype = {
    end: function end() {
      _end(this);
    },
    write: write,
    resume: function resume() {
      this.error = null;return this;
    },
    close: function close() {
      return this.write(null);
    },
    flush: function flush() {
      flushBuffers(this);
    }
  };

  var Stream;
  try {
    Stream = require('stream').Stream;
  } catch (ex) {
    Stream = function Stream() {};
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end';
  });

  function createStream(strict, opt) {
    return new SAXStream(strict, opt);
  }

  function SAXStream(strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt);
    }

    Stream.apply(this);

    this._parser = new SAXParser(strict, opt);
    this.writable = true;
    this.readable = true;

    var me = this;

    this._parser.onend = function () {
      me.emit('end');
    };

    this._parser.onerror = function (er) {
      me.emit('error', er);

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null;
    };

    this._decoder = null;

    streamWraps.forEach(function (ev) {
      (0, _defineProperty2.default)(me, 'on' + ev, {
        get: function get() {
          return me._parser['on' + ev];
        },
        set: function set(h) {
          if (!h) {
            me.removeAllListeners(ev);
            me._parser['on' + ev] = h;
            return h;
          }
          me.on(ev, h);
        },
        enumerable: true,
        configurable: false
      });
    });
  }

  SAXStream.prototype = (0, _create2.default)(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  });

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = require('string_decoder').StringDecoder;
        this._decoder = new SD('utf8');
      }
      data = this._decoder.write(data);
    }

    this._parser.write(data.toString());
    this.emit('data', data);
    return true;
  };

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk);
    }
    this._parser.end();
    return true;
  };

  SAXStream.prototype.on = function (ev, handler) {
    var me = this;
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        args.splice(0, 0, ev);
        me.emit.apply(me, args);
      };
    }

    return Stream.prototype.on.call(me, ev, handler);
  };

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA[';
  var DOCTYPE = 'DOCTYPE';
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE

    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
  };var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

  function isWhitespace(c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t';
  }

  function isQuote(c) {
    return c === '"' || c === '\'';
  }

  function isAttribEnd(c) {
    return c === '>' || isWhitespace(c);
  }

  function isMatch(regex, c) {
    return regex.test(c);
  }

  function notMatch(regex, c) {
    return !isMatch(regex, c);
  }

  var S = 0;
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  };

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  };

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  };

  (0, _keys2.default)(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key];
    var s = typeof e === 'number' ? String.fromCharCode(e) : e;
    sax.ENTITIES[key] = s;
  });

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s;
  }

  // shorthand
  S = sax.STATE;

  function emit(parser, event, data) {
    parser[event] && parser[event](data);
  }

  function emitNode(parser, nodeType, data) {
    if (parser.textNode) closeText(parser);
    emit(parser, nodeType, data);
  }

  function closeText(parser) {
    parser.textNode = textopts(parser.opt, parser.textNode);
    if (parser.textNode) emit(parser, 'ontext', parser.textNode);
    parser.textNode = '';
  }

  function textopts(opt, text) {
    if (opt.trim) text = text.trim();
    if (opt.normalize) text = text.replace(/\s+/g, ' ');
    return text;
  }

  function error(parser, er) {
    closeText(parser);
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
    }
    er = new Error(er);
    parser.error = er;
    emit(parser, 'onerror', er);
    return parser;
  }

  function _end(parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
      error(parser, 'Unexpected end');
    }
    closeText(parser);
    parser.c = '';
    parser.closed = true;
    emit(parser, 'onend');
    SAXParser.call(parser, parser.strict, parser.opt);
    return parser;
  }

  function strictFail(parser, message) {
    if ((typeof parser === 'undefined' ? 'undefined' : (0, _typeof3.default)(parser)) !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail');
    }
    if (parser.strict) {
      error(parser, message);
    }
  }

  function newTag(parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
    var parent = parser.tags[parser.tags.length - 1] || parser;
    var tag = parser.tag = { name: parser.tagName, attributes: {}

      // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    };if (parser.opt.xmlns) {
      tag.ns = parent.ns;
    }
    parser.attribList.length = 0;
    emitNode(parser, 'onopentagstart', tag);
  }

  function qname(name, attribute) {
    var i = name.indexOf(':');
    var qualName = i < 0 ? ['', name] : name.split(':');
    var prefix = qualName[0];
    var local = qualName[1];

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns';
      local = '';
    }

    return { prefix: prefix, local: local };
  }

  function attrib(parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]();
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = '';
      return;
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true);
      var prefix = qn.prefix;
      var local = qn.local;

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
        } else {
          var tag = parser.tag;
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns === parent.ns) {
            tag.ns = (0, _create2.default)(parent.ns);
          }
          tag.ns[local] = parser.attribValue;
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue]);
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue;
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      });
    }

    parser.attribName = parser.attribValue = '';
  }

  function openTag(parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag;

      // add namespace info to tag
      var qn = qname(parser.tagName);
      tag.prefix = qn.prefix;
      tag.local = qn.local;
      tag.uri = tag.ns[qn.prefix] || '';

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' + (0, _stringify2.default)(parser.tagName));
        tag.uri = qn.prefix;
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (tag.ns && parent.ns !== tag.ns) {
        (0, _keys2.default)(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          });
        });
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i];
        var name = nv[0];
        var value = nv[1];
        var qualName = qname(name, true);
        var prefix = qualName.prefix;
        var local = qualName.local;
        var uri = prefix === '' ? '' : tag.ns[prefix] || '';
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri

          // if there's any attributes with an undefined namespace,
          // then fail on them now.
        };if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' + (0, _stringify2.default)(prefix));
          a.uri = prefix;
        }
        parser.tag.attributes[name] = a;
        emitNode(parser, 'onattribute', a);
      }
      parser.attribList.length = 0;
    }

    parser.tag.isSelfClosing = !!selfClosing;

    // process the tag
    parser.sawRoot = true;
    parser.tags.push(parser.tag);
    emitNode(parser, 'onopentag', parser.tag);
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT;
      } else {
        parser.state = S.TEXT;
      }
      parser.tag = null;
      parser.tagName = '';
    }
    parser.attribName = parser.attribValue = '';
    parser.attribList.length = 0;
  }

  function closeTag(parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.');
      parser.textNode += '</>';
      parser.state = S.TEXT;
      return;
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>';
        parser.tagName = '';
        parser.state = S.SCRIPT;
        return;
      }
      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length;
    var tagName = parser.tagName;
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]();
    }
    var closeTo = tagName;
    while (t--) {
      var close = parser.tags[t];
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag');
      } else {
        break;
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
      parser.textNode += '</' + parser.tagName + '>';
      parser.state = S.TEXT;
      return;
    }
    parser.tagName = tagName;
    var s = parser.tags.length;
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop();
      parser.tagName = parser.tag.name;
      emitNode(parser, 'onclosetag', parser.tagName);

      var x = {};
      for (var i in tag.ns) {
        x[i] = tag.ns[i];
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        (0, _keys2.default)(tag.ns).forEach(function (p) {
          var n = tag.ns[p];
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
        });
      }
    }
    if (t === 0) parser.closedRoot = true;
    parser.tagName = parser.attribValue = parser.attribName = '';
    parser.attribList.length = 0;
    parser.state = S.TEXT;
  }

  function parseEntity(parser) {
    var entity = parser.entity;
    var entityLC = entity.toLowerCase();
    var num;
    var numStr = '';

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity];
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC];
    }
    entity = entityLC;
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2);
        num = parseInt(entity, 16);
        numStr = num.toString(16);
      } else {
        entity = entity.slice(1);
        num = parseInt(entity, 10);
        numStr = num.toString(10);
      }
    }
    entity = entity.replace(/^0+/, '');
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity');
      return '&' + parser.entity + ';';
    }

    return (0, _fromCodePoint2.default)(num);
  }

  function beginWhiteSpace(parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA;
      parser.startTagPosition = parser.position;
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.');
      parser.textNode = c;
      parser.state = S.TEXT;
    }
  }

  function charAt(chunk, i) {
    var result = '';
    if (i < chunk.length) {
      result = chunk.charAt(i);
    }
    return result;
  }

  function write(chunk) {
    var parser = this;
    if (this.error) {
      throw this.error;
    }
    if (parser.closed) {
      return error(parser, 'Cannot write after close. Assign an onready handler.');
    }
    if (chunk === null) {
      return _end(parser);
    }
    if ((typeof chunk === 'undefined' ? 'undefined' : (0, _typeof3.default)(chunk)) === 'object') {
      chunk = chunk.toString();
    }
    var i = 0;
    var c = '';
    while (true) {
      c = charAt(chunk, i++);
      parser.c = c;

      if (!c) {
        break;
      }

      if (parser.trackPosition) {
        parser.position++;
        if (c === '\n') {
          parser.line++;
          parser.column = 0;
        } else {
          parser.column++;
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE;
          if (c === '\uFEFF') {
            continue;
          }
          beginWhiteSpace(parser, c);
          continue;

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c);
          continue;

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1;
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++);
              if (c && parser.trackPosition) {
                parser.position++;
                if (c === '\n') {
                  parser.line++;
                  parser.column = 0;
                } else {
                  parser.column++;
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1);
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.');
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY;
            } else {
              parser.textNode += c;
            }
          }
          continue;

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING;
          } else {
            parser.script += c;
          }
          continue;

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG;
          } else {
            parser.script += '<' + c;
            parser.state = S.SCRIPT;
          }
          continue;

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL;
            parser.sgmlDecl = '';
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG;
            parser.tagName = c;
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG;
            parser.tagName = '';
          } else if (c === '?') {
            parser.state = S.PROC_INST;
            parser.procInstName = parser.procInstBody = '';
          } else {
            strictFail(parser, 'Unencoded <');
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition;
              c = new Array(pad).join(' ') + c;
            }
            parser.textNode += '<' + c;
            parser.state = S.TEXT;
          }
          continue;

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata');
            parser.state = S.CDATA;
            parser.sgmlDecl = '';
            parser.cdata = '';
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT;
            parser.comment = '';
            parser.sgmlDecl = '';
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE;
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser, 'Inappropriately located doctype declaration');
            }
            parser.doctype = '';
            parser.sgmlDecl = '';
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
            parser.sgmlDecl = '';
            parser.state = S.TEXT;
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED;
            parser.sgmlDecl += c;
          } else {
            parser.sgmlDecl += c;
          }
          continue;

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL;
            parser.q = '';
          }
          parser.sgmlDecl += c;
          continue;

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT;
            emitNode(parser, 'ondoctype', parser.doctype);
            parser.doctype = true; // just remember that we saw it.
          } else {
            parser.doctype += c;
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED;
              parser.q = c;
            }
          }
          continue;

        case S.DOCTYPE_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.q = '';
            parser.state = S.DOCTYPE;
          }
          continue;

        case S.DOCTYPE_DTD:
          parser.doctype += c;
          if (c === ']') {
            parser.state = S.DOCTYPE;
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED;
            parser.q = c;
          }
          continue;

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD;
            parser.q = '';
          }
          continue;

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING;
          } else {
            parser.comment += c;
          }
          continue;

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED;
            parser.comment = textopts(parser.opt, parser.comment);
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment);
            }
            parser.comment = '';
          } else {
            parser.comment += '-' + c;
            parser.state = S.COMMENT;
          }
          continue;

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment');
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c;
            parser.state = S.COMMENT;
          } else {
            parser.state = S.TEXT;
          }
          continue;

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING;
          } else {
            parser.cdata += c;
          }
          continue;

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2;
          } else {
            parser.cdata += ']' + c;
            parser.state = S.CDATA;
          }
          continue;

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata);
            }
            emitNode(parser, 'onclosecdata');
            parser.cdata = '';
            parser.state = S.TEXT;
          } else if (c === ']') {
            parser.cdata += ']';
          } else {
            parser.cdata += ']]' + c;
            parser.state = S.CDATA;
          }
          continue;

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY;
          } else {
            parser.procInstName += c;
          }
          continue;

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue;
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else {
            parser.procInstBody += c;
          }
          continue;

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            });
            parser.procInstName = parser.procInstBody = '';
            parser.state = S.TEXT;
          } else {
            parser.procInstBody += '?' + c;
            parser.state = S.PROC_INST_BODY;
          }
          continue;

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else {
            newTag(parser);
            if (c === '>') {
              openTag(parser);
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name');
              }
              parser.state = S.ATTRIB;
            }
          }
          continue;

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true);
            closeTag(parser);
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >');
            parser.state = S.ATTRIB;
          }
          continue;

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue;
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value');
            parser.attribValue = parser.attribName;
            attrib(parser);
            openTag(parser);
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE;
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (isWhitespace(c)) {
            continue;
          } else {
            strictFail(parser, 'Attribute without value');
            parser.tag.attributes[parser.attribName] = '';
            parser.attribValue = '';
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            });
            parser.attribName = '';
            if (c === '>') {
              openTag(parser);
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, 'Invalid attribute name');
              parser.state = S.ATTRIB;
            }
          }
          continue;

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue;
          } else if (isQuote(c)) {
            parser.q = c;
            parser.state = S.ATTRIB_VALUE_QUOTED;
          } else {
            strictFail(parser, 'Unquoted attribute value');
            parser.state = S.ATTRIB_VALUE_UNQUOTED;
            parser.attribValue = c;
          }
          continue;

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q;
            } else {
              parser.attribValue += c;
            }
            continue;
          }
          attrib(parser);
          parser.q = '';
          parser.state = S.ATTRIB_VALUE_CLOSED;
          continue;

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB;
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes');
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U;
            } else {
              parser.attribValue += c;
            }
            continue;
          }
          attrib(parser);
          if (c === '>') {
            openTag(parser);
          } else {
            parser.state = S.ATTRIB;
          }
          continue;

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue;
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c;
                parser.state = S.SCRIPT;
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.');
              }
            } else {
              parser.tagName = c;
            }
          } else if (c === '>') {
            closeTag(parser);
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else if (parser.script) {
            parser.script += '</' + parser.tagName;
            parser.tagName = '';
            parser.state = S.SCRIPT;
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag');
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE;
          }
          continue;

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue;
          }
          if (c === '>') {
            closeTag(parser);
          } else {
            strictFail(parser, 'Invalid characters in closing tag');
          }
          continue;

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState;
          var buffer;
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT;
              buffer = 'textNode';
              break;

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED;
              buffer = 'attribValue';
              break;

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED;
              buffer = 'attribValue';
              break;
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser);
            parser.entity = '';
            parser.state = returnState;
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c;
          } else {
            strictFail(parser, 'Invalid character in entity name');
            parser[buffer] += '&' + parser.entity + c;
            parser.entity = '';
            parser.state = returnState;
          }

          continue;

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state);
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser);
    }
    return parser;
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!_fromCodePoint2.default) {
    (function () {
      var stringFromCharCode = String.fromCharCode;
      var floor = Math.floor;
      var fromCodePoint = function fromCodePoint() {
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;
        if (!length) {
          return '';
        }
        var result = '';
        while (++index < length) {
          var codePoint = Number(arguments[index]);
          if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
          codePoint < 0 || // not a valid Unicode code point
          codePoint > 0x10FFFF || // not a valid Unicode code point
          floor(codePoint) !== codePoint // not an integer
          ) {
              throw RangeError('Invalid code point: ' + codePoint);
            }
          if (codePoint <= 0xFFFF) {
            // BMP code point
            codeUnits.push(codePoint);
          } else {
            // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000;
            highSurrogate = (codePoint >> 10) + 0xD800;
            lowSurrogate = codePoint % 0x400 + 0xDC00;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      /* istanbul ignore next */
      if (_defineProperty2.default) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        });
      } else {
        String.fromCodePoint = fromCodePoint;
      }
    })();
  }
})(typeof exports === 'undefined' ? undefined.sax = {} : exports);

}).call(this,require("buffer").Buffer)

},{"babel-runtime/core-js/json/stringify":16,"babel-runtime/core-js/object/create":18,"babel-runtime/core-js/object/define-property":19,"babel-runtime/core-js/object/keys":22,"babel-runtime/core-js/string/from-code-point":25,"babel-runtime/helpers/typeof":31,"buffer":37,"stream":193,"string_decoder":36}],193:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":156,"inherits":160,"readable-stream/duplex.js":176,"readable-stream/passthrough.js":185,"readable-stream/readable.js":186,"readable-stream/transform.js":187,"readable-stream/writable.js":188}],194:[function(require,module,exports){
(function (global){
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/request":196,"./lib/response":197,"builtin-status-codes":38,"url":201,"xtend":234}],195:[function(require,module,exports){
(function (global){
'use strict';

exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);

exports.writableStream = isFunction(global.WritableStream);

exports.abortController = isFunction(global.AbortController);

exports.blobConstructor = false;
try {
	new Blob([new ArrayBuffer(1)]);
	exports.blobConstructor = true;
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr;
function getXHR() {
	// Cache the xhr value
	if (xhr !== undefined) return xhr;

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest();
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com');
		} catch (e) {
			xhr = null;
		}
	} else {
		// Service workers don't have XHR
		xhr = null;
	}
	return xhr;
}

function checkTypeSupport(type) {
	var xhr = getXHR();
	if (!xhr) return false;
	try {
		xhr.responseType = type;
		return xhr.responseType === type;
	} catch (e) {}
	return false;
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined';
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice);

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || haveArrayBuffer && checkTypeSupport('arraybuffer');

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream');
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer && checkTypeSupport('moz-chunked-arraybuffer');

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);

exports.vbArray = isFunction(global.VBArray);

function isFunction(value) {
	return typeof value === 'function';
}

xhr = null; // Help gc

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],196:[function(require,module,exports){
(function (process,global,Buffer){
'use strict';

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var capability = require('./capability');
var inherits = require('inherits');
var response = require('./response');
var stream = require('readable-stream');
var toArrayBuffer = require('to-arraybuffer');

var IncomingMessage = response.IncomingMessage;
var rStates = response.readyStates;

function decideMode(preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch';
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer';
	} else if (capability.msstream) {
		return 'ms-stream';
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer';
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray';
	} else {
		return 'text';
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this;
	stream.Writable.call(self);

	self._opts = opts;
	self._body = [];
	self._headers = {};
	if (opts.auth) self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'));
	(0, _keys2.default)(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name]);
	});

	var preferBinary;
	var useFetch = true;
	if (opts.mode === 'disable-fetch' || 'requestTimeout' in opts && !capability.abortController) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false;
		preferBinary = true;
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false;
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType;
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true;
	} else {
		throw new Error('Invalid value for opts.mode');
	}
	self._mode = decideMode(preferBinary, useFetch);
	self._fetchTimer = null;

	self.on('finish', function () {
		self._onFinish();
	});
};

inherits(ClientRequest, stream.Writable);

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this;
	var lowerName = name.toLowerCase();
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1) return;

	self._headers[lowerName] = {
		name: name,
		value: value
	};
};

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()];
	if (header) return header.value;
	return null;
};

ClientRequest.prototype.removeHeader = function (name) {
	var self = this;
	delete self._headers[name.toLowerCase()];
};

ClientRequest.prototype._onFinish = function () {
	var self = this;

	if (self._destroyed) return;
	var opts = self._opts;

	var headersObj = self._headers;
	var body = null;
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body));
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer);
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			});
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString();
		}
	}

	// create flattened list of headers
	var headersList = [];
	(0, _keys2.default)(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name;
		var value = headersObj[keyName].value;
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v]);
			});
		} else {
			headersList.push([name, value]);
		}
	});

	if (self._mode === 'fetch') {
		var signal = null;
		var fetchTimer = null;
		if (capability.abortController) {
			var controller = new AbortController();
			signal = controller.signal;
			self._fetchAbortController = controller;

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout');
					if (self._fetchAbortController) self._fetchAbortController.abort();
				}, opts.requestTimeout);
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response;
			self._connect();
		}, function (reason) {
			global.clearTimeout(self._fetchTimer);
			if (!self._destroyed) self.emit('error', reason);
		});
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest();
		try {
			xhr.open(self._opts.method, self._opts.url, true);
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err);
			});
			return;
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr) xhr.responseType = self._mode.split(':')[0];

		if ('withCredentials' in xhr) xhr.withCredentials = !!opts.withCredentials;

		if (self._mode === 'text' && 'overrideMimeType' in xhr) xhr.overrideMimeType('text/plain; charset=x-user-defined');

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout;
			xhr.ontimeout = function () {
				self.emit('requestTimeout');
			};
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1]);
		});

		self._response = null;
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress();
					break;
			}
		};
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress();
			};
		}

		xhr.onerror = function () {
			if (self._destroyed) return;
			self.emit('error', new Error('XHR error'));
		};

		try {
			xhr.send(body);
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err);
			});
			return;
		}
	}
};

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid(xhr) {
	try {
		var status = xhr.status;
		return status !== null && status !== 0;
	} catch (e) {
		return false;
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this;

	if (!statusValid(self._xhr) || self._destroyed) return;

	if (!self._response) self._connect();

	self._response._onXHRProgress();
};

ClientRequest.prototype._connect = function () {
	var self = this;

	if (self._destroyed) return;

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer);
	self._response.on('error', function (err) {
		self.emit('error', err);
	});

	self.emit('response', self._response);
};

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this;

	self._body.push(chunk);
	cb();
};

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this;
	self._destroyed = true;
	global.clearTimeout(self._fetchTimer);
	if (self._response) self._response._destroyed = true;
	if (self._xhr) self._xhr.abort();else if (self._fetchAbortController) self._fetchAbortController.abort();
};

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this;
	if (typeof data === 'function') {
		cb = data;
		data = undefined;
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb);
};

ClientRequest.prototype.flushHeaders = function () {};
ClientRequest.prototype.setTimeout = function () {};
ClientRequest.prototype.setNoDelay = function () {};
ClientRequest.prototype.setSocketKeepAlive = function () {};

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = ['accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'user-agent', 'via'];

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":195,"./response":197,"_process":171,"babel-runtime/core-js/object/keys":22,"buffer":37,"inherits":160,"readable-stream":186,"to-arraybuffer":200}],197:[function(require,module,exports){
(function (process,global,Buffer){
'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var capability = require('./capability');
var inherits = require('inherits');
var stream = require('readable-stream');

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
};

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this;
	stream.Readable.call(self);

	self._mode = mode;
	self.headers = {};
	self.rawHeaders = [];
	self.trailers = {};
	self.rawTrailers = [];

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close');
		});
	});

	if (mode === 'fetch') {
		var read = function read() {
			reader.read().then(function (result) {
				if (self._destroyed) return;
				if (result.done) {
					global.clearTimeout(fetchTimer);
					self.push(null);
					return;
				}
				self.push(new Buffer(result.value));
				read();
			}).catch(function (err) {
				global.clearTimeout(fetchTimer);
				if (!self._destroyed) self.emit('error', err);
			});
		};

		self._fetchResponse = response;

		self.url = response.url;
		self.statusCode = response.status;
		self.statusMessage = response.statusText;

		response.headers.forEach(function (header, key) {
			self.headers[key.toLowerCase()] = header;
			self.rawHeaders.push(key, header);
		});

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function write(chunk) {
					return new _promise2.default(function (resolve, reject) {
						if (self._destroyed) {
							reject();
						} else if (self.push(new Buffer(chunk))) {
							resolve();
						} else {
							self._resumeFetch = resolve;
						}
					});
				},
				close: function close() {
					global.clearTimeout(fetchTimer);
					if (!self._destroyed) self.push(null);
				},
				abort: function abort(err) {
					if (!self._destroyed) self.emit('error', err);
				}
			});

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer);
					if (!self._destroyed) self.emit('error', err);
				});
				return;
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader();

		read();
	} else {
		self._xhr = xhr;
		self._pos = 0;

		self.url = xhr.responseURL;
		self.statusCode = xhr.status;
		self.statusMessage = xhr.statusText;
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/);
			if (matches) {
				var key = matches[1].toLowerCase();
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = [];
					}
					self.headers[key].push(matches[2]);
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2];
				} else {
					self.headers[key] = matches[2];
				}
				self.rawHeaders.push(matches[1], matches[2]);
			}
		});

		self._charset = 'x-user-defined';
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type'];
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase();
				}
			}
			if (!self._charset) self._charset = 'utf-8'; // best guess
		}
	}
};

inherits(IncomingMessage, stream.Readable);

IncomingMessage.prototype._read = function () {
	var self = this;

	var resolve = self._resumeFetch;
	if (resolve) {
		self._resumeFetch = null;
		resolve();
	}
};

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this;

	var xhr = self._xhr;

	var response = null;
	switch (self._mode) {
		case 'text:vbarray':
			// For IE9
			if (xhr.readyState !== rStates.DONE) break;
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray();
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response));
				break;
			}
		// Falls through in IE8	
		case 'text':
			try {
				// This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText;
			} catch (e) {
				self._mode = 'text:vbarray';
				break;
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos);
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length);
					for (var i = 0; i < newData.length; i++) {
						buffer[i] = newData.charCodeAt(i) & 0xff;
					}self.push(buffer);
				} else {
					self.push(newData, self._charset);
				}
				self._pos = response.length;
			}
			break;
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response) break;
			response = xhr.response;
			self.push(new Buffer(new Uint8Array(response)));
			break;
		case 'moz-chunked-arraybuffer':
			// take whole
			response = xhr.response;
			if (xhr.readyState !== rStates.LOADING || !response) break;
			self.push(new Buffer(new Uint8Array(response)));
			break;
		case 'ms-stream':
			response = xhr.response;
			if (xhr.readyState !== rStates.LOADING) break;
			var reader = new global.MSStreamReader();
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));
					self._pos = reader.result.byteLength;
				}
			};
			reader.onload = function () {
				self.push(null);
			};
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response);
			break;
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null);
	}
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"./capability":195,"_process":171,"babel-runtime/core-js/promise":23,"buffer":37,"inherits":160,"readable-stream":186}],198:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\uFFFD';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\uFFFD';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\uFFFD';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\uFFFD';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

},{"safe-buffer":191}],199:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":171,"timers":199}],200:[function(require,module,exports){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":37}],201:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":202,"punycode":172,"querystring":175}],202:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],203:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],204:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],205:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":204,"_process":171,"inherits":160}],206:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 1.12.7
(function () {
  "use strict";

  exports.stripBOM = function (str) {
    if (str[0] === "\uFEFF") {
      return str.substring(1);
    } else {
      return str;
    }
  };
}).call(undefined);

},{}],207:[function(require,module,exports){
'use strict';

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 1.12.7
(function () {
  "use strict";

  var builder,
      defaults,
      escapeCDATA,
      requiresCDATA,
      wrapCDATA,
      hasProp = {}.hasOwnProperty;

  builder = require('xmlbuilder');

  defaults = require('./defaults').defaults;

  requiresCDATA = function requiresCDATA(entry) {
    return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
  };

  wrapCDATA = function wrapCDATA(entry) {
    return "<![CDATA[" + escapeCDATA(entry) + "]]>";
  };

  escapeCDATA = function escapeCDATA(entry) {
    return entry.replace(']]>', ']]]]><![CDATA[>');
  };

  exports.Builder = function () {
    function Builder(opts) {
      var key, ref, value;
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
    }

    Builder.prototype.buildObject = function (rootObj) {
      var attrkey, charkey, render, rootElement, rootName;
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      if ((0, _keys2.default)(rootObj).length === 1 && this.options.rootName === defaults['0.2'].rootName) {
        rootName = (0, _keys2.default)(rootObj)[0];
        rootObj = rootObj[rootName];
      } else {
        rootName = this.options.rootName;
      }
      render = function (_this) {
        return function (element, obj) {
          var attr, child, entry, index, key, value;
          if ((typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) !== 'object') {
            if (_this.options.cdata && requiresCDATA(obj)) {
              element.raw(wrapCDATA(obj));
            } else {
              element.txt(obj);
            }
          } else if (Array.isArray(obj)) {
            for (index in obj) {
              if (!hasProp.call(obj, index)) continue;
              child = obj[index];
              for (key in child) {
                entry = child[key];
                element = render(element.ele(key), entry).up();
              }
            }
          } else {
            for (key in obj) {
              if (!hasProp.call(obj, key)) continue;
              child = obj[key];
              if (key === attrkey) {
                if ((typeof child === 'undefined' ? 'undefined' : (0, _typeof3.default)(child)) === "object") {
                  for (attr in child) {
                    value = child[attr];
                    element = element.att(attr, value);
                  }
                }
              } else if (key === charkey) {
                if (_this.options.cdata && requiresCDATA(child)) {
                  element = element.raw(wrapCDATA(child));
                } else {
                  element = element.txt(child);
                }
              } else if (Array.isArray(child)) {
                for (index in child) {
                  if (!hasProp.call(child, index)) continue;
                  entry = child[index];
                  if (typeof entry === 'string') {
                    if (_this.options.cdata && requiresCDATA(entry)) {
                      element = element.ele(key).raw(wrapCDATA(entry)).up();
                    } else {
                      element = element.ele(key, entry).up();
                    }
                  } else {
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else if ((typeof child === 'undefined' ? 'undefined' : (0, _typeof3.default)(child)) === "object") {
                element = render(element.ele(key), child).up();
              } else {
                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                  element = element.ele(key).raw(wrapCDATA(child)).up();
                } else {
                  if (child == null) {
                    child = '';
                  }
                  element = element.ele(key, child.toString()).up();
                }
              }
            }
          }
          return element;
        };
      }(this);
      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
        headless: this.options.headless,
        allowSurrogateChars: this.options.allowSurrogateChars
      });
      return render(rootElement, rootObj).end(this.options.renderOpts);
    };

    return Builder;
  }();
}).call(undefined);

},{"./defaults":208,"babel-runtime/core-js/object/keys":22,"babel-runtime/helpers/typeof":31,"xmlbuilder":233}],208:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 1.12.7
(function () {
  exports.defaults = {
    "0.1": {
      explicitCharkey: false,
      trim: true,
      normalize: true,
      normalizeTags: false,
      attrkey: "@",
      charkey: "#",
      explicitArray: false,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: false,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      childkey: '@@',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      emptyTag: ''
    },
    "0.2": {
      explicitCharkey: false,
      trim: false,
      normalize: false,
      normalizeTags: false,
      attrkey: "$",
      charkey: "_",
      explicitArray: true,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: true,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      preserveChildrenOrder: false,
      childkey: '$$',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      rootName: 'root',
      xmldec: {
        'version': '1.0',
        'encoding': 'UTF-8',
        'standalone': true
      },
      doctype: null,
      renderOpts: {
        'pretty': true,
        'indent': '  ',
        'newline': '\n'
      },
      headless: false,
      chunkSize: 10000,
      emptyTag: '',
      cdata: false
    }
  };
}).call(undefined);

},{}],209:[function(require,module,exports){
'use strict';

var _getOwnPropertyNames = require('babel-runtime/core-js/object/get-own-property-names');

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 1.12.7
(function () {
  "use strict";

  var bom,
      defaults,
      events,
      isEmpty,
      processItem,
      processors,
      sax,
      setImmediate,
      bind = function bind(fn, me) {
    return function () {
      return fn.apply(me, arguments);
    };
  },
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  sax = require('sax');

  events = require('events');

  bom = require('./bom');

  processors = require('./processors');

  setImmediate = require('timers').setImmediate;

  defaults = require('./defaults').defaults;

  isEmpty = function isEmpty(thing) {
    return (typeof thing === 'undefined' ? 'undefined' : (0, _typeof3.default)(thing)) === "object" && thing != null && (0, _keys2.default)(thing).length === 0;
  };

  processItem = function processItem(processors, item, key) {
    var i, len, process;
    for (i = 0, len = processors.length; i < len; i++) {
      process = processors[i];
      item = process(item, key);
    }
    return item;
  };

  exports.Parser = function (superClass) {
    extend(Parser, superClass);

    function Parser(opts) {
      this.parseString = bind(this.parseString, this);
      this.reset = bind(this.reset, this);
      this.assignOrPush = bind(this.assignOrPush, this);
      this.processAsync = bind(this.processAsync, this);
      var key, ref, value;
      if (!(this instanceof exports.Parser)) {
        return new exports.Parser(opts);
      }
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
      if (this.options.xmlns) {
        this.options.xmlnskey = this.options.attrkey + "ns";
      }
      if (this.options.normalizeTags) {
        if (!this.options.tagNameProcessors) {
          this.options.tagNameProcessors = [];
        }
        this.options.tagNameProcessors.unshift(processors.normalize);
      }
      this.reset();
    }

    Parser.prototype.processAsync = function () {
      var chunk, err;
      try {
        if (this.remaining.length <= this.options.chunkSize) {
          chunk = this.remaining;
          this.remaining = '';
          this.saxParser = this.saxParser.write(chunk);
          return this.saxParser.close();
        } else {
          chunk = this.remaining.substr(0, this.options.chunkSize);
          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
          this.saxParser = this.saxParser.write(chunk);
          return setImmediate(this.processAsync);
        }
      } catch (error1) {
        err = error1;
        if (!this.saxParser.errThrown) {
          this.saxParser.errThrown = true;
          return this.emit(err);
        }
      }
    };

    Parser.prototype.assignOrPush = function (obj, key, newValue) {
      if (!(key in obj)) {
        if (!this.options.explicitArray) {
          return obj[key] = newValue;
        } else {
          return obj[key] = [newValue];
        }
      } else {
        if (!(obj[key] instanceof Array)) {
          obj[key] = [obj[key]];
        }
        return obj[key].push(newValue);
      }
    };

    Parser.prototype.reset = function () {
      var attrkey, charkey, ontext, stack;
      this.removeAllListeners();
      this.saxParser = sax.parser(this.options.strict, {
        trim: false,
        normalize: false,
        xmlns: this.options.xmlns
      });
      this.saxParser.errThrown = false;
      this.saxParser.onerror = function (_this) {
        return function (error) {
          _this.saxParser.resume();
          if (!_this.saxParser.errThrown) {
            _this.saxParser.errThrown = true;
            return _this.emit("error", error);
          }
        };
      }(this);
      this.saxParser.onend = function (_this) {
        return function () {
          if (!_this.saxParser.ended) {
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      }(this);
      this.saxParser.ended = false;
      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
      this.resultObject = null;
      stack = [];
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      this.saxParser.onopentag = function (_this) {
        return function (node) {
          var key, newValue, obj, processedKey, ref;
          obj = {};
          obj[charkey] = "";
          if (!_this.options.ignoreAttrs) {
            ref = node.attributes;
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                obj[attrkey] = {};
              }
              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
              if (_this.options.mergeAttrs) {
                _this.assignOrPush(obj, processedKey, newValue);
              } else {
                obj[attrkey][processedKey] = newValue;
              }
            }
          }
          obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
          if (_this.options.xmlns) {
            obj[_this.options.xmlnskey] = {
              uri: node.uri,
              local: node.local
            };
          }
          return stack.push(obj);
        };
      }(this);
      this.saxParser.onclosetag = function (_this) {
        return function () {
          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
          obj = stack.pop();
          nodeName = obj["#name"];
          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
            delete obj["#name"];
          }
          if (obj.cdata === true) {
            cdata = obj.cdata;
            delete obj.cdata;
          }
          s = stack[stack.length - 1];
          if (obj[charkey].match(/^\s*$/) && !cdata) {
            emptyStr = obj[charkey];
            delete obj[charkey];
          } else {
            if (_this.options.trim) {
              obj[charkey] = obj[charkey].trim();
            }
            if (_this.options.normalize) {
              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
            }
            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
            if ((0, _keys2.default)(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
              obj = obj[charkey];
            }
          }
          if (isEmpty(obj)) {
            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
          }
          if (_this.options.validator != null) {
            xpath = "/" + function () {
              var i, len, results;
              results = [];
              for (i = 0, len = stack.length; i < len; i++) {
                node = stack[i];
                results.push(node["#name"]);
              }
              return results;
            }().concat(nodeName).join("/");
            (function () {
              var err;
              try {
                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
              } catch (error1) {
                err = error1;
                return _this.emit("error", err);
              }
            })();
          }
          if (_this.options.explicitChildren && !_this.options.mergeAttrs && (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === 'object') {
            if (!_this.options.preserveChildrenOrder) {
              node = {};
              if (_this.options.attrkey in obj) {
                node[_this.options.attrkey] = obj[_this.options.attrkey];
                delete obj[_this.options.attrkey];
              }
              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                node[_this.options.charkey] = obj[_this.options.charkey];
                delete obj[_this.options.charkey];
              }
              if ((0, _getOwnPropertyNames2.default)(obj).length > 0) {
                node[_this.options.childkey] = obj;
              }
              obj = node;
            } else if (s) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              objClone = {};
              for (key in obj) {
                if (!hasProp.call(obj, key)) continue;
                objClone[key] = obj[key];
              }
              s[_this.options.childkey].push(objClone);
              delete obj["#name"];
              if ((0, _keys2.default)(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }
          }
          if (stack.length > 0) {
            return _this.assignOrPush(s, nodeName, obj);
          } else {
            if (_this.options.explicitRoot) {
              old = obj;
              obj = {};
              obj[nodeName] = old;
            }
            _this.resultObject = obj;
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      }(this);
      ontext = function (_this) {
        return function (text) {
          var charChild, s;
          s = stack[stack.length - 1];
          if (s) {
            s[charkey] += text;
            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              charChild = {
                '#name': '__text__'
              };
              charChild[charkey] = text;
              if (_this.options.normalize) {
                charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
              }
              s[_this.options.childkey].push(charChild);
            }
            return s;
          }
        };
      }(this);
      this.saxParser.ontext = ontext;
      return this.saxParser.oncdata = function (_this) {
        return function (text) {
          var s;
          s = ontext(text);
          if (s) {
            return s.cdata = true;
          }
        };
      }(this);
    };

    Parser.prototype.parseString = function (str, cb) {
      var err;
      if (cb != null && typeof cb === "function") {
        this.on("end", function (result) {
          this.reset();
          return cb(null, result);
        });
        this.on("error", function (err) {
          this.reset();
          return cb(err);
        });
      }
      try {
        str = str.toString();
        if (str.trim() === '') {
          this.emit("end", null);
          return true;
        }
        str = bom.stripBOM(str);
        if (this.options.async) {
          this.remaining = str;
          setImmediate(this.processAsync);
          return this.saxParser;
        }
        return this.saxParser.write(str).close();
      } catch (error1) {
        err = error1;
        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
          this.emit('error', err);
          return this.saxParser.errThrown = true;
        } else if (this.saxParser.ended) {
          throw err;
        }
      }
    };

    return Parser;
  }(events.EventEmitter);

  exports.parseString = function (str, a, b) {
    var cb, options, parser;
    if (b != null) {
      if (typeof b === 'function') {
        cb = b;
      }
      if ((typeof a === 'undefined' ? 'undefined' : (0, _typeof3.default)(a)) === 'object') {
        options = a;
      }
    } else {
      if (typeof a === 'function') {
        cb = a;
      }
      options = {};
    }
    parser = new exports.Parser(options);
    return parser.parseString(str, cb);
  };
}).call(undefined);

},{"./bom":206,"./defaults":208,"./processors":210,"babel-runtime/core-js/object/get-own-property-names":20,"babel-runtime/core-js/object/keys":22,"babel-runtime/helpers/typeof":31,"events":156,"sax":192,"timers":199}],210:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  "use strict";

  var prefixMatch;

  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

  exports.normalize = function (str) {
    return str.toLowerCase();
  };

  exports.firstCharLowerCase = function (str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
  };

  exports.stripPrefix = function (str) {
    return str.replace(prefixMatch, '');
  };

  exports.parseNumbers = function (str) {
    if (!isNaN(str)) {
      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
    }
    return str;
  };

  exports.parseBooleans = function (str) {
    if (/^(?:true|false)$/i.test(str)) {
      str = str.toLowerCase() === 'true';
    }
    return str;
  };
}).call(undefined);

},{}],211:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  "use strict";

  var builder,
      defaults,
      parser,
      processors,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  defaults = require('./defaults');

  builder = require('./builder');

  parser = require('./parser');

  processors = require('./processors');

  exports.defaults = defaults.defaults;

  exports.processors = processors;

  exports.ValidationError = function (superClass) {
    extend(ValidationError, superClass);

    function ValidationError(message) {
      this.message = message;
    }

    return ValidationError;
  }(Error);

  exports.Builder = builder.Builder;

  exports.Parser = parser.Parser;

  exports.parseString = parser.parseString;
}).call(undefined);

},{"./builder":207,"./defaults":208,"./parser":209,"./processors":210}],212:[function(require,module,exports){
'use strict';

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 1.12.7
(function () {
  var assign,
      isArray,
      isEmpty,
      isFunction,
      isObject,
      isPlainObject,
      slice = [].slice,
      hasProp = {}.hasOwnProperty;

  assign = function assign() {
    var i, key, len, source, sources, target;
    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (isFunction(_assign2.default)) {
      _assign2.default.apply(null, arguments);
    } else {
      for (i = 0, len = sources.length; i < len; i++) {
        source = sources[i];
        if (source != null) {
          for (key in source) {
            if (!hasProp.call(source, key)) continue;
            target[key] = source[key];
          }
        }
      }
    }
    return target;
  };

  isFunction = function isFunction(val) {
    return !!val && Object.prototype.toString.call(val) === '[object Function]';
  };

  isObject = function isObject(val) {
    var ref;
    return !!val && ((ref = typeof val === 'undefined' ? 'undefined' : (0, _typeof3.default)(val)) === 'function' || ref === 'object');
  };

  isArray = function isArray(val) {
    if (isFunction(Array.isArray)) {
      return Array.isArray(val);
    } else {
      return Object.prototype.toString.call(val) === '[object Array]';
    }
  };

  isEmpty = function isEmpty(val) {
    var key;
    if (isArray(val)) {
      return !val.length;
    } else {
      for (key in val) {
        if (!hasProp.call(val, key)) continue;
        return false;
      }
      return true;
    }
  };

  isPlainObject = function isPlainObject(val) {
    var ctor, proto;
    return isObject(val) && (proto = (0, _getPrototypeOf2.default)(val)) && (ctor = proto.constructor) && typeof ctor === 'function' && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
  };

  module.exports.assign = assign;

  module.exports.isFunction = isFunction;

  module.exports.isObject = isObject;

  module.exports.isArray = isArray;

  module.exports.isEmpty = isEmpty;

  module.exports.isPlainObject = isPlainObject;
}).call(undefined);

},{"babel-runtime/core-js/object/assign":17,"babel-runtime/core-js/object/get-prototype-of":21,"babel-runtime/helpers/typeof":31}],213:[function(require,module,exports){
"use strict";

var _create = require("babel-runtime/core-js/object/create");

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLAttribute;

  module.exports = XMLAttribute = function () {
    function XMLAttribute(parent, name, value) {
      this.options = parent.options;
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing attribute name of element " + parent.name);
      }
      if (value == null) {
        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
      }
      this.name = this.stringify.attName(name);
      this.value = this.stringify.attValue(value);
    }

    XMLAttribute.prototype.clone = function () {
      return (0, _create2.default)(this);
    };

    XMLAttribute.prototype.toString = function (options) {
      return this.options.writer.set(options).attribute(this);
    };

    return XMLAttribute;
  }();
}).call(undefined);

},{"babel-runtime/core-js/object/create":18}],214:[function(require,module,exports){
"use strict";

var _create = require("babel-runtime/core-js/object/create");

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLCData,
      XMLNode,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  module.exports = XMLCData = function (superClass) {
    extend(XMLCData, superClass);

    function XMLCData(parent, text) {
      XMLCData.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing CDATA text");
      }
      this.text = this.stringify.cdata(text);
    }

    XMLCData.prototype.clone = function () {
      return (0, _create2.default)(this);
    };

    XMLCData.prototype.toString = function (options) {
      return this.options.writer.set(options).cdata(this);
    };

    return XMLCData;
  }(XMLNode);
}).call(undefined);

},{"./XMLNode":225,"babel-runtime/core-js/object/create":18}],215:[function(require,module,exports){
"use strict";

var _create = require("babel-runtime/core-js/object/create");

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLComment,
      XMLNode,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  module.exports = XMLComment = function (superClass) {
    extend(XMLComment, superClass);

    function XMLComment(parent, text) {
      XMLComment.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing comment text");
      }
      this.text = this.stringify.comment(text);
    }

    XMLComment.prototype.clone = function () {
      return (0, _create2.default)(this);
    };

    XMLComment.prototype.toString = function (options) {
      return this.options.writer.set(options).comment(this);
    };

    return XMLComment;
  }(XMLNode);
}).call(undefined);

},{"./XMLNode":225,"babel-runtime/core-js/object/create":18}],216:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLDTDAttList,
      XMLNode,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  module.exports = XMLDTDAttList = function (superClass) {
    extend(XMLDTDAttList, superClass);

    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      XMLDTDAttList.__super__.constructor.call(this, parent);
      if (elementName == null) {
        throw new Error("Missing DTD element name");
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name");
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type");
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default");
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT");
      }
      this.elementName = this.stringify.eleName(elementName);
      this.attributeName = this.stringify.attName(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      this.defaultValueType = defaultValueType;
    }

    XMLDTDAttList.prototype.toString = function (options) {
      return this.options.writer.set(options).dtdAttList(this);
    };

    return XMLDTDAttList;
  }(XMLNode);
}).call(undefined);

},{"./XMLNode":225}],217:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLDTDElement,
      XMLNode,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  module.exports = XMLDTDElement = function (superClass) {
    extend(XMLDTDElement, superClass);

    function XMLDTDElement(parent, name, value) {
      XMLDTDElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing DTD element name");
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (Array.isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.eleName(name);
      this.value = this.stringify.dtdElementValue(value);
    }

    XMLDTDElement.prototype.toString = function (options) {
      return this.options.writer.set(options).dtdElement(this);
    };

    return XMLDTDElement;
  }(XMLNode);
}).call(undefined);

},{"./XMLNode":225}],218:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLDTDEntity,
      XMLNode,
      isObject,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  isObject = require('./Utility').isObject;

  XMLNode = require('./XMLNode');

  module.exports = XMLDTDEntity = function (superClass) {
    extend(XMLDTDEntity, superClass);

    function XMLDTDEntity(parent, pe, name, value) {
      XMLDTDEntity.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing entity name");
      }
      if (value == null) {
        throw new Error("Missing entity value");
      }
      this.pe = !!pe;
      this.name = this.stringify.eleName(name);
      if (!isObject(value)) {
        this.value = this.stringify.dtdEntityValue(value);
      } else {
        if (!value.pubID && !value.sysID) {
          throw new Error("Public and/or system identifiers are required for an external entity");
        }
        if (value.pubID && !value.sysID) {
          throw new Error("System identifier is required for a public external entity");
        }
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        if (value.nData != null) {
          this.nData = this.stringify.dtdNData(value.nData);
        }
        if (this.pe && this.nData) {
          throw new Error("Notation declaration is not allowed in a parameter entity");
        }
      }
    }

    XMLDTDEntity.prototype.toString = function (options) {
      return this.options.writer.set(options).dtdEntity(this);
    };

    return XMLDTDEntity;
  }(XMLNode);
}).call(undefined);

},{"./Utility":212,"./XMLNode":225}],219:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLDTDNotation,
      XMLNode,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  module.exports = XMLDTDNotation = function (superClass) {
    extend(XMLDTDNotation, superClass);

    function XMLDTDNotation(parent, name, value) {
      XMLDTDNotation.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing notation name");
      }
      if (!value.pubID && !value.sysID) {
        throw new Error("Public or system identifiers are required for an external entity");
      }
      this.name = this.stringify.eleName(name);
      if (value.pubID != null) {
        this.pubID = this.stringify.dtdPubID(value.pubID);
      }
      if (value.sysID != null) {
        this.sysID = this.stringify.dtdSysID(value.sysID);
      }
    }

    XMLDTDNotation.prototype.toString = function (options) {
      return this.options.writer.set(options).dtdNotation(this);
    };

    return XMLDTDNotation;
  }(XMLNode);
}).call(undefined);

},{"./XMLNode":225}],220:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLDeclaration,
      XMLNode,
      isObject,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  isObject = require('./Utility').isObject;

  XMLNode = require('./XMLNode');

  module.exports = XMLDeclaration = function (superClass) {
    extend(XMLDeclaration, superClass);

    function XMLDeclaration(parent, version, encoding, standalone) {
      var ref;
      XMLDeclaration.__super__.constructor.call(this, parent);
      if (isObject(version)) {
        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
      }
      if (!version) {
        version = '1.0';
      }
      this.version = this.stringify.xmlVersion(version);
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    XMLDeclaration.prototype.toString = function (options) {
      return this.options.writer.set(options).declaration(this);
    };

    return XMLDeclaration;
  }(XMLNode);
}).call(undefined);

},{"./Utility":212,"./XMLNode":225}],221:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLDTDAttList,
      XMLDTDElement,
      XMLDTDEntity,
      XMLDTDNotation,
      XMLDocType,
      XMLNode,
      isObject,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  isObject = require('./Utility').isObject;

  XMLNode = require('./XMLNode');

  XMLDTDAttList = require('./XMLDTDAttList');

  XMLDTDEntity = require('./XMLDTDEntity');

  XMLDTDElement = require('./XMLDTDElement');

  XMLDTDNotation = require('./XMLDTDNotation');

  module.exports = XMLDocType = function (superClass) {
    extend(XMLDocType, superClass);

    function XMLDocType(parent, pubID, sysID) {
      var ref, ref1;
      XMLDocType.__super__.constructor.call(this, parent);
      this.documentObject = parent;
      if (isObject(pubID)) {
        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
      }
      if (sysID == null) {
        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
      }
      if (pubID != null) {
        this.pubID = this.stringify.dtdPubID(pubID);
      }
      if (sysID != null) {
        this.sysID = this.stringify.dtdSysID(sysID);
      }
    }

    XMLDocType.prototype.element = function (name, value) {
      var child;
      child = new XMLDTDElement(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.attList = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var child;
      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.entity = function (name, value) {
      var child;
      child = new XMLDTDEntity(this, false, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.pEntity = function (name, value) {
      var child;
      child = new XMLDTDEntity(this, true, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.notation = function (name, value) {
      var child;
      child = new XMLDTDNotation(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.toString = function (options) {
      return this.options.writer.set(options).docType(this);
    };

    XMLDocType.prototype.ele = function (name, value) {
      return this.element(name, value);
    };

    XMLDocType.prototype.att = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
    };

    XMLDocType.prototype.ent = function (name, value) {
      return this.entity(name, value);
    };

    XMLDocType.prototype.pent = function (name, value) {
      return this.pEntity(name, value);
    };

    XMLDocType.prototype.not = function (name, value) {
      return this.notation(name, value);
    };

    XMLDocType.prototype.up = function () {
      return this.root() || this.documentObject;
    };

    return XMLDocType;
  }(XMLNode);
}).call(undefined);

},{"./Utility":212,"./XMLDTDAttList":216,"./XMLDTDElement":217,"./XMLDTDEntity":218,"./XMLDTDNotation":219,"./XMLNode":225}],222:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLDocument,
      XMLNode,
      XMLStringWriter,
      XMLStringifier,
      isPlainObject,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  isPlainObject = require('./Utility').isPlainObject;

  XMLNode = require('./XMLNode');

  XMLStringifier = require('./XMLStringifier');

  XMLStringWriter = require('./XMLStringWriter');

  module.exports = XMLDocument = function (superClass) {
    extend(XMLDocument, superClass);

    function XMLDocument(options) {
      XMLDocument.__super__.constructor.call(this, null);
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter();
      }
      this.options = options;
      this.stringify = new XMLStringifier(options);
      this.isDocument = true;
    }

    XMLDocument.prototype.end = function (writer) {
      var writerOptions;
      if (!writer) {
        writer = this.options.writer;
      } else if (isPlainObject(writer)) {
        writerOptions = writer;
        writer = this.options.writer.set(writerOptions);
      }
      return writer.document(this);
    };

    XMLDocument.prototype.toString = function (options) {
      return this.options.writer.set(options).document(this);
    };

    return XMLDocument;
  }(XMLNode);
}).call(undefined);

},{"./Utility":212,"./XMLNode":225,"./XMLStringWriter":229,"./XMLStringifier":230}],223:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLAttribute,
      XMLCData,
      XMLComment,
      XMLDTDAttList,
      XMLDTDElement,
      XMLDTDEntity,
      XMLDTDNotation,
      XMLDeclaration,
      XMLDocType,
      XMLDocumentCB,
      XMLElement,
      XMLProcessingInstruction,
      XMLRaw,
      XMLStringWriter,
      XMLStringifier,
      XMLText,
      isFunction,
      isObject,
      isPlainObject,
      ref,
      hasProp = {}.hasOwnProperty;

  ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;

  XMLElement = require('./XMLElement');

  XMLCData = require('./XMLCData');

  XMLComment = require('./XMLComment');

  XMLRaw = require('./XMLRaw');

  XMLText = require('./XMLText');

  XMLProcessingInstruction = require('./XMLProcessingInstruction');

  XMLDeclaration = require('./XMLDeclaration');

  XMLDocType = require('./XMLDocType');

  XMLDTDAttList = require('./XMLDTDAttList');

  XMLDTDEntity = require('./XMLDTDEntity');

  XMLDTDElement = require('./XMLDTDElement');

  XMLDTDNotation = require('./XMLDTDNotation');

  XMLAttribute = require('./XMLAttribute');

  XMLStringifier = require('./XMLStringifier');

  XMLStringWriter = require('./XMLStringWriter');

  module.exports = XMLDocumentCB = function () {
    function XMLDocumentCB(options, onData, onEnd) {
      var writerOptions;
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter(options);
      } else if (isPlainObject(options.writer)) {
        writerOptions = options.writer;
        options.writer = new XMLStringWriter(writerOptions);
      }
      this.options = options;
      this.writer = options.writer;
      this.stringify = new XMLStringifier(options);
      this.onDataCallback = onData || function () {};
      this.onEndCallback = onEnd || function () {};
      this.currentNode = null;
      this.currentLevel = -1;
      this.openTags = {};
      this.documentStarted = false;
      this.documentCompleted = false;
      this.root = null;
    }

    XMLDocumentCB.prototype.node = function (name, attributes, text) {
      var ref1;
      if (name == null) {
        throw new Error("Missing node name");
      }
      if (this.root && this.currentLevel === -1) {
        throw new Error("Document can only have one root node");
      }
      this.openCurrent();
      name = name.valueOf();
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      this.currentNode = new XMLElement(this, name, attributes);
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      if (text != null) {
        this.text(text);
      }
      return this;
    };

    XMLDocumentCB.prototype.element = function (name, attributes, text) {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.dtdElement.apply(this, arguments);
      } else {
        return this.node(name, attributes, text);
      }
    };

    XMLDocumentCB.prototype.attribute = function (name, value) {
      var attName, attValue;
      if (!this.currentNode || this.currentNode.children) {
        throw new Error("att() can only be used immediately after an ele() call in callback mode");
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || value != null) {
          this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLDocumentCB.prototype.text = function (value) {
      var node;
      this.openCurrent();
      node = new XMLText(this, value);
      this.onData(this.writer.text(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.cdata = function (value) {
      var node;
      this.openCurrent();
      node = new XMLCData(this, value);
      this.onData(this.writer.cdata(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.comment = function (value) {
      var node;
      this.openCurrent();
      node = new XMLComment(this, value);
      this.onData(this.writer.comment(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.raw = function (value) {
      var node;
      this.openCurrent();
      node = new XMLRaw(this, value);
      this.onData(this.writer.raw(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.instruction = function (target, value) {
      var i, insTarget, insValue, len, node;
      this.openCurrent();
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        node = new XMLProcessingInstruction(this, target, value);
        this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
      }
      return this;
    };

    XMLDocumentCB.prototype.declaration = function (version, encoding, standalone) {
      var node;
      this.openCurrent();
      if (this.documentStarted) {
        throw new Error("declaration() must be the first node");
      }
      node = new XMLDeclaration(this, version, encoding, standalone);
      this.onData(this.writer.declaration(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.doctype = function (root, pubID, sysID) {
      this.openCurrent();
      if (root == null) {
        throw new Error("Missing root node name");
      }
      if (this.root) {
        throw new Error("dtd() must come before the root node");
      }
      this.currentNode = new XMLDocType(this, pubID, sysID);
      this.currentNode.rootNodeName = root;
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      return this;
    };

    XMLDocumentCB.prototype.dtdElement = function (name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDElement(this, name, value);
      this.onData(this.writer.dtdElement(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.attList = function (elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var node;
      this.openCurrent();
      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.entity = function (name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, false, name, value);
      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.pEntity = function (name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, true, name, value);
      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.notation = function (name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDNotation(this, name, value);
      this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.up = function () {
      if (this.currentLevel < 0) {
        throw new Error("The document node has no parent");
      }
      if (this.currentNode) {
        if (this.currentNode.children) {
          this.closeNode(this.currentNode);
        } else {
          this.openNode(this.currentNode);
        }
        this.currentNode = null;
      } else {
        this.closeNode(this.openTags[this.currentLevel]);
      }
      delete this.openTags[this.currentLevel];
      this.currentLevel--;
      return this;
    };

    XMLDocumentCB.prototype.end = function () {
      while (this.currentLevel >= 0) {
        this.up();
      }
      return this.onEnd();
    };

    XMLDocumentCB.prototype.openCurrent = function () {
      if (this.currentNode) {
        this.currentNode.children = true;
        return this.openNode(this.currentNode);
      }
    };

    XMLDocumentCB.prototype.openNode = function (node) {
      if (!node.isOpen) {
        if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
          this.root = node;
        }
        this.onData(this.writer.openNode(node, this.currentLevel));
        return node.isOpen = true;
      }
    };

    XMLDocumentCB.prototype.closeNode = function (node) {
      if (!node.isClosed) {
        this.onData(this.writer.closeNode(node, this.currentLevel));
        return node.isClosed = true;
      }
    };

    XMLDocumentCB.prototype.onData = function (chunk) {
      this.documentStarted = true;
      return this.onDataCallback(chunk);
    };

    XMLDocumentCB.prototype.onEnd = function () {
      this.documentCompleted = true;
      return this.onEndCallback();
    };

    XMLDocumentCB.prototype.ele = function () {
      return this.element.apply(this, arguments);
    };

    XMLDocumentCB.prototype.nod = function (name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.txt = function (value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.dat = function (value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.com = function (value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.ins = function (target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.dec = function (version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLDocumentCB.prototype.dtd = function (root, pubID, sysID) {
      return this.doctype(root, pubID, sysID);
    };

    XMLDocumentCB.prototype.e = function (name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLDocumentCB.prototype.n = function (name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.t = function (value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.d = function (value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.c = function (value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.r = function (value) {
      return this.raw(value);
    };

    XMLDocumentCB.prototype.i = function (target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.att = function () {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.a = function () {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.ent = function (name, value) {
      return this.entity(name, value);
    };

    XMLDocumentCB.prototype.pent = function (name, value) {
      return this.pEntity(name, value);
    };

    XMLDocumentCB.prototype.not = function (name, value) {
      return this.notation(name, value);
    };

    return XMLDocumentCB;
  }();
}).call(undefined);

},{"./Utility":212,"./XMLAttribute":213,"./XMLCData":214,"./XMLComment":215,"./XMLDTDAttList":216,"./XMLDTDElement":217,"./XMLDTDEntity":218,"./XMLDTDNotation":219,"./XMLDeclaration":220,"./XMLDocType":221,"./XMLElement":224,"./XMLProcessingInstruction":226,"./XMLRaw":227,"./XMLStringWriter":229,"./XMLStringifier":230,"./XMLText":231}],224:[function(require,module,exports){
'use strict';

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLAttribute,
      XMLElement,
      XMLNode,
      isFunction,
      isObject,
      ref,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction;

  XMLNode = require('./XMLNode');

  XMLAttribute = require('./XMLAttribute');

  module.exports = XMLElement = function (superClass) {
    extend(XMLElement, superClass);

    function XMLElement(parent, name, attributes) {
      XMLElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing element name");
      }
      this.name = this.stringify.eleName(name);
      this.attributes = {};
      if (attributes != null) {
        this.attribute(attributes);
      }
      if (parent.isDocument) {
        this.isRoot = true;
        this.documentObject = parent;
        parent.rootObject = this;
      }
    }

    XMLElement.prototype.clone = function () {
      var att, attName, clonedSelf, ref1;
      clonedSelf = (0, _create2.default)(this);
      if (clonedSelf.isRoot) {
        clonedSelf.documentObject = null;
      }
      clonedSelf.attributes = {};
      ref1 = this.attributes;
      for (attName in ref1) {
        if (!hasProp.call(ref1, attName)) continue;
        att = ref1[attName];
        clonedSelf.attributes[attName] = att.clone();
      }
      clonedSelf.children = [];
      this.children.forEach(function (child) {
        var clonedChild;
        clonedChild = child.clone();
        clonedChild.parent = clonedSelf;
        return clonedSelf.children.push(clonedChild);
      });
      return clonedSelf;
    };

    XMLElement.prototype.attribute = function (name, value) {
      var attName, attValue;
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || value != null) {
          this.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLElement.prototype.removeAttribute = function (name) {
      var attName, i, len;
      if (name == null) {
        throw new Error("Missing attribute name");
      }
      name = name.valueOf();
      if (Array.isArray(name)) {
        for (i = 0, len = name.length; i < len; i++) {
          attName = name[i];
          delete this.attributes[attName];
        }
      } else {
        delete this.attributes[name];
      }
      return this;
    };

    XMLElement.prototype.toString = function (options) {
      return this.options.writer.set(options).element(this);
    };

    XMLElement.prototype.att = function (name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.a = function (name, value) {
      return this.attribute(name, value);
    };

    return XMLElement;
  }(XMLNode);
}).call(undefined);

},{"./Utility":212,"./XMLAttribute":213,"./XMLNode":225,"babel-runtime/core-js/object/create":18}],225:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLCData,
      XMLComment,
      XMLDeclaration,
      XMLDocType,
      XMLElement,
      XMLNode,
      XMLProcessingInstruction,
      XMLRaw,
      XMLText,
      isEmpty,
      isFunction,
      isObject,
      ref,
      hasProp = {}.hasOwnProperty;

  ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  XMLProcessingInstruction = null;

  module.exports = XMLNode = function () {
    function XMLNode(parent) {
      this.parent = parent;
      if (this.parent) {
        this.options = this.parent.options;
        this.stringify = this.parent.stringify;
      }
      this.children = [];
      if (!XMLElement) {
        XMLElement = require('./XMLElement');
        XMLCData = require('./XMLCData');
        XMLComment = require('./XMLComment');
        XMLDeclaration = require('./XMLDeclaration');
        XMLDocType = require('./XMLDocType');
        XMLRaw = require('./XMLRaw');
        XMLText = require('./XMLText');
        XMLProcessingInstruction = require('./XMLProcessingInstruction');
      }
    }

    XMLNode.prototype.element = function (name, attributes, text) {
      var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
      lastChild = null;
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (Array.isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          item = name[j];
          lastChild = this.element(item);
        }
      } else if (isFunction(name)) {
        lastChild = this.element(name.apply());
      } else if (isObject(name)) {
        for (key in name) {
          if (!hasProp.call(name, key)) continue;
          val = name[key];
          if (isFunction(val)) {
            val = val.apply();
          }
          if (isObject(val) && isEmpty(val)) {
            val = null;
          }
          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
            for (k = 0, len1 = val.length; k < len1; k++) {
              item = val[k];
              childNode = {};
              childNode[key] = item;
              lastChild = this.element(childNode);
            }
          } else if (isObject(val)) {
            lastChild = this.element(key);
            lastChild.element(val);
          } else {
            lastChild = this.element(key, val);
          }
        }
      } else {
        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
          lastChild = this.text(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
          lastChild = this.cdata(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
          lastChild = this.comment(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
          lastChild = this.raw(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
        } else {
          lastChild = this.node(name, attributes, text);
        }
      }
      if (lastChild == null) {
        throw new Error("Could not create any elements with: " + name);
      }
      return lastChild;
    };

    XMLNode.prototype.insertBefore = function (name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.insertAfter = function (name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.remove = function () {
      var i, ref1;
      if (this.isRoot) {
        throw new Error("Cannot remove the root element");
      }
      i = this.parent.children.indexOf(this);
      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;
      return this.parent;
    };

    XMLNode.prototype.node = function (name, attributes, text) {
      var child, ref1;
      if (name != null) {
        name = name.valueOf();
      }
      attributes || (attributes = {});
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      child = new XMLElement(this, name, attributes);
      if (text != null) {
        child.text(text);
      }
      this.children.push(child);
      return child;
    };

    XMLNode.prototype.text = function (value) {
      var child;
      child = new XMLText(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.cdata = function (value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.comment = function (value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.commentBefore = function (value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.commentAfter = function (value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.raw = function (value) {
      var child;
      child = new XMLRaw(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.instruction = function (target, value) {
      var insTarget, insValue, instruction, j, len;
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (j = 0, len = target.length; j < len; j++) {
          insTarget = target[j];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        instruction = new XMLProcessingInstruction(this, target, value);
        this.children.push(instruction);
      }
      return this;
    };

    XMLNode.prototype.instructionBefore = function (target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.instructionAfter = function (target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.declaration = function (version, encoding, standalone) {
      var doc, xmldec;
      doc = this.document();
      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
      if (doc.children[0] instanceof XMLDeclaration) {
        doc.children[0] = xmldec;
      } else {
        doc.children.unshift(xmldec);
      }
      return doc.root() || doc;
    };

    XMLNode.prototype.doctype = function (pubID, sysID) {
      var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
      doc = this.document();
      doctype = new XMLDocType(doc, pubID, sysID);
      ref1 = doc.children;
      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
        child = ref1[i];
        if (child instanceof XMLDocType) {
          doc.children[i] = doctype;
          return doctype;
        }
      }
      ref2 = doc.children;
      for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
        child = ref2[i];
        if (child.isRoot) {
          doc.children.splice(i, 0, doctype);
          return doctype;
        }
      }
      doc.children.push(doctype);
      return doctype;
    };

    XMLNode.prototype.up = function () {
      if (this.isRoot) {
        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
      }
      return this.parent;
    };

    XMLNode.prototype.root = function () {
      var node;
      node = this;
      while (node) {
        if (node.isDocument) {
          return node.rootObject;
        } else if (node.isRoot) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.document = function () {
      var node;
      node = this;
      while (node) {
        if (node.isDocument) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.end = function (options) {
      return this.document().end(options);
    };

    XMLNode.prototype.prev = function () {
      var i;
      i = this.parent.children.indexOf(this);
      if (i < 1) {
        throw new Error("Already at the first node");
      }
      return this.parent.children[i - 1];
    };

    XMLNode.prototype.next = function () {
      var i;
      i = this.parent.children.indexOf(this);
      if (i === -1 || i === this.parent.children.length - 1) {
        throw new Error("Already at the last node");
      }
      return this.parent.children[i + 1];
    };

    XMLNode.prototype.importDocument = function (doc) {
      var clonedRoot;
      clonedRoot = doc.root().clone();
      clonedRoot.parent = this;
      clonedRoot.isRoot = false;
      this.children.push(clonedRoot);
      return this;
    };

    XMLNode.prototype.ele = function (name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.nod = function (name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.txt = function (value) {
      return this.text(value);
    };

    XMLNode.prototype.dat = function (value) {
      return this.cdata(value);
    };

    XMLNode.prototype.com = function (value) {
      return this.comment(value);
    };

    XMLNode.prototype.ins = function (target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.doc = function () {
      return this.document();
    };

    XMLNode.prototype.dec = function (version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLNode.prototype.dtd = function (pubID, sysID) {
      return this.doctype(pubID, sysID);
    };

    XMLNode.prototype.e = function (name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.n = function (name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.t = function (value) {
      return this.text(value);
    };

    XMLNode.prototype.d = function (value) {
      return this.cdata(value);
    };

    XMLNode.prototype.c = function (value) {
      return this.comment(value);
    };

    XMLNode.prototype.r = function (value) {
      return this.raw(value);
    };

    XMLNode.prototype.i = function (target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.u = function () {
      return this.up();
    };

    XMLNode.prototype.importXMLBuilder = function (doc) {
      return this.importDocument(doc);
    };

    return XMLNode;
  }();
}).call(undefined);

},{"./Utility":212,"./XMLCData":214,"./XMLComment":215,"./XMLDeclaration":220,"./XMLDocType":221,"./XMLElement":224,"./XMLProcessingInstruction":226,"./XMLRaw":227,"./XMLText":231}],226:[function(require,module,exports){
"use strict";

var _create = require("babel-runtime/core-js/object/create");

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLNode,
      XMLProcessingInstruction,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  module.exports = XMLProcessingInstruction = function (superClass) {
    extend(XMLProcessingInstruction, superClass);

    function XMLProcessingInstruction(parent, target, value) {
      XMLProcessingInstruction.__super__.constructor.call(this, parent);
      if (target == null) {
        throw new Error("Missing instruction target");
      }
      this.target = this.stringify.insTarget(target);
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    XMLProcessingInstruction.prototype.clone = function () {
      return (0, _create2.default)(this);
    };

    XMLProcessingInstruction.prototype.toString = function (options) {
      return this.options.writer.set(options).processingInstruction(this);
    };

    return XMLProcessingInstruction;
  }(XMLNode);
}).call(undefined);

},{"./XMLNode":225,"babel-runtime/core-js/object/create":18}],227:[function(require,module,exports){
"use strict";

var _create = require("babel-runtime/core-js/object/create");

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLNode,
      XMLRaw,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  module.exports = XMLRaw = function (superClass) {
    extend(XMLRaw, superClass);

    function XMLRaw(parent, text) {
      XMLRaw.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing raw text");
      }
      this.value = this.stringify.raw(text);
    }

    XMLRaw.prototype.clone = function () {
      return (0, _create2.default)(this);
    };

    XMLRaw.prototype.toString = function (options) {
      return this.options.writer.set(options).raw(this);
    };

    return XMLRaw;
  }(XMLNode);
}).call(undefined);

},{"./XMLNode":225,"babel-runtime/core-js/object/create":18}],228:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLCData,
      XMLComment,
      XMLDTDAttList,
      XMLDTDElement,
      XMLDTDEntity,
      XMLDTDNotation,
      XMLDeclaration,
      XMLDocType,
      XMLElement,
      XMLProcessingInstruction,
      XMLRaw,
      XMLStreamWriter,
      XMLText,
      XMLWriterBase,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  XMLDeclaration = require('./XMLDeclaration');

  XMLDocType = require('./XMLDocType');

  XMLCData = require('./XMLCData');

  XMLComment = require('./XMLComment');

  XMLElement = require('./XMLElement');

  XMLRaw = require('./XMLRaw');

  XMLText = require('./XMLText');

  XMLProcessingInstruction = require('./XMLProcessingInstruction');

  XMLDTDAttList = require('./XMLDTDAttList');

  XMLDTDElement = require('./XMLDTDElement');

  XMLDTDEntity = require('./XMLDTDEntity');

  XMLDTDNotation = require('./XMLDTDNotation');

  XMLWriterBase = require('./XMLWriterBase');

  module.exports = XMLStreamWriter = function (superClass) {
    extend(XMLStreamWriter, superClass);

    function XMLStreamWriter(stream, options) {
      XMLStreamWriter.__super__.constructor.call(this, options);
      this.stream = stream;
    }

    XMLStreamWriter.prototype.document = function (doc) {
      var child, i, j, len, len1, ref, ref1, results;
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        child.isLastRootNode = false;
      }
      doc.children[doc.children.length - 1].isLastRootNode = true;
      ref1 = doc.children;
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        child = ref1[j];
        switch (false) {
          case !(child instanceof XMLDeclaration):
            results.push(this.declaration(child));
            break;
          case !(child instanceof XMLDocType):
            results.push(this.docType(child));
            break;
          case !(child instanceof XMLComment):
            results.push(this.comment(child));
            break;
          case !(child instanceof XMLProcessingInstruction):
            results.push(this.processingInstruction(child));
            break;
          default:
            results.push(this.element(child));
        }
      }
      return results;
    };

    XMLStreamWriter.prototype.attribute = function (att) {
      return this.stream.write(' ' + att.name + '="' + att.value + '"');
    };

    XMLStreamWriter.prototype.cdata = function (node, level) {
      return this.stream.write(this.space(level) + '<![CDATA[' + node.text + ']]>' + this.endline(node));
    };

    XMLStreamWriter.prototype.comment = function (node, level) {
      return this.stream.write(this.space(level) + '<!-- ' + node.text + ' -->' + this.endline(node));
    };

    XMLStreamWriter.prototype.declaration = function (node, level) {
      this.stream.write(this.space(level));
      this.stream.write('<?xml version="' + node.version + '"');
      if (node.encoding != null) {
        this.stream.write(' encoding="' + node.encoding + '"');
      }
      if (node.standalone != null) {
        this.stream.write(' standalone="' + node.standalone + '"');
      }
      this.stream.write(this.spacebeforeslash + '?>');
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.docType = function (node, level) {
      var child, i, len, ref;
      level || (level = 0);
      this.stream.write(this.space(level));
      this.stream.write('<!DOCTYPE ' + node.root().name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      if (node.children.length > 0) {
        this.stream.write(' [');
        this.stream.write(this.endline(node));
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          switch (false) {
            case !(child instanceof XMLDTDAttList):
              this.dtdAttList(child, level + 1);
              break;
            case !(child instanceof XMLDTDElement):
              this.dtdElement(child, level + 1);
              break;
            case !(child instanceof XMLDTDEntity):
              this.dtdEntity(child, level + 1);
              break;
            case !(child instanceof XMLDTDNotation):
              this.dtdNotation(child, level + 1);
              break;
            case !(child instanceof XMLCData):
              this.cdata(child, level + 1);
              break;
            case !(child instanceof XMLComment):
              this.comment(child, level + 1);
              break;
            case !(child instanceof XMLProcessingInstruction):
              this.processingInstruction(child, level + 1);
              break;
            default:
              throw new Error("Unknown DTD node type: " + child.constructor.name);
          }
        }
        this.stream.write(']');
      }
      this.stream.write(this.spacebeforeslash + '>');
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.element = function (node, level) {
      var att, child, i, len, name, ref, ref1, space;
      level || (level = 0);
      space = this.space(level);
      this.stream.write(space + '<' + node.name);
      ref = node.attributes;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        this.attribute(att);
      }
      if (node.children.length === 0 || node.children.every(function (e) {
        return e.value === '';
      })) {
        if (this.allowEmpty) {
          this.stream.write('></' + node.name + '>');
        } else {
          this.stream.write(this.spacebeforeslash + '/>');
        }
      } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
        this.stream.write('>');
        this.stream.write(node.children[0].value);
        this.stream.write('</' + node.name + '>');
      } else {
        this.stream.write('>' + this.newline);
        ref1 = node.children;
        for (i = 0, len = ref1.length; i < len; i++) {
          child = ref1[i];
          switch (false) {
            case !(child instanceof XMLCData):
              this.cdata(child, level + 1);
              break;
            case !(child instanceof XMLComment):
              this.comment(child, level + 1);
              break;
            case !(child instanceof XMLElement):
              this.element(child, level + 1);
              break;
            case !(child instanceof XMLRaw):
              this.raw(child, level + 1);
              break;
            case !(child instanceof XMLText):
              this.text(child, level + 1);
              break;
            case !(child instanceof XMLProcessingInstruction):
              this.processingInstruction(child, level + 1);
              break;
            default:
              throw new Error("Unknown XML node type: " + child.constructor.name);
          }
        }
        this.stream.write(space + '</' + node.name + '>');
      }
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.processingInstruction = function (node, level) {
      this.stream.write(this.space(level) + '<?' + node.target);
      if (node.value) {
        this.stream.write(' ' + node.value);
      }
      return this.stream.write(this.spacebeforeslash + '?>' + this.endline(node));
    };

    XMLStreamWriter.prototype.raw = function (node, level) {
      return this.stream.write(this.space(level) + node.value + this.endline(node));
    };

    XMLStreamWriter.prototype.text = function (node, level) {
      return this.stream.write(this.space(level) + node.value + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdAttList = function (node, level) {
      this.stream.write(this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType);
      if (node.defaultValueType !== '#DEFAULT') {
        this.stream.write(' ' + node.defaultValueType);
      }
      if (node.defaultValue) {
        this.stream.write(' "' + node.defaultValue + '"');
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdElement = function (node, level) {
      this.stream.write(this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value);
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdEntity = function (node, level) {
      this.stream.write(this.space(level) + '<!ENTITY');
      if (node.pe) {
        this.stream.write(' %');
      }
      this.stream.write(' ' + node.name);
      if (node.value) {
        this.stream.write(' "' + node.value + '"');
      } else {
        if (node.pubID && node.sysID) {
          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }
        if (node.nData) {
          this.stream.write(' NDATA ' + node.nData);
        }
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdNotation = function (node, level) {
      this.stream.write(this.space(level) + '<!NOTATION ' + node.name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.pubID) {
        this.stream.write(' PUBLIC "' + node.pubID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.endline = function (node) {
      if (!node.isLastRootNode) {
        return this.newline;
      } else {
        return '';
      }
    };

    return XMLStreamWriter;
  }(XMLWriterBase);
}).call(undefined);

},{"./XMLCData":214,"./XMLComment":215,"./XMLDTDAttList":216,"./XMLDTDElement":217,"./XMLDTDEntity":218,"./XMLDTDNotation":219,"./XMLDeclaration":220,"./XMLDocType":221,"./XMLElement":224,"./XMLProcessingInstruction":226,"./XMLRaw":227,"./XMLText":231,"./XMLWriterBase":232}],229:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLCData,
      XMLComment,
      XMLDTDAttList,
      XMLDTDElement,
      XMLDTDEntity,
      XMLDTDNotation,
      XMLDeclaration,
      XMLDocType,
      XMLElement,
      XMLProcessingInstruction,
      XMLRaw,
      XMLStringWriter,
      XMLText,
      XMLWriterBase,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  XMLDeclaration = require('./XMLDeclaration');

  XMLDocType = require('./XMLDocType');

  XMLCData = require('./XMLCData');

  XMLComment = require('./XMLComment');

  XMLElement = require('./XMLElement');

  XMLRaw = require('./XMLRaw');

  XMLText = require('./XMLText');

  XMLProcessingInstruction = require('./XMLProcessingInstruction');

  XMLDTDAttList = require('./XMLDTDAttList');

  XMLDTDElement = require('./XMLDTDElement');

  XMLDTDEntity = require('./XMLDTDEntity');

  XMLDTDNotation = require('./XMLDTDNotation');

  XMLWriterBase = require('./XMLWriterBase');

  module.exports = XMLStringWriter = function (superClass) {
    extend(XMLStringWriter, superClass);

    function XMLStringWriter(options) {
      XMLStringWriter.__super__.constructor.call(this, options);
    }

    XMLStringWriter.prototype.document = function (doc) {
      var child, i, len, r, ref;
      this.textispresent = false;
      r = '';
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        r += function () {
          switch (false) {
            case !(child instanceof XMLDeclaration):
              return this.declaration(child);
            case !(child instanceof XMLDocType):
              return this.docType(child);
            case !(child instanceof XMLComment):
              return this.comment(child);
            case !(child instanceof XMLProcessingInstruction):
              return this.processingInstruction(child);
            default:
              return this.element(child, 0);
          }
        }.call(this);
      }
      if (this.pretty && r.slice(-this.newline.length) === this.newline) {
        r = r.slice(0, -this.newline.length);
      }
      return r;
    };

    XMLStringWriter.prototype.attribute = function (att) {
      return ' ' + att.name + '="' + att.value + '"';
    };

    XMLStringWriter.prototype.cdata = function (node, level) {
      return this.space(level) + '<![CDATA[' + node.text + ']]>' + this.newline;
    };

    XMLStringWriter.prototype.comment = function (node, level) {
      return this.space(level) + '<!-- ' + node.text + ' -->' + this.newline;
    };

    XMLStringWriter.prototype.declaration = function (node, level) {
      var r;
      r = this.space(level);
      r += '<?xml version="' + node.version + '"';
      if (node.encoding != null) {
        r += ' encoding="' + node.encoding + '"';
      }
      if (node.standalone != null) {
        r += ' standalone="' + node.standalone + '"';
      }
      r += this.spacebeforeslash + '?>';
      r += this.newline;
      return r;
    };

    XMLStringWriter.prototype.docType = function (node, level) {
      var child, i, len, r, ref;
      level || (level = 0);
      r = this.space(level);
      r += '<!DOCTYPE ' + node.root().name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      if (node.children.length > 0) {
        r += ' [';
        r += this.newline;
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          r += function () {
            switch (false) {
              case !(child instanceof XMLDTDAttList):
                return this.dtdAttList(child, level + 1);
              case !(child instanceof XMLDTDElement):
                return this.dtdElement(child, level + 1);
              case !(child instanceof XMLDTDEntity):
                return this.dtdEntity(child, level + 1);
              case !(child instanceof XMLDTDNotation):
                return this.dtdNotation(child, level + 1);
              case !(child instanceof XMLCData):
                return this.cdata(child, level + 1);
              case !(child instanceof XMLComment):
                return this.comment(child, level + 1);
              case !(child instanceof XMLProcessingInstruction):
                return this.processingInstruction(child, level + 1);
              default:
                throw new Error("Unknown DTD node type: " + child.constructor.name);
            }
          }.call(this);
        }
        r += ']';
      }
      r += this.spacebeforeslash + '>';
      r += this.newline;
      return r;
    };

    XMLStringWriter.prototype.element = function (node, level) {
      var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;
      level || (level = 0);
      textispresentwasset = false;
      if (this.textispresent) {
        this.newline = '';
        this.pretty = false;
      } else {
        this.newline = this.newlinedefault;
        this.pretty = this.prettydefault;
      }
      space = this.space(level);
      r = '';
      r += space + '<' + node.name;
      ref = node.attributes;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        r += this.attribute(att);
      }
      if (node.children.length === 0 || node.children.every(function (e) {
        return e.value === '';
      })) {
        if (this.allowEmpty) {
          r += '></' + node.name + '>' + this.newline;
        } else {
          r += this.spacebeforeslash + '/>' + this.newline;
        }
      } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
        r += '>';
        r += node.children[0].value;
        r += '</' + node.name + '>' + this.newline;
      } else {
        if (this.dontprettytextnodes) {
          ref1 = node.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            if (child.value != null) {
              this.textispresent++;
              textispresentwasset = true;
              break;
            }
          }
        }
        if (this.textispresent) {
          this.newline = '';
          this.pretty = false;
          space = this.space(level);
        }
        r += '>' + this.newline;
        ref2 = node.children;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          child = ref2[j];
          r += function () {
            switch (false) {
              case !(child instanceof XMLCData):
                return this.cdata(child, level + 1);
              case !(child instanceof XMLComment):
                return this.comment(child, level + 1);
              case !(child instanceof XMLElement):
                return this.element(child, level + 1);
              case !(child instanceof XMLRaw):
                return this.raw(child, level + 1);
              case !(child instanceof XMLText):
                return this.text(child, level + 1);
              case !(child instanceof XMLProcessingInstruction):
                return this.processingInstruction(child, level + 1);
              default:
                throw new Error("Unknown XML node type: " + child.constructor.name);
            }
          }.call(this);
        }
        if (textispresentwasset) {
          this.textispresent--;
        }
        if (!this.textispresent) {
          this.newline = this.newlinedefault;
          this.pretty = this.prettydefault;
        }
        r += space + '</' + node.name + '>' + this.newline;
      }
      return r;
    };

    XMLStringWriter.prototype.processingInstruction = function (node, level) {
      var r;
      r = this.space(level) + '<?' + node.target;
      if (node.value) {
        r += ' ' + node.value;
      }
      r += this.spacebeforeslash + '?>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.raw = function (node, level) {
      return this.space(level) + node.value + this.newline;
    };

    XMLStringWriter.prototype.text = function (node, level) {
      return this.space(level) + node.value + this.newline;
    };

    XMLStringWriter.prototype.dtdAttList = function (node, level) {
      var r;
      r = this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
      if (node.defaultValueType !== '#DEFAULT') {
        r += ' ' + node.defaultValueType;
      }
      if (node.defaultValue) {
        r += ' "' + node.defaultValue + '"';
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.dtdElement = function (node, level) {
      return this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + this.spacebeforeslash + '>' + this.newline;
    };

    XMLStringWriter.prototype.dtdEntity = function (node, level) {
      var r;
      r = this.space(level) + '<!ENTITY';
      if (node.pe) {
        r += ' %';
      }
      r += ' ' + node.name;
      if (node.value) {
        r += ' "' + node.value + '"';
      } else {
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.nData) {
          r += ' NDATA ' + node.nData;
        }
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.dtdNotation = function (node, level) {
      var r;
      r = this.space(level) + '<!NOTATION ' + node.name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.pubID) {
        r += ' PUBLIC "' + node.pubID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.openNode = function (node, level) {
      var att, name, r, ref;
      level || (level = 0);
      if (node instanceof XMLElement) {
        r = this.space(level) + '<' + node.name;
        ref = node.attributes;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          att = ref[name];
          r += this.attribute(att);
        }
        r += (node.children ? '>' : '/>') + this.newline;
        return r;
      } else {
        r = this.space(level) + '<!DOCTYPE ' + node.rootNodeName;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        r += (node.children ? ' [' : '>') + this.newline;
        return r;
      }
    };

    XMLStringWriter.prototype.closeNode = function (node, level) {
      level || (level = 0);
      switch (false) {
        case !(node instanceof XMLElement):
          return this.space(level) + '</' + node.name + '>' + this.newline;
        case !(node instanceof XMLDocType):
          return this.space(level) + ']>' + this.newline;
      }
    };

    return XMLStringWriter;
  }(XMLWriterBase);
}).call(undefined);

},{"./XMLCData":214,"./XMLComment":215,"./XMLDTDAttList":216,"./XMLDTDElement":217,"./XMLDTDEntity":218,"./XMLDTDNotation":219,"./XMLDeclaration":220,"./XMLDocType":221,"./XMLElement":224,"./XMLProcessingInstruction":226,"./XMLRaw":227,"./XMLText":231,"./XMLWriterBase":232}],230:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLStringifier,
      bind = function bind(fn, me) {
    return function () {
      return fn.apply(me, arguments);
    };
  },
      hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = function () {
    function XMLStringifier(options) {
      this.assertLegalChar = bind(this.assertLegalChar, this);
      var key, ref, value;
      options || (options = {});
      this.noDoubleEncoding = options.noDoubleEncoding;
      ref = options.stringify || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
    }

    XMLStringifier.prototype.eleName = function (val) {
      val = '' + val || '';
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.eleText = function (val) {
      val = '' + val || '';
      return this.assertLegalChar(this.elEscape(val));
    };

    XMLStringifier.prototype.cdata = function (val) {
      val = '' + val || '';
      val = val.replace(']]>', ']]]]><![CDATA[>');
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.comment = function (val) {
      val = '' + val || '';
      if (val.match(/--/)) {
        throw new Error("Comment text cannot contain double-hypen: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.raw = function (val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attName = function (val) {
      return val = '' + val || '';
    };

    XMLStringifier.prototype.attValue = function (val) {
      val = '' + val || '';
      return this.attEscape(val);
    };

    XMLStringifier.prototype.insTarget = function (val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.insValue = function (val) {
      val = '' + val || '';
      if (val.match(/\?>/)) {
        throw new Error("Invalid processing instruction value: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlVersion = function (val) {
      val = '' + val || '';
      if (!val.match(/1\.[0-9]+/)) {
        throw new Error("Invalid version number: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlEncoding = function (val) {
      val = '' + val || '';
      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
        throw new Error("Invalid encoding: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlStandalone = function (val) {
      if (val) {
        return "yes";
      } else {
        return "no";
      }
    };

    XMLStringifier.prototype.dtdPubID = function (val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdSysID = function (val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdElementValue = function (val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttType = function (val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttDefault = function (val) {
      if (val != null) {
        return '' + val || '';
      } else {
        return val;
      }
    };

    XMLStringifier.prototype.dtdEntityValue = function (val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdNData = function (val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    XMLStringifier.prototype.assertLegalChar = function (str) {
      var res;
      res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
      if (res) {
        throw new Error("Invalid character in string: " + str + " at index " + res.index);
      }
      return str;
    };

    XMLStringifier.prototype.elEscape = function (str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
    };

    XMLStringifier.prototype.attEscape = function (str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
    };

    return XMLStringifier;
  }();
}).call(undefined);

},{}],231:[function(require,module,exports){
"use strict";

var _create = require("babel-runtime/core-js/object/create");

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLNode,
      XMLText,
      extend = function extend(child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  },
      hasProp = {}.hasOwnProperty;

  XMLNode = require('./XMLNode');

  module.exports = XMLText = function (superClass) {
    extend(XMLText, superClass);

    function XMLText(parent, text) {
      XMLText.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing element text");
      }
      this.value = this.stringify.eleText(text);
    }

    XMLText.prototype.clone = function () {
      return (0, _create2.default)(this);
    };

    XMLText.prototype.toString = function (options) {
      return this.options.writer.set(options).text(this);
    };

    return XMLText;
  }(XMLNode);
}).call(undefined);

},{"./XMLNode":225,"babel-runtime/core-js/object/create":18}],232:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLWriterBase,
      hasProp = {}.hasOwnProperty;

  module.exports = XMLWriterBase = function () {
    function XMLWriterBase(options) {
      var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
      options || (options = {});
      this.pretty = options.pretty || false;
      this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
      if (this.pretty) {
        this.indent = (ref1 = options.indent) != null ? ref1 : '  ';
        this.newline = (ref2 = options.newline) != null ? ref2 : '\n';
        this.offset = (ref3 = options.offset) != null ? ref3 : 0;
        this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
      } else {
        this.indent = '';
        this.newline = '';
        this.offset = 0;
        this.dontprettytextnodes = 0;
      }
      this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : '';
      if (this.spacebeforeslash === true) {
        this.spacebeforeslash = ' ';
      }
      this.newlinedefault = this.newline;
      this.prettydefault = this.pretty;
      ref6 = options.writer || {};
      for (key in ref6) {
        if (!hasProp.call(ref6, key)) continue;
        value = ref6[key];
        this[key] = value;
      }
    }

    XMLWriterBase.prototype.set = function (options) {
      var key, ref, value;
      options || (options = {});
      if ("pretty" in options) {
        this.pretty = options.pretty;
      }
      if ("allowEmpty" in options) {
        this.allowEmpty = options.allowEmpty;
      }
      if (this.pretty) {
        this.indent = "indent" in options ? options.indent : '  ';
        this.newline = "newline" in options ? options.newline : '\n';
        this.offset = "offset" in options ? options.offset : 0;
        this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0;
      } else {
        this.indent = '';
        this.newline = '';
        this.offset = 0;
        this.dontprettytextnodes = 0;
      }
      this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : '';
      if (this.spacebeforeslash === true) {
        this.spacebeforeslash = ' ';
      }
      this.newlinedefault = this.newline;
      this.prettydefault = this.pretty;
      ref = options.writer || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
      return this;
    };

    XMLWriterBase.prototype.space = function (level) {
      var indent;
      if (this.pretty) {
        indent = (level || 0) + this.offset + 1;
        if (indent > 0) {
          return new Array(indent).join(this.indent);
        } else {
          return '';
        }
      } else {
        return '';
      }
    };

    return XMLWriterBase;
  }();
}).call(undefined);

},{}],233:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 1.12.7
(function () {
  var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;

  ref = require('./Utility'), assign = ref.assign, isFunction = ref.isFunction;

  XMLDocument = require('./XMLDocument');

  XMLDocumentCB = require('./XMLDocumentCB');

  XMLStringWriter = require('./XMLStringWriter');

  XMLStreamWriter = require('./XMLStreamWriter');

  module.exports.create = function (name, xmldec, doctype, options) {
    var doc, root;
    if (name == null) {
      throw new Error("Root element needs a name");
    }
    options = assign({}, xmldec, doctype, options);
    doc = new XMLDocument(options);
    root = doc.element(name);
    if (!options.headless) {
      doc.declaration(options);
      if (options.pubID != null || options.sysID != null) {
        doc.doctype(options);
      }
    }
    return root;
  };

  module.exports.begin = function (options, onData, onEnd) {
    var ref1;
    if (isFunction(options)) {
      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
      options = {};
    }
    if (onData) {
      return new XMLDocumentCB(options, onData, onEnd);
    } else {
      return new XMLDocument(options);
    }
  };

  module.exports.stringWriter = function (options) {
    return new XMLStringWriter(options);
  };

  module.exports.streamWriter = function (stream, options) {
    return new XMLStreamWriter(stream, options);
  };
}).call(undefined);

},{"./Utility":212,"./XMLDocument":222,"./XMLDocumentCB":223,"./XMLStreamWriter":228,"./XMLStringWriter":229}],234:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],235:[function(require,module,exports){
'use strict';

var Buffer = require('buffer').Buffer;
var sha = require('./sha');
var sha256 = require('./sha256');
var md5 = require('./md5');

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
};

var blocksize = 64;
var zeroBuffer = new Buffer(blocksize);
zeroBuffer.fill(0);

function hmac(fn, key, data) {
  if (!Buffer.isBuffer(key)) key = new Buffer(key);
  if (!Buffer.isBuffer(data)) data = new Buffer(data);

  if (key.length > blocksize) {
    key = fn(key);
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize);
  }

  var ipad = new Buffer(blocksize),
      opad = new Buffer(blocksize);
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36;
    opad[i] = key[i] ^ 0x5C;
  }

  var hash = fn(Buffer.concat([ipad, data]));
  return fn(Buffer.concat([opad, hash]));
}

function hash(alg, key) {
  alg = alg || 'sha1';
  var fn = algorithms[alg];
  var bufs = [];
  var length = 0;
  if (!fn) error('algorithm:', alg, 'is not yet supported');
  return {
    update: function update(data) {
      if (!Buffer.isBuffer(data)) data = new Buffer(data);

      bufs.push(data);
      length += data.length;
      return this;
    },
    digest: function digest(enc) {
      var buf = Buffer.concat(bufs);
      var r = key ? hmac(fn, key, buf) : fn(buf);
      bufs = null;
      return enc ? r.toString(enc) : r;
    }
  };
}

function error() {
  var m = [].slice.call(arguments).join(' ');
  throw new Error([m, 'we accept pull requests', 'http://github.com/dominictarr/crypto-browserify'].join('\n'));
}

exports.createHash = function (alg) {
  return hash(alg);
};
exports.createHmac = function (alg, key) {
  return hash(alg, key);
};

function each(a, f) {
  for (var i in a) {
    f(a[i], i);
  }
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials', 'createCipher', 'createCipheriv', 'createDecipher', 'createDecipheriv', 'createSign', 'createVerify', 'createDiffieHellman', 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet');
  };
});

},{"./md5":237,"./sha":238,"./sha256":239,"buffer":37}],236:[function(require,module,exports){
'use strict';

var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize);zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if (buf.length % intSize !== 0) {
    var len = buf.length + (intSize - buf.length % intSize);
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":37}],237:[function(require,module,exports){
"use strict";

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test() {
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[(len + 64 >>> 9 << 4) + 14] = len;

  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
    d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);

    a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
    d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t) {
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
}
function md5_ff(a, b, c, d, x, s, t) {
  return md5_cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t) {
  return md5_cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t) {
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t) {
  return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xFFFF;
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":236}],238:[function(require,module,exports){
'use strict';

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = require('./helpers');

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << 24 - len % 32;
  x[(len + 64 >> 9 << 4) + 15] = len;

  var w = Array(80);
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  var e = -1009589776;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for (var j = 0; j < 80; j++) {
      if (j < 16) w[j] = x[i + j];else w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);
}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d) {
  if (t < 20) return b & c | ~b & d;
  if (t < 40) return b ^ c ^ d;
  if (t < 60) return b & c | b & d | c & d;
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t) {
  return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xFFFF;
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":236}],239:[function(require,module,exports){
'use strict';

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = require('./helpers');

var safe_add = function safe_add(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xFFFF;
};

var S = function S(X, n) {
  return X >>> n | X << 32 - n;
};

var R = function R(X, n) {
  return X >>> n;
};

var Ch = function Ch(x, y, z) {
  return x & y ^ ~x & z;
};

var Maj = function Maj(x, y, z) {
  return x & y ^ x & z ^ y & z;
};

var Sigma0256 = function Sigma0256(x) {
  return S(x, 2) ^ S(x, 13) ^ S(x, 22);
};

var Sigma1256 = function Sigma1256(x) {
  return S(x, 6) ^ S(x, 11) ^ S(x, 25);
};

var Gamma0256 = function Gamma0256(x) {
  return S(x, 7) ^ S(x, 18) ^ R(x, 3);
};

var Gamma1256 = function Gamma1256(x) {
  return S(x, 17) ^ S(x, 19) ^ R(x, 10);
};

var core_sha256 = function core_sha256(m, l) {
  var K = new Array(0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0xFC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x6CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
  var W = new Array(64);
  var a, b, c, d, e, f, g, h, i, j;
  var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << 24 - l % 32;
  m[(l + 64 >> 9 << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0];b = HASH[1];c = HASH[2];d = HASH[3];e = HASH[4];f = HASH[5];g = HASH[6];h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g;g = f;f = e;e = safe_add(d, T1);d = c;c = b;b = a;a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]);HASH[1] = safe_add(b, HASH[1]);HASH[2] = safe_add(c, HASH[2]);HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]);HASH[5] = safe_add(f, HASH[5]);HASH[6] = safe_add(g, HASH[6]);HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":236}],240:[function(require,module,exports){
(function (global){
"use strict";

var _create = require("babel-runtime/core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function (f) {
  if ((typeof exports === "undefined" ? "undefined" : (0, _typeof3.default)(exports)) === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define([], f);
  } else {
    var g;if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }g.mime = f();
  }
})(function () {
  var define, module, exports;return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
        }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
          var n = t[o][1][e];return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
      s(r[o]);
    }return s;
  }({ 1: [function (require, module, exports) {
      'use strict';

      /**
       * @param typeMap [Object] Map of MIME type -> Array[extensions]
       * @param ...
       */

      var Mime = function () {
        function Mime() {
          (0, _classCallCheck3.default)(this, Mime);

          this._types = (0, _create2.default)(null);
          this._extensions = (0, _create2.default)(null);

          for (var i = 0; i < arguments.length; i++) {
            this.define(arguments[i]);
          }
        }

        /**
         * Define mimetype -> xtension mappings.  Each key is a mime-type that maps
         * to an array of extensions associated with the type.  The first extension is
         * used as the default extension for the type.
         *
         * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
         *
         * @param map (Object) type definitions
         */


        (0, _createClass3.default)(Mime, [{
          key: "define",
          value: function define(typeMap, force) {
            for (var type in typeMap) {
              var extensions = typeMap[type];
              for (var i = 0; i < extensions.length; i++) {
                var ext = extensions[i];
                if (!force && ext in this._types) {
                  throw new Error("Attempt to change mapping for \"" + ext + "\" extension from \"" + this._types[ext] + "\" to \"" + type + "\". Pass `force=true` to allow this, otherwise remove \"" + ext + "\" from the list of extensions for \"" + type + "\".");
                }

                this._types[ext] = type;
              }

              // Use first extension as default
              if (force || !this._extensions[type]) {
                this._extensions[type] = extensions[0];
              }
            }
          }

          /**
           * Lookup a mime type based on extension
           */

        }, {
          key: "getType",
          value: function getType(path) {
            path = String(path);
            var last = path.replace(/^.*[/\\]/, '').toLowerCase();
            var ext = last.replace(/^.*\./, '').toLowerCase();

            var hasPath = last.length < path.length;
            var hasDot = ext.length < last.length - 1;

            return (hasDot || !hasPath) && this._types[ext] || null;
          }

          /**
           * Return file extension associated with a mime type
           */

        }, {
          key: "getExtension",
          value: function getExtension(type) {
            type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
            return type && this._extensions[type.toLowerCase()] || null;
          }
        }]);
        return Mime;
      }();

      module.exports = Mime;
    }, {}], 2: [function (r, module, exports) {
      'use strict';

      var Mime = r('./Mime');
      module.exports = new Mime(r('./types/standard'), r('./types/other'));
    }, { "./Mime": 1, "./types/other": 3, "./types/standard": 4 }], 3: [function (require, module, exports) {
      module.exports = { "application/prs.cww": ["cww"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-otf": [], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-ttf": ["ttf", "ttc"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
    }, {}], 4: [function (require, module, exports) {
      module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": ["woff"], "application/font-woff2": ["woff2"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/pskc+xml": ["pskcxml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/voicexml+xml": ["vxml"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/otf": ["otf"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/ktx": ["ktx"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/webp": ["webp"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
    }, {}] }, {}, [2])(2);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"babel-runtime/core-js/object/create":18,"babel-runtime/helpers/classCallCheck":29,"babel-runtime/helpers/createClass":30,"babel-runtime/helpers/typeof":31}],241:[function(require,module,exports){
'use strict';

// copy from https://github.com/node-modules/utility for browser

exports.encodeURIComponent = function (text) {
  try {
    return encodeURIComponent(text);
  } catch (e) {
    return text;
  }
};

exports.escape = require('escape-html');

exports.timestamp = function timestamp(t) {
  if (t) {
    var v = t;
    if (typeof v === 'string') {
      v = Number(v);
    }
    if (String(t).length === 10) {
      v *= 1000;
    }
    return new Date(v);
  }
  return Math.round(Date.now() / 1000);
};

},{"escape-html":155}],242:[function(require,module,exports){
(function (process,Buffer){
'use strict';

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var util = require('util');
var urlutil = require('url');
var http = require('http');
var https = require('https');
var debug = require('debug')('urllib');
var ms = require('humanize-ms');

var _Promise;

var REQUEST_ID = 0;
var MAX_VALUE = Math.pow(2, 31) - 10;
var PROTO_RE = /^https?:\/\//i;

function getAgent(agent, defaultAgent) {
  return agent === undefined ? defaultAgent : agent;
}

function makeCallback(resolve, reject) {
  return function (err, data, res) {
    if (err) {
      return reject(err);
    }
    resolve({
      data: data,
      status: res.statusCode,
      headers: res.headers,
      res: res
    });
  };
}

// exports.TIMEOUT = ms('5s');
exports.TIMEOUTS = [ms('300s'), ms('300s')];

var TEXT_DATA_TYPES = ['json', 'text'];

exports.request = function request(url, args, callback) {
  // request(url, callback)
  if (arguments.length === 2 && typeof args === 'function') {
    callback = args;
    args = null;
  }
  if (typeof callback === 'function') {
    return exports.requestWithCallback(url, args, callback);
  }

  // Promise
  if (!_Promise) {
    _Promise = require('any-promise');
  }
  return new _Promise(function (resolve, reject) {
    exports.requestWithCallback(url, args, makeCallback(resolve, reject));
  });
};

exports.requestWithCallback = function requestWithCallback(url, args, callback) {
  // requestWithCallback(url, callback)
  if (!url || typeof url !== 'string' && (typeof url === 'undefined' ? 'undefined' : (0, _typeof3.default)(url)) !== 'object') {
    var msg = util.format('expect request url to be a string or a http request options, but got %j', url);
    throw new Error(msg);
  }

  if (arguments.length === 2 && typeof args === 'function') {
    callback = args;
    args = null;
  }

  args = args || {};
  if (REQUEST_ID >= MAX_VALUE) {
    REQUEST_ID = 0;
  }
  var reqId = ++REQUEST_ID;

  args.requestUrls = args.requestUrls || [];

  var reqMeta = {
    requestId: reqId,
    url: url,
    args: args,
    ctx: args.ctx
  };
  if (args.emitter) {
    args.emitter.emit('request', reqMeta);
  }

  args.timeout = args.timeout || exports.TIMEOUTS;
  args.maxRedirects = args.maxRedirects || 10;
  args.streaming = args.streaming || args.customResponse;
  var requestStartTime = Date.now();
  var parsedUrl;

  if (typeof url === 'string') {
    if (!PROTO_RE.test(url)) {
      // Support `request('www.server.com')`
      url = 'http://' + url;
    }
    parsedUrl = urlutil.parse(url);
  } else {
    parsedUrl = url;
  }

  var method = (args.type || args.method || parsedUrl.method || 'GET').toUpperCase();
  var port = parsedUrl.port || 80;
  var httplib = http;
  var agent = getAgent(args.agent, exports.agent);
  var fixJSONCtlChars = args.fixJSONCtlChars;

  if (parsedUrl.protocol === 'https:') {
    httplib = https;
    agent = getAgent(args.httpsAgent, exports.httpsAgent);

    if (!parsedUrl.port) {
      port = 443;
    }
  }

  // request through proxy tunnel
  // var proxyTunnelAgent = detectProxyAgent(parsedUrl, args);
  // if (proxyTunnelAgent) {
  //   agent = proxyTunnelAgent;
  // }

  var options = {
    host: parsedUrl.hostname || parsedUrl.host || 'localhost',
    path: parsedUrl.path || '/',
    method: method,
    port: port,
    agent: agent,
    headers: args.headers || {},
    // default is dns.lookup
    // https://github.com/nodejs/node/blob/master/lib/net.js#L986
    // custom dnslookup require node >= 4.0.0
    // https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/net.js#L952
    lookup: args.lookup
  };

  if (Array.isArray(args.timeout)) {
    options.requestTimeout = args.timeout[args.timeout.length - 1];
  } else if (typeof args.timeout !== 'undefined') {
    options.requestTimeout = args.timeout;
  }

  var sslNames = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'rejectUnauthorized', 'secureProtocol', 'secureOptions'];
  for (var i = 0; i < sslNames.length; i++) {
    var name = sslNames[i];
    if (args.hasOwnProperty(name)) {
      options[name] = args[name];
    }
  }

  // don't check ssl
  if (options.rejectUnauthorized === false && !options.hasOwnProperty('secureOptions')) {
    options.secureOptions = require('constants').SSL_OP_NO_TLSv1_2;
  }

  var auth = args.auth || parsedUrl.auth;
  if (auth) {
    options.auth = auth;
  }

  var body = args.content || args.data;
  var dataAsQueryString = method === 'GET' || method === 'HEAD' || args.dataAsQueryString;
  if (!args.content) {
    if (body && !(typeof body === 'string' || Buffer.isBuffer(body))) {
      if (dataAsQueryString) {
        // read: GET, HEAD, use query string
        body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);
      } else {
        var contentType = options.headers['Content-Type'] || options.headers['content-type'];
        // auto add application/x-www-form-urlencoded when using urlencode form request
        if (!contentType) {
          if (args.contentType === 'json') {
            contentType = 'application/json';
          } else {
            contentType = 'application/x-www-form-urlencoded';
          }
          options.headers['Content-Type'] = contentType;
        }

        if (parseContentType(contentType).type === 'application/json') {
          body = (0, _stringify2.default)(body);
        } else {
          // 'application/x-www-form-urlencoded'
          body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);
        }
      }
    }
  }

  // if it's a GET or HEAD request, data should be sent as query string
  if (dataAsQueryString && body) {
    options.path += (parsedUrl.query ? '&' : '?') + body;
    body = null;
  }

  var requestSize = 0;
  if (body) {
    var length = body.length;
    if (!Buffer.isBuffer(body)) {
      length = Buffer.byteLength(body);
    }
    requestSize = options.headers['Content-Length'] = length;
  }

  if (args.dataType === 'json') {
    options.headers.Accept = 'application/json';
  }

  if (typeof args.beforeRequest === 'function') {
    // you can use this hook to change every thing.
    args.beforeRequest(options);
  }
  var connectTimer = null;
  var responseTimer = null;
  var __err = null;
  var connected = false; // socket connected or not
  var keepAliveSocket = false; // request with keepalive socket
  var responseSize = 0;
  var statusCode = -1;
  var responseAborted = false;
  var remoteAddress = '';
  var remotePort = '';
  var timing = null;
  if (args.timing) {
    timing = {
      // socket assigned
      queuing: 0,
      // dns lookup time
      dnslookup: 0,
      // socket connected
      connected: 0,
      // request sent
      requestSent: 0,
      // Time to first byte (TTFB)
      waiting: 0,
      contentDownload: 0
    };
  }

  function cancelConnectTimer() {
    if (connectTimer) {
      clearTimeout(connectTimer);
      connectTimer = null;
    }
  }
  function cancelResponseTimer() {
    if (responseTimer) {
      clearTimeout(responseTimer);
      responseTimer = null;
    }
  }

  function done(err, data, res) {
    cancelResponseTimer();
    if (!callback) {
      console.warn('[urllib:warn] [%s] [%s] [worker:%s] %s %s callback twice!!!', Date(), reqId, process.pid, options.method, url);
      // https://github.com/node-modules/urllib/pull/30
      if (err) {
        console.warn('[urllib:warn] [%s] [%s] [worker:%s] %s: %s\nstack: %s', Date(), reqId, process.pid, err.name, err.message, err.stack);
      }
      return;
    }
    var cb = callback;
    callback = null;
    var headers = {};
    if (res) {
      statusCode = res.statusCode;
      headers = res.headers;
    }

    // handle digest auth
    if (statusCode === 401 && headers['www-authenticate'] && (!args.headers || !args.headers.Authorization) && args.digestAuth) {
      var authenticate = headers['www-authenticate'];
      if (authenticate.indexOf('Digest ') >= 0) {
        debug('Request#%d %s: got digest auth header WWW-Authenticate: %s', reqId, url, authenticate);
        args.headers = args.headers || {};
        args.headers.Authorization = digestAuthHeader(options.method, options.path, authenticate, args.digestAuth);
        debug('Request#%d %s: auth with digest header: %s', reqId, url, args.headers.Authorization);
        if (res.headers['set-cookie']) {
          args.headers.Cookie = res.headers['set-cookie'].join(';');
        }
        return exports.requestWithCallback(url, args, cb);
      }
    }

    var requestUseTime = Date.now() - requestStartTime;
    if (timing) {
      timing.contentDownload = requestUseTime;
    }

    debug('[%sms] done, %s bytes HTTP %s %s %s %s, keepAliveSocket: %s, timing: %j', requestUseTime, responseSize, statusCode, options.method, options.host, options.path, keepAliveSocket, timing);

    var response = {
      status: statusCode,
      statusCode: statusCode,
      headers: headers,
      size: responseSize,
      aborted: responseAborted,
      rt: requestUseTime,
      keepAliveSocket: keepAliveSocket,
      data: data,
      requestUrls: args.requestUrls,
      timing: timing,
      remoteAddress: remoteAddress,
      remotePort: remotePort
    };

    if (err) {
      var agentStatus = '';
      if (agent && typeof agent.getCurrentStatus === 'function') {
        // add current agent status to error message for logging and debug
        agentStatus = ', agent status: ' + (0, _stringify2.default)(agent.getCurrentStatus());
      }
      err.message += ', ' + options.method + ' ' + url + ' ' + statusCode + ' (connected: ' + connected + ', keepalive socket: ' + keepAliveSocket + agentStatus + ')' + '\nheaders: ' + (0, _stringify2.default)(headers);
      err.data = data;
      err.path = options.path;
      err.status = statusCode;
      err.headers = headers;
      err.res = response;
    }

    cb(err, data, args.streaming ? res : response);

    if (args.emitter) {
      // keep to use the same reqMeta object on request event before
      reqMeta.url = url;
      reqMeta.socket = req && req.connection;
      reqMeta.options = options;
      reqMeta.size = requestSize;

      args.emitter.emit('response', {
        requestId: reqId,
        error: err,
        ctx: args.ctx,
        req: reqMeta,
        res: response
      });
    }
  }

  function handleRedirect(res) {
    var err = null;
    if (args.followRedirect && statuses.redirect[res.statusCode]) {
      // handle redirect
      args._followRedirectCount = (args._followRedirectCount || 0) + 1;
      var location = res.headers.location;
      if (!location) {
        err = new Error('Got statusCode ' + res.statusCode + ' but cannot resolve next location from headers');
        err.name = 'FollowRedirectError';
      } else if (args._followRedirectCount > args.maxRedirects) {
        err = new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + url);
        err.name = 'MaxRedirectError';
      } else {
        var newUrl = args.formatRedirectUrl ? args.formatRedirectUrl(url, location) : urlutil.resolve(url, location);
        debug('Request#%d %s: `redirected` from %s to %s', reqId, options.path, url, newUrl);
        // make sure timer stop
        cancelResponseTimer();
        // should clean up headers.Host on `location: http://other-domain/url`
        if (args.headers && args.headers.Host && PROTO_RE.test(location)) {
          args.headers.Host = null;
        }
        // avoid done will be execute in the future change.
        var cb = callback;
        callback = null;
        exports.requestWithCallback(newUrl, args, cb);
        return {
          redirect: true,
          error: null
        };
      }
    }
    return {
      redirect: false,
      error: err
    };
  }

  // set user-agent
  if (!options.headers['User-Agent'] && !options.headers['user-agent']) {
    options.headers['User-Agent'] = navigator.userAgent;
  }

  if (args.gzip) {
    if (!options.headers['Accept-Encoding'] && !options.headers['accept-encoding']) {
      options.headers['Accept-Encoding'] = 'gzip';
    }
  }

  function decodeContent(res, body, cb) {
    var encoding = res.headers['content-encoding'];
    // if (body.length === 0) {
    //   return cb(null, body, encoding);
    // }

    // if (!encoding || encoding.toLowerCase() !== 'gzip') {
    return cb(null, body, encoding);
    // }

    // debug('gunzip %d length body', body.length);
    // zlib.gunzip(body, cb);
  }

  var writeStream = args.writeStream;

  debug('Request#%d %s %s with headers %j, options.path: %s', reqId, method, url, options.headers, options.path);

  args.requestUrls.push(url);

  function onResponse(res) {
    if (timing) {
      timing.waiting = Date.now() - requestStartTime;
    }
    debug('Request#%d %s `req response` event emit: status %d, headers: %j', reqId, url, res.statusCode, res.headers);

    if (args.streaming) {
      var result = handleRedirect(res);
      if (result.redirect) {
        res.resume();
        return;
      }
      if (result.error) {
        res.resume();
        return done(result.error, null, res);
      }

      return done(null, null, res);
    }

    res.on('close', function () {
      debug('Request#%d %s: `res close` event emit, total size %d', reqId, url, responseSize);
    });

    res.on('error', function () {
      debug('Request#%d %s: `res error` event emit, total size %d', reqId, url, responseSize);
    });

    res.on('aborted', function () {
      responseAborted = true;
      debug('Request#%d %s: `res aborted` event emit, total size %d', reqId, url, responseSize);
    });

    if (writeStream) {
      // If there's a writable stream to recieve the response data, just pipe the
      // response stream to that writable stream and call the callback when it has
      // finished writing.
      //
      // NOTE that when the response stream `res` emits an 'end' event it just
      // means that it has finished piping data to another stream. In the
      // meanwhile that writable stream may still writing data to the disk until
      // it emits a 'close' event.
      //
      // That means that we should not apply callback until the 'close' of the
      // writable stream is emited.
      //
      // See also:
      // - https://github.com/TBEDP/urllib/commit/959ac3365821e0e028c231a5e8efca6af410eabb
      // - http://nodejs.org/api/stream.html#stream_event_end
      // - http://nodejs.org/api/stream.html#stream_event_close_1
      var result = handleRedirect(res);
      if (result.redirect) {
        res.resume();
        return;
      }
      if (result.error) {
        res.resume();
        // end ths stream first
        writeStream.end();
        return done(result.error, null, res);
      }
      // you can set consumeWriteStream false that only wait response end
      if (args.consumeWriteStream === false) {
        res.on('end', done.bind(null, null, null, res));
      } else {
        // node 0.10, 0.12: only emit res aborted, writeStream close not fired
        if (isNode010 || isNode012) {
          first([[writeStream, 'close'], [res, 'aborted']], function (_, stream, event) {
            debug('Request#%d %s: writeStream or res %s event emitted', reqId, url, event);
            done(__err || null, null, res);
          });
        } else {
          writeStream.on('close', function () {
            debug('Request#%d %s: writeStream close event emitted', reqId, url);
            done(__err || null, null, res);
          });
        }
      }
      return res.pipe(writeStream);
    }

    // Otherwise, just concat those buffers.
    //
    // NOTE that the `chunk` is not a String but a Buffer. It means that if
    // you simply concat two chunk with `+` you're actually converting both
    // Buffers into Strings before concating them. It'll cause problems when
    // dealing with multi-byte characters.
    //
    // The solution is to store each chunk in an array and concat them with
    // 'buffer-concat' when all chunks is recieved.
    //
    // See also:
    // http://cnodejs.org/topic/4faf65852e8fb5bc65113403

    var chunks = [];

    res.on('data', function (chunk) {
      debug('Request#%d %s: `res data` event emit, size %d', reqId, url, chunk.length);
      responseSize += chunk.length;
      chunks.push(chunk);
    });

    res.on('end', function () {
      var body = Buffer.concat(chunks, responseSize);
      debug('Request#%d %s: `res end` event emit, total size %d, _dumped: %s', reqId, url, responseSize, res._dumped);

      if (__err) {
        // req.abort() after `res data` event emit.
        return done(__err, body, res);
      }

      var result = handleRedirect(res);
      if (result.error) {
        return done(result.error, body, res);
      }
      if (result.redirect) {
        return;
      }

      decodeContent(res, body, function (err, data, encoding) {
        if (err) {
          return done(err, body, res);
        }
        // if body not decode, dont touch it
        if (!encoding && TEXT_DATA_TYPES.indexOf(args.dataType) >= 0) {
          // try to decode charset
          try {
            data = decodeBodyByCharset(data, res);
          } catch (e) {
            debug('decodeBodyByCharset error: %s', e);
            // if error, dont touch it
            return done(null, data, res);
          }

          if (args.dataType === 'json') {
            if (responseSize === 0) {
              data = null;
            } else {
              var r = parseJSON(data, fixJSONCtlChars);
              if (r.error) {
                err = r.error;
              } else {
                data = r.data;
              }
            }
          }
        }

        if (responseAborted) {
          // err = new Error('Remote socket was terminated before `response.end()` was called');
          // err.name = 'RemoteSocketClosedError';
          debug('Request#%d %s: Remote socket was terminated before `response.end()` was called', reqId, url);
        }

        done(err, data, res);
      });
    });
  }

  var connectTimeout, responseTimeout;
  if (Array.isArray(args.timeout)) {
    connectTimeout = ms(args.timeout[0]);
    responseTimeout = ms(args.timeout[1]);
  } else {
    // set both timeout equal
    connectTimeout = responseTimeout = ms(args.timeout);
  }
  debug('ConnectTimeout: %d, ResponseTimeout: %d', connectTimeout, responseTimeout);

  function startConnectTimer() {
    debug('Connect timer ticking, timeout: %d', connectTimeout);
    connectTimer = setTimeout(function () {
      connectTimer = null;
      if (statusCode === -1) {
        statusCode = -2;
      }
      var msg = 'Connect timeout for ' + connectTimeout + 'ms';
      var errorName = 'ConnectionTimeoutError';
      if (!req.socket) {
        errorName = 'SocketAssignTimeoutError';
        msg += ', working sockets is full';
      }
      __err = new Error(msg);
      __err.name = errorName;
      __err.requestId = reqId;
      debug('ConnectTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);
      abortRequest();
    }, connectTimeout);
  }

  function startResposneTimer() {
    debug('Response timer ticking, timeout: %d', responseTimeout);
    responseTimer = setTimeout(function () {
      responseTimer = null;
      var msg = 'Response timeout for ' + responseTimeout + 'ms';
      var errorName = 'ResponseTimeoutError';
      __err = new Error(msg);
      __err.name = errorName;
      __err.requestId = reqId;
      debug('ResponseTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);
      abortRequest();
    }, responseTimeout);
  }

  var req;
  // request headers checker will throw error
  options.mode = args.mode ? args.mode : '';
  try {
    req = httplib.request(options, onResponse);
  } catch (err) {
    return done(err);
  }

  // environment detection: browser or nodejs
  if (typeof window === 'undefined') {
    // start connect timer just after `request` return, and just in nodejs environment
    startConnectTimer();
  } else {
    req.on('requestTimeout', function () {
      if (statusCode === -1) {
        statusCode = -2;
      }
      var msg = 'Connect timeout for ' + connectTimeout + 'ms';
      var errorName = 'ConnectionTimeoutError';
      __err = new Error(msg);
      __err.name = errorName;
      __err.requestId = reqId;
      abortRequest();
    });
  }

  function abortRequest() {
    debug('Request#%d %s abort, connected: %s', reqId, url, connected);
    // it wont case error event when req haven't been assigned a socket yet.
    if (!req.socket) {
      __err.noSocket = true;
      done(__err);
    }
    req.abort();
  }

  if (timing) {
    // request sent
    req.on('finish', function () {
      timing.requestSent = Date.now() - requestStartTime;
    });
  }

  req.once('socket', function (socket) {
    if (timing) {
      // socket queuing time
      timing.queuing = Date.now() - requestStartTime;
    }

    // https://github.com/nodejs/node/blob/master/lib/net.js#L377
    // https://github.com/nodejs/node/blob/v0.10.40-release/lib/net.js#L352
    // should use socket.socket on 0.10.x
    if (isNode010 && socket.socket) {
      socket = socket.socket;
    }

    var readyState = socket.readyState;
    if (readyState === 'opening') {
      socket.once('lookup', function (err, ip, addressType) {
        debug('Request#%d %s lookup: %s, %s, %s', reqId, url, err, ip, addressType);
        if (timing) {
          timing.dnslookup = Date.now() - requestStartTime;
        }
        if (ip) {
          remoteAddress = ip;
        }
      });
      socket.once('connect', function () {
        if (timing) {
          // socket connected
          timing.connected = Date.now() - requestStartTime;
        }

        // cancel socket timer at first and start tick for TTFB
        cancelConnectTimer();
        startResposneTimer();

        debug('Request#%d %s new socket connected', reqId, url);
        connected = true;
        if (!remoteAddress) {
          remoteAddress = socket.remoteAddress;
        }
        remotePort = socket.remotePort;
      });
      return;
    }

    debug('Request#%d %s reuse socket connected, readyState: %s', reqId, url, readyState);
    connected = true;
    keepAliveSocket = true;
    if (!remoteAddress) {
      remoteAddress = socket.remoteAddress;
    }
    remotePort = socket.remotePort;

    // reuse socket, timer should be canceled.
    cancelConnectTimer();
    startResposneTimer();
  });

  req.on('error', function (err) {
    //TypeError for browser fetch api, Error for browser xmlhttprequest api
    if (err.name === 'Error' || err.name === 'TypeError') {
      err.name = connected ? 'ResponseError' : 'RequestError';
    }
    err.message += ' (req "error")';
    debug('Request#%d %s `req error` event emit, %s: %s', reqId, url, err.name, err.message);
    done(__err || err);
  });

  if (writeStream) {
    writeStream.once('error', function (err) {
      err.message += ' (writeStream "error")';
      __err = err;
      debug('Request#%d %s `writeStream error` event emit, %s: %s', reqId, url, err.name, err.message);
      abortRequest();
    });
  }

  if (args.stream) {
    args.stream.pipe(req);
    args.stream.once('error', function (err) {
      err.message += ' (stream "error")';
      __err = err;
      debug('Request#%d %s `readStream error` event emit, %s: %s', reqId, url, err.name, err.message);
      abortRequest();
    });
  } else {
    req.end(body);
  }

  req.requestId = reqId;
  return req;
};

}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":171,"any-promise":12,"babel-runtime/core-js/json/stringify":16,"babel-runtime/helpers/typeof":31,"buffer":37,"constants":39,"debug":153,"http":194,"https":157,"humanize-ms":158,"url":201,"util":205}]},{},[1])(1)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvYnJvd3Nlci5qcyIsImxpYi9icm93c2VyL2NsaWVudC5qcyIsImxpYi9icm93c2VyL21hbmFnZWQtdXBsb2FkLmpzIiwibGliL2Jyb3dzZXIvb2JqZWN0LmpzIiwibGliL2Jyb3dzZXIvdmVyc2lvbi5qcyIsImxpYi9jb21tb24vY2FsbGJhY2suanMiLCJsaWIvY29tbW9uL211bHRpcGFydC5qcyIsImxpYi9jb21tb24vcGFyYWxsZWwuanMiLCJsaWIvY29tbW9uL3NpZ25VdGlscy5qcyIsImxpYi9jb21tb24vdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYWdlbnRrZWVwYWxpdmUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9hbnktcHJvbWlzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hbnktcHJvbWlzZS9sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvYW55LXByb21pc2UvcmVnaXN0ZXItc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldC1pbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N0cmluZy9mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2hhcy1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ib3dzZXIvc3JjL2Jvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1aWx0aW4tc3RhdHVzLWNvZGVzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY29uc3RhbnRzLWJyb3dzZXJpZnkvY29uc3RhbnRzLmpzb24iLCJub2RlX21vZHVsZXMvY29weS10by9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3NldC1pbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N0cmluZy9mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9oYXMtaW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3BlcmZvcm0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdXNlci1hZ2VudC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRlZm9ybWF0L2xpYi9kYXRlZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJub2RlX21vZHVsZXMvZXNjYXBlLWh0bWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9odHRwcy1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h1bWFuaXplLW1zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtY2xhc3MtaG90Zml4L2lzLWNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL2lzLXR5cGUtb2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc3N0cmVhbS9pc3N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1kZXNjcmlwdG9ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGxhdGZvcm0vcGxhdGZvcm0uanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2F4L2xpYi9zYXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL2NhcGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3JlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3Jlc3BvbnNlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3RvLWFycmF5YnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy94bWwyanMvbGliL2JvbS5qcyIsIm5vZGVfbW9kdWxlcy94bWwyanMvbGliL2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMveG1sMmpzL2xpYi9kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy94bWwyanMvbGliL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy94bWwyanMvbGliL3Byb2Nlc3NvcnMuanMiLCJub2RlX21vZHVsZXMveG1sMmpzL2xpYi94bWwyanMuanMiLCJub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvVXRpbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxBdHRyaWJ1dGUuanMiLCJub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQ0RhdGEuanMiLCJub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQ29tbWVudC5qcyIsIm5vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEVERBdHRMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERUREVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRFRERW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERURE5vdGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERlY2xhcmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERvY1R5cGUuanMiLCJub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRG9jdW1lbnQuanMiLCJub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRG9jdW1lbnRDQi5qcyIsIm5vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxFbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTE5vZGUuanMiLCJub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFJhdy5qcyIsIm5vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxTdHJlYW1Xcml0ZXIuanMiLCJub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MU3RyaW5nV3JpdGVyLmpzIiwibm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFN0cmluZ2lmaWVyLmpzIiwibm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFRleHQuanMiLCJub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MV3JpdGVyQmFzZS5qcyIsIm5vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJzaGltcy9jcnlwdG8vY3J5cHRvLmpzIiwic2hpbXMvY3J5cHRvL2hlbHBlcnMuanMiLCJzaGltcy9jcnlwdG8vbWQ1LmpzIiwic2hpbXMvY3J5cHRvL3NoYS5qcyIsInNoaW1zL2NyeXB0by9zaGEyNTYuanMiLCJzaGltcy9taW1lLmpzIiwic2hpbXMvdXRpbGl0eS5qcyIsInNoaW1zL3hoci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUEsSUFBTSxNQUFNLFFBQVEsa0JBQVIsQ0FBWjtBQUNBLElBQUksTUFBSixHQUFhLFFBQVEsUUFBUixFQUFrQixNQUEvQjtBQUNBLElBQUksTUFBSixH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QUF3QixVQUFVLElBQVYsQ0FBZSxJQUFmLENBQXJDO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FMRDs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BvQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzd2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLE9BQVQsQ0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FBRUEsSUFBSSxNQUFNLFFBQVEsc0JBQVIsQ0FBVjtBQUNBOztBQUVBO0FBQ0EsSUFBSSxhQUFhLGtCQUFlLFVBQVUsR0FBVixFQUFlO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMxa0JBO0FBQ0EsQ0FBQyxZQUFXO0FB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RUFBaUI7QUFDZixTQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEdBQWpCO0FBQ0EsU0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixPQUFqQixFQUEwQixVQUFVLEdBQVYsRUFBZTtBQUN2QyxVQUFJLE9BQUosSUFBZSxtQkFBZjtBQUNBLGNBQVEsR0FBUjtBQUNBLFlBQU0scURBQU4sRUFBNkQsS0FBN0QsRUFBb0UsR0FBcEUsRUFBeUUsSUFBSSxJQUE3RSxFQUFtRixJQUFJLE9BQXZGO0FBQ0E7QUFDRCxLQUxEO0FBTUQsR0FSRCxNQVFPO0FBQ0wsUUFBSSxHQUFKLENBQVEsSUFBUjtBQUNEOztBQUVELE1BQUksU0FBSixHQUFnQixLQUFoQjtBQUNBLFNBQU8sR0FBUDtBQUNELENBM3NCRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImNvbnN0IE9TUyA9IHJlcXVpcmUoJy4vYnJvd3Nlci9jbGllbnQnKTtcbk9TUy5CdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5PU1MudXJsbGliID0gcmVxdWlyZSgnLi4vc2hpbXMveGhyJyk7XG5PU1MudmVyc2lvbiA9IHJlcXVpcmUoJy4vYnJvd3Nlci92ZXJzaW9uJykudmVyc2lvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBPU1M7XG4iLCJcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYWxpLW9zcycpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgY29weSA9IHJlcXVpcmUoJ2NvcHktdG8nKTtcbmNvbnN0IG1pbWUgPSByZXF1aXJlKCdtaW1lJyk7XG5jb25zdCB4bWwgPSByZXF1aXJlKCd4bWwyanMnKTtcbmNvbnN0IG1zID0gcmVxdWlyZSgnaHVtYW5pemUtbXMnKTtcbmNvbnN0IEFnZW50S2VlcGFsaXZlID0gcmVxdWlyZSgnYWdlbnRrZWVwYWxpdmUnKTtcbmNvbnN0IG1lcmdlID0gcmVxdWlyZSgnbWVyZ2UtZGVzY3JpcHRvcnMnKTtcbmNvbnN0IHVybHV0aWwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IGlzID0gcmVxdWlyZSgnaXMtdHlwZS1vZicpO1xuY29uc3QgcGxhdGZvcm0gPSByZXF1aXJlKCdwbGF0Zm9ybScpO1xuY29uc3QgdXRpbGl0eSA9IHJlcXVpcmUoJ3V0aWxpdHknKTtcbmNvbnN0IHVybGxpYiA9IHJlcXVpcmUoJ3VybGxpYicpO1xuY29uc3QgcGtnID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5jb25zdCBkYXRlRm9ybWF0ID0gcmVxdWlyZSgnZGF0ZWZvcm1hdCcpO1xuY29uc3QgYm93c2VyID0gcmVxdWlyZSgnYm93c2VyJyk7XG5jb25zdCBzaWduVXRpbHMgPSByZXF1aXJlKCcuLi9jb21tb24vc2lnblV0aWxzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpO1xuXG5jb25zdCBnbG9iYWxIdHRwQWdlbnQgPSBuZXcgQWdlbnRLZWVwYWxpdmUoKTtcblxuZnVuY3Rpb24gZ2V0SGVhZGVyKGhlYWRlcnMsIG5hbWUpIHtcbiAgcmV0dXJuIGhlYWRlcnNbbmFtZV0gfHwgaGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiBzZXRFbmRwb2ludChlbmRwb2ludCwgc2VjdXJlKSB7XG4gIGxldCB1cmwgPSB1cmx1dGlsLnBhcnNlKGVuZHBvaW50KTtcblxuICBpZiAoIXVybC5wcm90b2NvbCkge1xuICAgIGNvbnN0IHByb3RvY29sID0gc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbiAgICB1cmwgPSB1cmx1dGlsLnBhcnNlKHByb3RvY29sICsgZW5kcG9pbnQpO1xuICB9XG5cbiAgaWYgKHVybC5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiB1cmwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmRwb2ludCBwcm90b2NvbCBtdXN0IGJlIGh0dHAgb3IgaHR0cHMuJyk7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBzZXRSZWdpb24ocmVnaW9uLCBpbnRlcm5hbCwgc2VjdXJlKSB7XG4gIGNvbnN0IHByb3RvY29sID0gc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbiAgbGV0IHN1ZmZpeCA9IGludGVybmFsID8gJy1pbnRlcm5hbC5hbGl5dW5jcy5jb20nIDogJy5hbGl5dW5jcy5jb20nO1xuICBjb25zdCBwcmVmaXggPSAndnBjMTAwLW9zcy1jbi0nO1xuICAvLyBhbGl5dW4gVlBDIHJlZ2lvbjogaHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20va25vd2xlZGdlX2RldGFpbC8zODc0MC5odG1sXG4gIGlmIChyZWdpb24uc3Vic3RyKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXgpIHtcbiAgICBzdWZmaXggPSAnLmFsaXl1bmNzLmNvbSc7XG4gIH1cblxuICByZXR1cm4gdXJsdXRpbC5wYXJzZShwcm90b2NvbCArIHJlZ2lvbiArIHN1ZmZpeCk7XG59XG5cbi8vIGNoZWNrIGxvY2FsIHdlYiBwcm90b2NvbCxpZiBodHRwcyBzZWN1cmUgZGVmYXVsdCBzZXQgdHJ1ZSAsIGlmIGh0dHAgc2VjdXJlIGRlZmF1bHQgc2V0IGZhbHNlXG5mdW5jdGlvbiBpc0h0dHBzV2ViUHJvdG9jb2woKSB7XG4gIHJldHVybiBkb2N1bWVudCAmJiBkb2N1bWVudC5sb2NhdGlvbiAmJiBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG59XG5cbmZ1bmN0aW9uIENsaWVudChvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENsaWVudCkpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudChvcHRpb25zLCBjdHgpO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW5pdGVkKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBDbGllbnQuaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLm9wdGlvbnMuY2FuY2VsRmxhZyA9IGZhbHNlOy8vIGNhbmNlbCBmbGFnOiBpZiB0cnVlIG5lZWQgdG8gYmUgY2FuY2VsbGVkLCBkZWZhdWx0IGZhbHNlXG5cbiAgLy8gc3VwcG9ydCBjdXN0b20gYWdlbnQgYW5kIHVybGxpYiBjbGllbnRcbiAgaWYgKHRoaXMub3B0aW9ucy51cmxsaWIpIHtcbiAgICB0aGlzLnVybGxpYiA9IHRoaXMub3B0aW9ucy51cmxsaWI7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cmxsaWIgPSB1cmxsaWI7XG4gICAgdGhpcy5hZ2VudCA9IHRoaXMub3B0aW9ucy5hZ2VudCB8fCBnbG9iYWxIdHRwQWdlbnQ7XG4gIH1cbiAgdGhpcy5jdHggPSBjdHg7XG4gIHRoaXMudXNlckFnZW50ID0gdGhpcy5fZ2V0VXNlckFnZW50KCk7XG5cbiAgLy8gcmVjb3JkIHRoZSB0aW1lIGRpZmZlcmVuY2UgYmV0d2VlbiBjbGllbnQgYW5kIHNlcnZlclxuICB0aGlzLm9wdGlvbnMuYW1lbmRUaW1lU2tld2VkID0gMDtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYENsaWVudGBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudDtcblxuQ2xpZW50LmluaXRPcHRpb25zID0gZnVuY3Rpb24gaW5pdE9wdGlvbnMob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnNcbiAgICB8fCAhb3B0aW9ucy5hY2Nlc3NLZXlJZFxuICAgIHx8ICFvcHRpb25zLmFjY2Vzc0tleVNlY3JldCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZSBhY2Nlc3NLZXlJZCwgYWNjZXNzS2V5U2VjcmV0Jyk7XG4gIH1cblxuICBjb25zdCBpc0h0dHBzUHJvdG9jb2wgPSBpc0h0dHBzV2ViUHJvdG9jb2woKTtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICByZWdpb246ICdvc3MtY24taGFuZ3pob3UnLFxuICAgIGludGVybmFsOiBmYWxzZSxcbiAgICBzZWN1cmU6IGlzSHR0cHNQcm90b2NvbCxcbiAgICBidWNrZXQ6IG51bGwsXG4gICAgZW5kcG9pbnQ6IG51bGwsXG4gICAgY25hbWU6IGZhbHNlLFxuICAgIGlzUmVxdWVzdFBheTogZmFsc2UsXG4gICAgdXNlRmV0Y2g6IHRydWVcbiAgfTtcblxuICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAob3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdHNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG4gIH0pO1xuICBvcHRzLmFjY2Vzc0tleUlkID0gb3B0cy5hY2Nlc3NLZXlJZC50cmltKCk7XG4gIG9wdHMuYWNjZXNzS2V5U2VjcmV0ID0gb3B0cy5hY2Nlc3NLZXlTZWNyZXQudHJpbSgpO1xuXG4gIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICBvcHRzLnRpbWVvdXQgPSBtcyhvcHRzLnRpbWVvdXQpO1xuICB9XG5cbiAgaWYgKG9wdHMuZW5kcG9pbnQpIHtcbiAgICBvcHRzLmVuZHBvaW50ID0gc2V0RW5kcG9pbnQob3B0cy5lbmRwb2ludCwgb3B0cy5zZWN1cmUpO1xuICB9IGVsc2UgaWYgKG9wdHMucmVnaW9uKSB7XG4gICAgb3B0cy5lbmRwb2ludCA9IHNldFJlZ2lvbihvcHRzLnJlZ2lvbiwgb3B0cy5pbnRlcm5hbCwgb3B0cy5zZWN1cmUpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZSBvcHRpb25zLmVuZHBvaW50IG9yIG9wdGlvbnMucmVnaW9uJyk7XG4gIH1cblxuICBvcHRzLmluaXRlZCA9IHRydWU7XG4gIHJldHVybiBvcHRzO1xufTtcblxuXG4vKipcbiAqIHByb3RvdHlwZVxuICovXG5cbmNvbnN0IHByb3RvID0gQ2xpZW50LnByb3RvdHlwZTtcblxuLy8gbW91bnQgZGVidWcgb24gcHJvdG9cbnByb3RvLmRlYnVnID0gZGVidWc7XG5cbi8qKlxuICogT2JqZWN0IG9wZXJhdGlvbnNcbiAqL1xubWVyZ2UocHJvdG8sIHJlcXVpcmUoJy4vb2JqZWN0JykpO1xuLy8gLyoqXG4vLyAgKiBCdWNrZXQgb3BlcmF0aW9uc1xuLy8gICovXG4vLyBtZXJnZShwcm90bywgcmVxdWlyZSgnLi9idWNrZXQnKSk7XG4vLyBtdWx0aXBhcnQgdXBsb2FkXG5tZXJnZShwcm90bywgcmVxdWlyZSgnLi9tYW5hZ2VkLXVwbG9hZCcpKTtcbi8qKlxuICogTXVsdGlwYXJ0IG9wZXJhdGlvbnNcbiAqL1xubWVyZ2UocHJvdG8sIHJlcXVpcmUoJy4uL2NvbW1vbi9tdWx0aXBhcnQnKSk7XG5cbi8qKlxuICogQ29tbW9uIG1vZHVsZSBwYXJhbGxlbFxuICovXG5tZXJnZShwcm90bywgcmVxdWlyZSgnLi4vY29tbW9uL3BhcmFsbGVsJykpO1xuXG4vKipcbiAqIGdldCBPU1Mgc2lnbmF0dXJlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nVG9TaWduXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBzaWduYXR1cmVcbiAqL1xucHJvdG8uc2lnbmF0dXJlID0gZnVuY3Rpb24gc2lnbmF0dXJlKHN0cmluZ1RvU2lnbikge1xuICB0aGlzLmRlYnVnKCdhdXRob3JpemF0aW9uIHN0cmluZ1RvU2lnbjogJXMnLCBzdHJpbmdUb1NpZ24sICdpbmZvJyk7XG5cbiAgcmV0dXJuIHNpZ25VdGlscy5jb21wdXRlU2lnbmF0dXJlKHRoaXMub3B0aW9ucy5hY2Nlc3NLZXlTZWNyZXQsIHN0cmluZ1RvU2lnbik7XG59O1xuXG4vKipcbiAqIGdldCBhdXRob3IgaGVhZGVyXG4gKlxuICogXCJBdXRob3JpemF0aW9uOiBPU1MgXCIgKyBBY2Nlc3MgS2V5IElkICsgXCI6XCIgKyBTaWduYXR1cmVcbiAqXG4gKiBTaWduYXR1cmUgPSBiYXNlNjQoaG1hYy1zaGExKEFjY2VzcyBLZXkgU2VjcmV0ICsgXCJcXG5cIlxuICogICsgVkVSQiArIFwiXFxuXCJcbiAqICArIENPTlRFTlQtTUQ1ICsgXCJcXG5cIlxuICogICsgQ09OVEVOVC1UWVBFICsgXCJcXG5cIlxuICogICsgREFURSArIFwiXFxuXCJcbiAqICArIENhbm9uaWNhbGl6ZWRPU1NIZWFkZXJzXG4gKiAgKyBDYW5vbmljYWxpemVkUmVzb3VyY2UpKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7U3RyaW5nfVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnByb3RvLmF1dGhvcml6YXRpb24gPSBmdW5jdGlvbiBhdXRob3JpemF0aW9uKG1ldGhvZCwgcmVzb3VyY2UsIHN1YnJlcywgaGVhZGVycykge1xuICBjb25zdCBzdHJpbmdUb1NpZ24gPSBzaWduVXRpbHMuYnVpbGRDYW5vbmljYWxTdHJpbmcobWV0aG9kLnRvVXBwZXJDYXNlKCksIHJlc291cmNlLCB7XG4gICAgaGVhZGVycyxcbiAgICBwYXJhbWV0ZXJzOiBzdWJyZXNcbiAgfSk7XG5cbiAgcmV0dXJuIHNpZ25VdGlscy5hdXRob3JpemF0aW9uKHRoaXMub3B0aW9ucy5hY2Nlc3NLZXlJZCwgdGhpcy5vcHRpb25zLmFjY2Vzc0tleVNlY3JldCwgc3RyaW5nVG9TaWduKTtcbn07XG5cbi8qKlxuICogY3JlYXRlIHJlcXVlc3QgcGFyYW1zXG4gKiBTZWUgYHJlcXVlc3RgXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5wcm90by5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChwYXJhbXMpIHtcbiAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAneC1vc3MtZGF0ZSc6IGRhdGVGb3JtYXQoK25ldyBEYXRlKCkgKyB0aGlzLm9wdGlvbnMuYW1lbmRUaW1lU2tld2VkLCAnVVRDOmRkZCwgZGQgbW1tIHl5eXkgSEg6TU06c3MgXFwnR01UXFwnJyksXG4gICAgJ3gtb3NzLXVzZXItYWdlbnQnOiB0aGlzLnVzZXJBZ2VudFxuICB9O1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuaXNSZXF1ZXN0UGF5KSB7XG4gICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCB7ICd4LW9zcy1yZXF1ZXN0LXBheWVyJzogJ3JlcXVlc3RlcicgfSk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnN0c1Rva2VuKSB7XG4gICAgaGVhZGVyc1sneC1vc3Mtc2VjdXJpdHktdG9rZW4nXSA9IHRoaXMub3B0aW9ucy5zdHNUb2tlbjtcbiAgfVxuXG4gIGNvcHkocGFyYW1zLmhlYWRlcnMpLnRvKGhlYWRlcnMpO1xuXG4gIGlmICghZ2V0SGVhZGVyKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKSkge1xuICAgIGlmIChwYXJhbXMubWltZSA9PT0gbWltZS5kZWZhdWx0X3R5cGUpIHtcbiAgICAgIHBhcmFtcy5taW1lID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5taW1lICYmIHBhcmFtcy5taW1lLmluZGV4T2YoJy8nKSA+IDApIHtcbiAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gcGFyYW1zLm1pbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gbWltZS5nZXRUeXBlKHBhcmFtcy5taW1lIHx8IHBhdGguZXh0bmFtZShwYXJhbXMub2JqZWN0IHx8ICcnKSkgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcmFtcy5jb250ZW50KSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1NZDUnXSA9IGNyeXB0b1xuICAgICAgLmNyZWF0ZUhhc2goJ21kNScpXG4gICAgICAudXBkYXRlKG5ldyBCdWZmZXIocGFyYW1zLmNvbnRlbnQsICd1dGY4JykpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcbiAgICBpZiAoIWhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10pIHtcbiAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBwYXJhbXMuY29udGVudC5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYXV0aFJlc291cmNlID0gdGhpcy5fZ2V0UmVzb3VyY2UocGFyYW1zKTtcbiAgaGVhZGVycy5hdXRob3JpemF0aW9uID0gdGhpcy5hdXRob3JpemF0aW9uKHBhcmFtcy5tZXRob2QsIGF1dGhSZXNvdXJjZSwgcGFyYW1zLnN1YnJlcywgaGVhZGVycyk7XG5cbiAgY29uc3QgdXJsID0gdGhpcy5fZ2V0UmVxVXJsKHBhcmFtcyk7XG4gIHRoaXMuZGVidWcoJ3JlcXVlc3QgJXMgJXMsIHdpdGggaGVhZGVycyAlaiwgISFzdHJlYW06ICVzJywgcGFyYW1zLm1ldGhvZCwgdXJsLCBoZWFkZXJzLCAhIXBhcmFtcy5zdHJlYW0sICdpbmZvJyk7XG4gIGNvbnN0IHRpbWVvdXQgPSBwYXJhbXMudGltZW91dCB8fCB0aGlzLm9wdGlvbnMudGltZW91dDtcbiAgY29uc3QgcmVxUGFyYW1zID0ge1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIG1ldGhvZDogcGFyYW1zLm1ldGhvZCxcbiAgICBjb250ZW50OiBwYXJhbXMuY29udGVudCxcbiAgICBzdHJlYW06IHBhcmFtcy5zdHJlYW0sXG4gICAgaGVhZGVycyxcbiAgICB0aW1lb3V0LFxuICAgIHdyaXRlU3RyZWFtOiBwYXJhbXMud3JpdGVTdHJlYW0sXG4gICAgY3VzdG9tUmVzcG9uc2U6IHBhcmFtcy5jdXN0b21SZXNwb25zZSxcbiAgICBjdHg6IHBhcmFtcy5jdHggfHwgdGhpcy5jdHhcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHVybCxcbiAgICBwYXJhbXM6IHJlcVBhcmFtc1xuICB9O1xufTtcblxuLyoqXG4gKiByZXF1ZXN0IG9zcyBzZXJ2ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqICAgLSB7U3RyaW5nfSBvYmplY3RcbiAqICAgLSB7U3RyaW5nfSBidWNrZXRcbiAqICAgLSB7T2JqZWN0fSBbaGVhZGVyc11cbiAqICAgLSB7T2JqZWN0fSBbcXVlcnldXG4gKiAgIC0ge0J1ZmZlcn0gW2NvbnRlbnRdXG4gKiAgIC0ge1N0cmVhbX0gW3N0cmVhbV1cbiAqICAgLSB7U3RyZWFtfSBbd3JpdGVTdHJlYW1dXG4gKiAgIC0ge1N0cmluZ30gW21pbWVdXG4gKiAgIC0ge0Jvb2xlYW59IFt4bWxSZXNwb25zZV1cbiAqICAgLSB7Qm9vbGVhbn0gW2N1c3RvbVJlc3BvbnNlXVxuICogICAtIHtOdW1iZXJ9IFt0aW1lb3V0XVxuICogICAtIHtPYmplY3R9IFtjdHhdIHJlcXVlc3QgY29udGV4dCwgZGVmYXVsdCBpcyBgdGhpcy5jdHhgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxucHJvdG8ucmVxdWVzdCA9IGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3QocGFyYW1zKSB7XG4gIGNvbnN0IHJlcVBhcmFtcyA9IHRoaXMuY3JlYXRlUmVxdWVzdChwYXJhbXMpO1xuXG4gIGlmICghdGhpcy5vcHRpb25zLnVzZUZldGNoKSB7XG4gICAgcmVxUGFyYW1zLnBhcmFtcy5tb2RlID0gJ2Rpc2FibGUtZmV0Y2gnO1xuICB9XG4gIGxldCByZXN1bHQ7XG4gIGxldCByZXFFcnI7XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgdGhpcy51cmxsaWIucmVxdWVzdChyZXFQYXJhbXMudXJsLCByZXFQYXJhbXMucGFyYW1zKTtcbiAgICB0aGlzLmRlYnVnKCdyZXNwb25zZSAlcyAlcywgZ290ICVzLCBoZWFkZXJzOiAlaicsIHBhcmFtcy5tZXRob2QsIHJlcVBhcmFtcy51cmwsIHJlc3VsdC5zdGF0dXMsIHJlc3VsdC5oZWFkZXJzLCAnaW5mbycpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXFFcnIgPSBlcnI7XG4gIH1cbiAgbGV0IGVycjtcbiAgaWYgKHJlc3VsdCAmJiBwYXJhbXMuc3VjY2Vzc1N0YXR1c2VzICYmIHBhcmFtcy5zdWNjZXNzU3RhdHVzZXMuaW5kZXhPZihyZXN1bHQuc3RhdHVzKSA9PT0gLTEpIHtcbiAgICBlcnIgPSBhd2FpdCB0aGlzLnJlcXVlc3RFcnJvcihyZXN1bHQpO1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ1JlcXVlc3RUaW1lVG9vU2tld2VkJykge1xuICAgICAgdGhpcy5vcHRpb25zLmFtZW5kVGltZVNrZXdlZCA9ICtuZXcgRGF0ZShlcnIuc2VydmVyVGltZSkgLSBuZXcgRGF0ZSgpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdChwYXJhbXMpO1xuICAgIH1cbiAgICBlcnIucGFyYW1zID0gcGFyYW1zO1xuICB9IGVsc2UgaWYgKHJlcUVycikge1xuICAgIGVyciA9IGF3YWl0IHRoaXMucmVxdWVzdEVycm9yKHJlcUVycik7XG4gIH1cblxuICBpZiAoZXJyKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgaWYgKHBhcmFtcy54bWxSZXNwb25zZSkge1xuICAgIGNvbnN0IHBhcnNlRGF0YSA9IGF3YWl0IHRoaXMucGFyc2VYTUwocmVzdWx0LmRhdGEpO1xuICAgIHJlc3VsdC5kYXRhID0gcGFyc2VEYXRhO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5wcm90by5fZ2V0UmVzb3VyY2UgPSBmdW5jdGlvbiBfZ2V0UmVzb3VyY2UocGFyYW1zKSB7XG4gIGxldCByZXNvdXJjZSA9ICcvJztcbiAgaWYgKHBhcmFtcy5idWNrZXQpIHJlc291cmNlICs9IGAke3BhcmFtcy5idWNrZXR9L2A7XG4gIGlmIChwYXJhbXMub2JqZWN0KSByZXNvdXJjZSArPSBwYXJhbXMub2JqZWN0O1xuXG4gIHJldHVybiByZXNvdXJjZTtcbn07XG5cbnByb3RvLl9pc0lQID0gZnVuY3Rpb24gX2lzSVAoaG9zdCkge1xuICByZXR1cm4gdXRpbHMuX2lzSVAoaG9zdCk7XG59O1xuXG5wcm90by5fZXNjYXBlID0gZnVuY3Rpb24gX2VzY2FwZShuYW1lKSB7XG4gIHJldHVybiB1dGlsaXR5LmVuY29kZVVSSUNvbXBvbmVudChuYW1lKS5yZXBsYWNlKC8lMkYvZywgJy8nKTtcbn07XG5cbnByb3RvLl9nZXRSZXFVcmwgPSBmdW5jdGlvbiBfZ2V0UmVxVXJsKHBhcmFtcykge1xuICBjb25zdCBlcCA9IHt9O1xuICBjb3B5KHRoaXMub3B0aW9ucy5lbmRwb2ludCkudG8oZXApO1xuICBjb25zdCBpc0lQID0gdGhpcy5faXNJUChlcC5ob3N0bmFtZSk7XG4gIGNvbnN0IGlzQ25hbWUgPSB0aGlzLm9wdGlvbnMuY25hbWU7XG4gIGlmIChwYXJhbXMuYnVja2V0ICYmICFpc0NuYW1lICYmICFpc0lQKSB7XG4gICAgZXAuaG9zdCA9IGAke3BhcmFtcy5idWNrZXR9LiR7ZXAuaG9zdH1gO1xuICB9XG5cbiAgbGV0IHJlb3VyY2VQYXRoID0gJy8nO1xuICBpZiAocGFyYW1zLmJ1Y2tldCAmJiBpc0lQKSB7XG4gICAgcmVvdXJjZVBhdGggKz0gYCR7cGFyYW1zLmJ1Y2tldH0vYDtcbiAgfVxuXG4gIGlmIChwYXJhbXMub2JqZWN0KSB7XG4gICAgLy8gUHJlc2VydmUgJy8nIGluIHJlc3VsdCB1cmxcbiAgICByZW91cmNlUGF0aCArPSB0aGlzLl9lc2NhcGUocGFyYW1zLm9iamVjdCkucmVwbGFjZSgvXFwrL2csICclMkInKTtcbiAgfVxuICBlcC5wYXRobmFtZSA9IHJlb3VyY2VQYXRoO1xuXG4gIGNvbnN0IHF1ZXJ5ID0ge307XG4gIGlmIChwYXJhbXMucXVlcnkpIHtcbiAgICBtZXJnZShxdWVyeSwgcGFyYW1zLnF1ZXJ5KTtcbiAgfVxuXG4gIGlmIChwYXJhbXMuc3VicmVzKSB7XG4gICAgbGV0IHN1YnJlc0FzUXVlcnkgPSB7fTtcbiAgICBpZiAoaXMuc3RyaW5nKHBhcmFtcy5zdWJyZXMpKSB7XG4gICAgICBzdWJyZXNBc1F1ZXJ5W3BhcmFtcy5zdWJyZXNdID0gJyc7XG4gICAgfSBlbHNlIGlmIChpcy5hcnJheShwYXJhbXMuc3VicmVzKSkge1xuICAgICAgcGFyYW1zLnN1YnJlcy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgIHN1YnJlc0FzUXVlcnlba10gPSAnJztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJyZXNBc1F1ZXJ5ID0gcGFyYW1zLnN1YnJlcztcbiAgICB9XG4gICAgbWVyZ2UocXVlcnksIHN1YnJlc0FzUXVlcnkpO1xuICB9XG5cbiAgZXAucXVlcnkgPSBxdWVyeTtcblxuICByZXR1cm4gdXJsdXRpbC5mb3JtYXQoZXApO1xufTtcblxuLypcbiAqIEdldCBVc2VyLUFnZW50IGZvciBicm93c2VyICYgbm9kZS5qc1xuICogQGV4YW1wbGVcbiAqICAgYWxpeXVuLXNkay1ub2RlanMvNC4xLjIgTm9kZS5qcyA1LjMuMCBvbiBEYXJ3aW4gNjQtYml0XG4gKiAgIGFsaXl1bi1zZGstanMvNC4xLjIgU2FmYXJpIDkuMCBvbiBBcHBsZSBpUGhvbmUoaU9TIDkuMi4xKVxuICogICBhbGl5dW4tc2RrLWpzLzQuMS4yIENocm9tZSA0My4wLjIzNTcuMTM0IDMyLWJpdCBvbiBXaW5kb3dzIFNlcnZlciAyMDA4IFIyIC8gNyA2NC1iaXRcbiAqL1xuXG5wcm90by5fZ2V0VXNlckFnZW50ID0gZnVuY3Rpb24gX2dldFVzZXJBZ2VudCgpIHtcbiAgY29uc3QgYWdlbnQgPSAocHJvY2VzcyAmJiBwcm9jZXNzLmJyb3dzZXIpID8gJ2pzJyA6ICdub2RlanMnO1xuICBjb25zdCBzZGsgPSBgYWxpeXVuLXNkay0ke2FnZW50fS8ke3BrZy52ZXJzaW9ufWA7XG4gIGxldCBwbGF0ID0gcGxhdGZvcm0uZGVzY3JpcHRpb247XG4gIGlmICghcGxhdCAmJiBwcm9jZXNzKSB7XG4gICAgcGxhdCA9IGBOb2RlLmpzICR7cHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpfSBvbiAke3Byb2Nlc3MucGxhdGZvcm19ICR7cHJvY2Vzcy5hcmNofWA7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fY2hlY2tVc2VyQWdlbnQoYCR7c2RrfSAke3BsYXR9YCk7XG59O1xuXG5wcm90by5fY2hlY2tVc2VyQWdlbnQgPSBmdW5jdGlvbiBfY2hlY2tVc2VyQWdlbnQodWEpIHtcbiAgY29uc3QgdXNlckFnZW50ID0gdWEucmVwbGFjZSgvXFx1MDNiMS8sICdhbHBoYScpLnJlcGxhY2UoL1xcdTAzYjIvLCAnYmV0YScpO1xuICByZXR1cm4gdXNlckFnZW50O1xufTtcblxuLypcbiAqIENoZWNrIEJyb3dzZXIgQW5kIFZlcnNpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gYnJvd3NlciBuYW1lOiBsaWtlIElFLCBDaHJvbWUsIEZpcmVmb3hcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdmVyc2lvbl0gYnJvd3NlciBtYWpvciB2ZXJzaW9uOiBsaWtlIDEwKElFIDEwLngpLCA1NShDaHJvbWUgNTUueCksIDUwKEZpcmVmb3ggNTAueClcbiAqIEByZXR1cm4ge0Jvb2x9IHRydWUgb3IgZmFsc2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnByb3RvLmNoZWNrQnJvd3NlckFuZFZlcnNpb24gPSBmdW5jdGlvbiBjaGVja0Jyb3dzZXJBbmRWZXJzaW9uKG5hbWUsIHZlcnNpb24pIHtcbiAgcmV0dXJuICgoYm93c2VyLm5hbWUgPT09IG5hbWUpICYmIChib3dzZXIudmVyc2lvbi5zcGxpdCgnLicpWzBdID09PSB2ZXJzaW9uKSk7XG59O1xuXG4vKipcbiAqIHRodW5raWZ5IHhtbC5wYXJzZVN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBzdHJcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5wcm90by5wYXJzZVhNTCA9IGZ1bmN0aW9uIHBhcnNlWE1MVGh1bmsoc3RyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHIpKSB7XG4gICAgICBzdHIgPSBzdHIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgeG1sLnBhcnNlU3RyaW5nKHN0ciwge1xuICAgICAgZXhwbGljaXRSb290OiBmYWxzZSxcbiAgICAgIGV4cGxpY2l0QXJyYXk6IGZhbHNlXG4gICAgfSwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogZ2VuZXJhdGVyIGEgcmVxdWVzdCBlcnJvciB3aXRoIHJlcXVlc3QgcmVzcG9uc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5wcm90by5yZXF1ZXN0RXJyb3IgPSBhc3luYyBmdW5jdGlvbiByZXF1ZXN0RXJyb3IocmVzdWx0KSB7XG4gIGxldCBlcnIgPSBudWxsO1xuICBpZiAoIXJlc3VsdC5kYXRhIHx8ICFyZXN1bHQuZGF0YS5sZW5ndGgpIHtcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gLTEgfHwgcmVzdWx0LnN0YXR1cyA9PT0gLTIpIHsgLy8gLTEgaXMgbmV0IGVycm9yICwgLTIgaXMgdGltZW91dFxuICAgICAgZXJyID0gbmV3IEVycm9yKHJlc3VsdC5tZXNzYWdlKTtcbiAgICAgIGVyci5uYW1lID0gcmVzdWx0Lm5hbWU7XG4gICAgICBlcnIuc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcbiAgICAgIGVyci5jb2RlID0gcmVzdWx0Lm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhFQUQgbm90IGV4aXN0cyByZXNvdXJjZVxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoJ09iamVjdCBub3QgZXhpc3RzJyk7XG4gICAgICAgIGVyci5uYW1lID0gJ05vU3VjaEtleUVycm9yJztcbiAgICAgICAgZXJyLnN0YXR1cyA9IDQwNDtcbiAgICAgICAgZXJyLmNvZGUgPSAnTm9TdWNoS2V5JztcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnN0YXR1cyA9PT0gNDEyKSB7XG4gICAgICAgIGVyciA9IG5ldyBFcnJvcignUHJlIGNvbmRpdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgZXJyLm5hbWUgPSAnUHJlY29uZGl0aW9uRmFpbGVkRXJyb3InO1xuICAgICAgICBlcnIuc3RhdHVzID0gNDEyO1xuICAgICAgICBlcnIuY29kZSA9ICdQcmVjb25kaXRpb25GYWlsZWQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyID0gbmV3IEVycm9yKGBVbmtub3cgZXJyb3IsIHN0YXR1czogJHtyZXN1bHQuc3RhdHVzfWApO1xuICAgICAgICBlcnIubmFtZSA9ICdVbmtub3dFcnJvcic7XG4gICAgICAgIGVyci5zdGF0dXMgPSByZXN1bHQuc3RhdHVzO1xuICAgICAgfVxuICAgICAgZXJyLnJlcXVlc3RJZCA9IHJlc3VsdC5oZWFkZXJzWyd4LW9zcy1yZXF1ZXN0LWlkJ107XG4gICAgICBlcnIuaG9zdCA9ICcnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtZXNzYWdlID0gU3RyaW5nKHJlc3VsdC5kYXRhKTtcbiAgICB0aGlzLmRlYnVnKCdyZXF1ZXN0IHJlc3BvbnNlIGVycm9yIGRhdGE6ICVzJywgbWVzc2FnZSwgJ2Vycm9yJyk7XG5cbiAgICBsZXQgaW5mbztcbiAgICB0cnkge1xuICAgICAgaW5mbyA9IGF3YWl0IHRoaXMucGFyc2VYTUwobWVzc2FnZSkgfHwge307XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZGVidWcobWVzc2FnZSwgJ2Vycm9yJyk7XG4gICAgICBlcnJvci5tZXNzYWdlICs9IGBcXG5yYXcgeG1sOiAke21lc3NhZ2V9YDtcbiAgICAgIGVycm9yLnN0YXR1cyA9IHJlc3VsdC5zdGF0dXM7XG4gICAgICBlcnJvci5yZXF1ZXN0SWQgPSByZXN1bHQuaGVhZGVyc1sneC1vc3MtcmVxdWVzdC1pZCddO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIGxldCBtc2cgPSBpbmZvLk1lc3NhZ2UgfHwgKGB1bmtub3cgcmVxdWVzdCBlcnJvciwgc3RhdHVzOiAke3Jlc3VsdC5zdGF0dXN9YCk7XG4gICAgaWYgKGluZm8uQ29uZGl0aW9uKSB7XG4gICAgICBtc2cgKz0gYCAoY29uZGl0aW9uOiAke2luZm8uQ29uZGl0aW9ufSlgO1xuICAgIH1cbiAgICBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICBlcnIubmFtZSA9IGluZm8uQ29kZSA/IGAke2luZm8uQ29kZX1FcnJvcmAgOiAnVW5rbm93RXJyb3InO1xuICAgIGVyci5zdGF0dXMgPSByZXN1bHQuc3RhdHVzO1xuICAgIGVyci5jb2RlID0gaW5mby5Db2RlO1xuICAgIGVyci5yZXF1ZXN0SWQgPSBpbmZvLlJlcXVlc3RJZDtcbiAgICBlcnIuaG9zdElkID0gaW5mby5Ib3N0SWQ7XG4gICAgZXJyLnNlcnZlclRpbWUgPSBpbmZvLlNlcnZlclRpbWU7XG4gIH1cblxuICB0aGlzLmRlYnVnKCdnZW5lcmF0ZSBlcnJvciAlaicsIGVyciwgJ2Vycm9yJyk7XG4gIHJldHVybiBlcnI7XG59O1xuXG4iLCJcblxuLy8gdmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnYWxpLW9zczptdWx0aXBhcnQnKTtcbmNvbnN0IGlzID0gcmVxdWlyZSgnaXMtdHlwZS1vZicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBtaW1lID0gcmVxdWlyZSgnbWltZScpO1xuY29uc3QgY29weSA9IHJlcXVpcmUoJ2NvcHktdG8nKTtcblxuY29uc3QgcHJvdG8gPSBleHBvcnRzO1xuXG4vKipcbiAqIE11bHRpcGFydCBvcGVyYXRpb25zXG4gKi9cblxuLyoqXG4gKiBVcGxvYWQgYSBmaWxlIHRvIE9TUyB1c2luZyBtdWx0aXBhcnQgdXBsb2Fkc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAge09iamVjdH0gb3B0aW9ucy5jYWxsYmFjayBUaGUgY2FsbGJhY2sgcGFyYW1ldGVyIGlzIGNvbXBvc2VkIG9mIGEgSlNPTiBzdHJpbmcgZW5jb2RlZCBpbiBCYXNlNjRcbiAqICAgICAgICB7U3RyaW5nfSBvcHRpb25zLmNhbGxiYWNrLnVybCB0aGUgT1NTIHNlbmRzIGEgY2FsbGJhY2sgcmVxdWVzdCB0byB0aGlzIFVSTFxuICogICAgICAgIHtTdHJpbmd9IG9wdGlvbnMuY2FsbGJhY2suaG9zdCBUaGUgaG9zdCBoZWFkZXIgdmFsdWUgZm9yIGluaXRpYXRpbmcgY2FsbGJhY2sgcmVxdWVzdHNcbiAqICAgICAgICB7U3RyaW5nfSBvcHRpb25zLmNhbGxiYWNrLmJvZHkgVGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN0IGJvZHkgd2hlbiBhIGNhbGxiYWNrIGlzIGluaXRpYXRlZFxuICogICAgICAgIHtTdHJpbmd9IG9wdGlvbnMuY2FsbGJhY2suY29udGVudFR5cGUgVGhlIENvbnRlbnQtVHlwZSBvZiB0aGUgY2FsbGJhY2sgcmVxdWVzdHMgaW5pdGlhdGlhdGVkXG4gKiAgICAgICAge09iamVjdH0gb3B0aW9ucy5jYWxsYmFjay5jdXN0b21WYWx1ZSBDdXN0b20gcGFyYW1ldGVycyBhcmUgYSBtYXAgb2Yga2V5LXZhbHVlcywgZS5nOlxuICogICAgICAgICAgICAgICAgICBjdXN0b21WYWx1ZSA9IHtcbiAqICAgICAgICAgICAgICAgICAgICBrZXkxOiAndmFsdWUxJyxcbiAqICAgICAgICAgICAgICAgICAgICBrZXkyOiAndmFsdWUyJ1xuICogICAgICAgICAgICAgICAgICB9XG4gKi9cbnByb3RvLm11bHRpcGFydFVwbG9hZCA9IGFzeW5jIGZ1bmN0aW9uIG11bHRpcGFydFVwbG9hZChuYW1lLCBmaWxlLCBvcHRpb25zKSB7XG4gIHRoaXMucmVzZXRDYW5jZWxGbGFnKCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAob3B0aW9ucy5jaGVja3BvaW50ICYmIG9wdGlvbnMuY2hlY2twb2ludC51cGxvYWRJZCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZXN1bWVNdWx0aXBhcnQob3B0aW9ucy5jaGVja3BvaW50LCBvcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IG1pblBhcnRTaXplID0gMTAwICogMTAyNDtcblxuICBpZiAoIW9wdGlvbnMubWltZSkge1xuICAgIGlmIChpcy5maWxlKGZpbGUpKSB7XG4gICAgICBvcHRpb25zLm1pbWUgPSBtaW1lLmdldFR5cGUocGF0aC5leHRuYW1lKGZpbGUubmFtZSkpO1xuICAgIH0gZWxzZSBpZiAoaXMuYmxvYihmaWxlKSkge1xuICAgICAgb3B0aW9ucy5taW1lID0gZmlsZS50eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLm1pbWUgPSBtaW1lLmdldFR5cGUocGF0aC5leHRuYW1lKGZpbGUpKTtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gIHRoaXMuX2NvbnZlcnRNZXRhVG9IZWFkZXJzKG9wdGlvbnMubWV0YSwgb3B0aW9ucy5oZWFkZXJzKTtcblxuICBjb25zdCBmaWxlU2l6ZSA9IGF3YWl0IHRoaXMuX2dldEZpbGVTaXplKGZpbGUpO1xuICBpZiAoZmlsZVNpemUgPCBtaW5QYXJ0U2l6ZSkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NyZWF0ZVN0cmVhbShmaWxlLCAwLCBmaWxlU2l6ZSk7XG4gICAgb3B0aW9ucy5jb250ZW50TGVuZ3RoID0gZmlsZVNpemU7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnB1dFN0cmVhbShuYW1lLCBzdHJlYW0sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvZ3Jlc3MpIHtcbiAgICAgIGF3YWl0IG9wdGlvbnMucHJvZ3Jlc3MoMSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmV0ID0ge1xuICAgICAgcmVzOiByZXN1bHQucmVzLFxuICAgICAgYnVja2V0OiB0aGlzLm9wdGlvbnMuYnVja2V0LFxuICAgICAgbmFtZSxcbiAgICAgIGV0YWc6IHJlc3VsdC5yZXMuaGVhZGVycy5ldGFnXG4gICAgfTtcblxuICAgIGlmICgob3B0aW9ucy5oZWFkZXJzICYmIG9wdGlvbnMuaGVhZGVyc1sneC1vc3MtY2FsbGJhY2snXSkgfHwgb3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgcmV0LmRhdGEgPSByZXN1bHQuZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGlmIChvcHRpb25zLnBhcnRTaXplICYmICEocGFyc2VJbnQob3B0aW9ucy5wYXJ0U2l6ZSwgMTApID09PSBvcHRpb25zLnBhcnRTaXplKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFydFNpemUgbXVzdCBiZSBpbnQgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5wYXJ0U2l6ZSAmJiBvcHRpb25zLnBhcnRTaXplIDwgbWluUGFydFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnRTaXplIG11c3Qgbm90IGJlIHNtYWxsZXIgdGhhbiAke21pblBhcnRTaXplfWApO1xuICB9XG5cbiAgY29uc3QgaW5pdFJlc3VsdCA9IGF3YWl0IHRoaXMuaW5pdE11bHRpcGFydFVwbG9hZChuYW1lLCBvcHRpb25zKTtcbiAgY29uc3QgeyB1cGxvYWRJZCB9ID0gaW5pdFJlc3VsdDtcbiAgY29uc3QgcGFydFNpemUgPSB0aGlzLl9nZXRQYXJ0U2l6ZShmaWxlU2l6ZSwgb3B0aW9ucy5wYXJ0U2l6ZSk7XG5cbiAgY29uc3QgY2hlY2twb2ludCA9IHtcbiAgICBmaWxlLFxuICAgIG5hbWUsXG4gICAgZmlsZVNpemUsXG4gICAgcGFydFNpemUsXG4gICAgdXBsb2FkSWQsXG4gICAgZG9uZVBhcnRzOiBbXVxuICB9O1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvZ3Jlc3MpIHtcbiAgICBhd2FpdCBvcHRpb25zLnByb2dyZXNzKDAsIGNoZWNrcG9pbnQsIGluaXRSZXN1bHQucmVzKTtcbiAgfVxuXG5cbiAgcmV0dXJuIGF3YWl0IHRoaXMuX3Jlc3VtZU11bHRpcGFydChjaGVja3BvaW50LCBvcHRpb25zKTtcbn07XG5cbi8qXG4gKiBSZXN1bWUgbXVsdGlwYXJ0IHVwbG9hZCBmcm9tIGNoZWNrcG9pbnQuIFRoZSBjaGVja3BvaW50IHdpbGwgYmVcbiAqIHVwZGF0ZWQgYWZ0ZXIgZWFjaCBzdWNjZXNzZnVsIHBhcnQgdXBsb2FkLlxuICogQHBhcmFtIHtPYmplY3R9IGNoZWNrcG9pbnQgdGhlIGNoZWNrcG9pbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbnByb3RvLl9yZXN1bWVNdWx0aXBhcnQgPSBhc3luYyBmdW5jdGlvbiBfcmVzdW1lTXVsdGlwYXJ0KGNoZWNrcG9pbnQsIG9wdGlvbnMpIHtcbiAgY29uc3QgdGhhdCA9IHRoaXM7XG4gIGlmICh0aGlzLmlzQ2FuY2VsKCkpIHtcbiAgICB0aHJvdyB0aGlzLl9tYWtlQ2FuY2VsRXZlbnQoKTtcbiAgfVxuICBjb25zdCB7XG4gICAgZmlsZSwgZmlsZVNpemUsIHBhcnRTaXplLCB1cGxvYWRJZCwgZG9uZVBhcnRzLCBuYW1lXG4gIH0gPSBjaGVja3BvaW50O1xuXG4gIGNvbnN0IGludGVybmFsRG9uZVBhcnRzID0gW107XG5cbiAgaWYgKGRvbmVQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgY29weShkb25lUGFydHMpLnRvKGludGVybmFsRG9uZVBhcnRzKTtcbiAgfVxuXG4gIGNvbnN0IHBhcnRPZmZzID0gdGhpcy5fZGl2aWRlUGFydHMoZmlsZVNpemUsIHBhcnRTaXplKTtcbiAgY29uc3QgbnVtUGFydHMgPSBwYXJ0T2Zmcy5sZW5ndGg7XG4gIGxldCBtdWx0aXBhcnRGaW5pc2ggPSBmYWxzZTtcblxuICBsZXQgdXBsb2FkUGFydEpvYiA9IGZ1bmN0aW9uIHVwbG9hZFBhcnRKb2Ioc2VsZiwgcGFydE5vKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghc2VsZi5pc0NhbmNlbCgpKSB7XG4gICAgICAgICAgY29uc3QgcGkgPSBwYXJ0T2Zmc1twYXJ0Tm8gLSAxXTtcbiAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgc3RyZWFtOiBzZWxmLl9jcmVhdGVTdHJlYW0oZmlsZSwgcGkuc3RhcnQsIHBpLmVuZCksXG4gICAgICAgICAgICBzaXplOiBwaS5lbmQgLSBwaS5zdGFydFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZWxmLl91cGxvYWRQYXJ0KG5hbWUsIHVwbG9hZElkLCBwYXJ0Tm8sIGRhdGEpO1xuICAgICAgICAgIGlmICghc2VsZi5pc0NhbmNlbCgpICYmICFtdWx0aXBhcnRGaW5pc2gpIHtcbiAgICAgICAgICAgIGNoZWNrcG9pbnQuZG9uZVBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICBudW1iZXI6IHBhcnRObyxcbiAgICAgICAgICAgICAgZXRhZzogcmVzdWx0LnJlcy5oZWFkZXJzLmV0YWdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wcm9ncmVzcykge1xuICAgICAgICAgICAgICBhd2FpdCBvcHRpb25zLnByb2dyZXNzKGRvbmVQYXJ0cy5sZW5ndGggLyBudW1QYXJ0cywgY2hlY2twb2ludCwgcmVzdWx0LnJlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBudW1iZXI6IHBhcnRObyxcbiAgICAgICAgICAgICAgZXRhZzogcmVzdWx0LnJlcy5oZWFkZXJzLmV0YWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IHRlbXBFcnIgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgdGVtcEVyci5uYW1lID0gZXJyLm5hbWU7XG4gICAgICAgIHRlbXBFcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICB0ZW1wRXJyLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0ZW1wRXJyLnBhcnROdW0gPSBwYXJ0Tm87XG4gICAgICAgIGNvcHkoZXJyKS50byh0ZW1wRXJyKTtcbiAgICAgICAgcmVqZWN0KHRlbXBFcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGFsbCA9IEFycmF5LmZyb20obmV3IEFycmF5KG51bVBhcnRzKSwgKHgsIGkpID0+IGkgKyAxKTtcbiAgY29uc3QgZG9uZSA9IGludGVybmFsRG9uZVBhcnRzLm1hcChwID0+IHAubnVtYmVyKTtcbiAgY29uc3QgdG9kbyA9IGFsbC5maWx0ZXIocCA9PiBkb25lLmluZGV4T2YocCkgPCAwKTtcbiAgY29uc3QgZGVmYXVsdFBhcmFsbGVsID0gNTtcbiAgY29uc3QgcGFyYWxsZWwgPSBvcHRpb25zLnBhcmFsbGVsIHx8IGRlZmF1bHRQYXJhbGxlbDtcblxuICAvLyB1cGxvYWQgaW4gcGFyYWxsZWxcbiAgY29uc3Qgam9iRXJyID0gYXdhaXQgdGhpcy5fcGFyYWxsZWwodG9kbywgcGFyYWxsZWwsIHZhbHVlID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB1cGxvYWRQYXJ0Sm9iKHRoYXQsIHZhbHVlKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaW50ZXJuYWxEb25lUGFydHMucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH0pO1xuICB9KSk7XG4gIG11bHRpcGFydEZpbmlzaCA9IHRydWU7XG5cbiAgaWYgKHRoaXMuaXNDYW5jZWwoKSkge1xuICAgIHVwbG9hZFBhcnRKb2IgPSBudWxsO1xuICAgIHRocm93IHRoaXMuX21ha2VDYW5jZWxFdmVudCgpO1xuICB9XG5cbiAgaWYgKGpvYkVyciAmJiBqb2JFcnIubGVuZ3RoID4gMCkge1xuICAgIGpvYkVyclswXS5tZXNzYWdlID0gYEZhaWxlZCB0byB1cGxvYWQgc29tZSBwYXJ0cyB3aXRoIGVycm9yOiAke2pvYkVyclswXS50b1N0cmluZygpfSBwYXJ0X251bTogJHtqb2JFcnJbMF0ucGFydE51bX1gO1xuICAgIHRocm93IGpvYkVyclswXTtcbiAgfVxuICByZXR1cm4gYXdhaXQgdGhpcy5jb21wbGV0ZU11bHRpcGFydFVwbG9hZChuYW1lLCB1cGxvYWRJZCwgaW50ZXJuYWxEb25lUGFydHMsIG9wdGlvbnMpO1xufTtcblxuXG5pcy5maWxlID0gZnVuY3Rpb24gZmlsZShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiAoRmlsZSkgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEZpbGU7XG59O1xuXG5pcy5ibG9iID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgcmV0dXJuIHR5cGVvZiAoQmxvYikgIT09ICd1bmRlZmluZWQnICYmIGJsb2IgaW5zdGFuY2VvZiBCbG9iO1xufTtcblxuLyoqXG4gKiBHZXQgZmlsZSBzaXplXG4gKi9cbnByb3RvLl9nZXRGaWxlU2l6ZSA9IGFzeW5jIGZ1bmN0aW9uIF9nZXRGaWxlU2l6ZShmaWxlKSB7XG4gIGlmIChpcy5idWZmZXIoZmlsZSkpIHtcbiAgICByZXR1cm4gZmlsZS5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoaXMuYmxvYihmaWxlKSB8fCBpcy5maWxlKGZpbGUpKSB7XG4gICAgcmV0dXJuIGZpbGUuc2l6ZTtcbiAgfSBpZiAoaXMuc3RyaW5nKGZpbGUpKSB7XG4gICAgY29uc3Qgc3RhdCA9IGF3YWl0IHRoaXMuX3N0YXRGaWxlKGZpbGUpO1xuICAgIHJldHVybiBzdGF0LnNpemU7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ19nZXRGaWxlU2l6ZSByZXF1aXJlcyBCdWZmZXIvRmlsZS9TdHJpbmcuJyk7XG59O1xuXG4vKlxuICogUmVhZGFibGUgc3RyZWFtIGZvciBXZWIgRmlsZVxuICovXG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gV2ViRmlsZVJlYWRTdHJlYW0oZmlsZSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV2ViRmlsZVJlYWRTdHJlYW0pKSB7XG4gICAgcmV0dXJuIG5ldyBXZWJGaWxlUmVhZFN0cmVhbShmaWxlLCBvcHRpb25zKTtcbiAgfVxuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5maWxlID0gZmlsZTtcbiAgdGhpcy5yZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICB0aGlzLnN0YXJ0ID0gMDtcbiAgdGhpcy5maW5pc2ggPSBmYWxzZTtcbiAgdGhpcy5maWxlQnVmZmVyID0gbnVsbDtcbn1cbnV0aWwuaW5oZXJpdHMoV2ViRmlsZVJlYWRTdHJlYW0sIFJlYWRhYmxlKTtcblxuV2ViRmlsZVJlYWRTdHJlYW0ucHJvdG90eXBlLnJlYWRGaWxlQW5kUHVzaCA9IGZ1bmN0aW9uIHJlYWRGaWxlQW5kUHVzaChzaXplKSB7XG4gIGlmICh0aGlzLmZpbGVCdWZmZXIpIHtcbiAgICBsZXQgcHVzaFJldCA9IHRydWU7XG4gICAgd2hpbGUgKHB1c2hSZXQgJiYgdGhpcy5maWxlQnVmZmVyICYmIHRoaXMuc3RhcnQgPCB0aGlzLmZpbGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICBjb25zdCB7IHN0YXJ0IH0gPSB0aGlzO1xuICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgc2l6ZTtcbiAgICAgIGVuZCA9IGVuZCA+IHRoaXMuZmlsZUJ1ZmZlci5sZW5ndGggPyB0aGlzLmZpbGVCdWZmZXIubGVuZ3RoIDogZW5kO1xuICAgICAgdGhpcy5zdGFydCA9IGVuZDtcbiAgICAgIHB1c2hSZXQgPSB0aGlzLnB1c2godGhpcy5maWxlQnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICB9XG4gIH1cbn07XG5cbldlYkZpbGVSZWFkU3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIF9yZWFkKHNpemUpIHtcbiAgaWYgKCh0aGlzLmZpbGUgJiYgdGhpcy5zdGFydCA+PSB0aGlzLmZpbGUuc2l6ZSkgfHxcbiAgICAgICh0aGlzLmZpbGVCdWZmZXIgJiYgdGhpcy5zdGFydCA+PSB0aGlzLmZpbGVCdWZmZXIubGVuZ3RoKSB8fFxuICAgICAgKHRoaXMuZmluaXNoKSB8fCAodGhpcy5zdGFydCA9PT0gMCAmJiAhdGhpcy5maWxlKSkge1xuICAgIGlmICghdGhpcy5maW5pc2gpIHtcbiAgICAgIHRoaXMuZmlsZUJ1ZmZlciA9IG51bGw7XG4gICAgICB0aGlzLmZpbmlzaCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucHVzaChudWxsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBkZWZhdWx0UmVhZFNpemUgPSAxNiAqIDEwMjQ7XG4gIHNpemUgPSBzaXplIHx8IGRlZmF1bHRSZWFkU2l6ZTtcblxuICBjb25zdCB0aGF0ID0gdGhpcztcbiAgdGhpcy5yZWFkZXIub25sb2FkID0gZnVuY3Rpb24gb25sb2FkKGUpIHtcbiAgICB0aGF0LmZpbGVCdWZmZXIgPSBuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KGUudGFyZ2V0LnJlc3VsdCkpO1xuICAgIHRoYXQuZmlsZSA9IG51bGw7XG4gICAgdGhhdC5yZWFkRmlsZUFuZFB1c2goc2l6ZSk7XG4gIH07XG5cbiAgaWYgKHRoaXMuc3RhcnQgPT09IDApIHtcbiAgICB0aGlzLnJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcih0aGlzLmZpbGUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVhZEZpbGVBbmRQdXNoKHNpemUpO1xuICB9XG59O1xuXG5wcm90by5fY3JlYXRlU3RyZWFtID0gZnVuY3Rpb24gX2NyZWF0ZVN0cmVhbShmaWxlLCBzdGFydCwgZW5kKSB7XG4gIGlmIChpcy5ibG9iKGZpbGUpIHx8IGlzLmZpbGUoZmlsZSkpIHtcbiAgICByZXR1cm4gbmV3IFdlYkZpbGVSZWFkU3RyZWFtKGZpbGUuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICB9XG4gIC8vIGVsc2UgaWYgKGlzLnN0cmluZyhmaWxlKSkge1xuICAvLyAgIHJldHVybiBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGUsIHtcbiAgLy8gICAgIHN0YXJ0OiBzdGFydCxcbiAgLy8gICAgIGVuZDogZW5kIC0gMVxuICAvLyAgIH0pO1xuICAvLyB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdfY3JlYXRlU3RyZWFtIHJlcXVpcmVzIEZpbGUvU3RyaW5nLicpO1xufTtcblxucHJvdG8uX2dldFBhcnRTaXplID0gZnVuY3Rpb24gX2dldFBhcnRTaXplKGZpbGVTaXplLCBwYXJ0U2l6ZSkge1xuICBjb25zdCBtYXhOdW1QYXJ0cyA9IDEwICogMTAwMDtcbiAgY29uc3QgZGVmYXVsdFBhcnRTaXplID0gMTAyNCAqIDEwMjQ7XG5cbiAgaWYgKCFwYXJ0U2l6ZSkge1xuICAgIHJldHVybiBkZWZhdWx0UGFydFNpemU7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXgoXG4gICAgTWF0aC5jZWlsKGZpbGVTaXplIC8gbWF4TnVtUGFydHMpLFxuICAgIHBhcnRTaXplLFxuICApO1xufTtcblxucHJvdG8uX2RpdmlkZVBhcnRzID0gZnVuY3Rpb24gX2RpdmlkZVBhcnRzKGZpbGVTaXplLCBwYXJ0U2l6ZSkge1xuICBjb25zdCBudW1QYXJ0cyA9IE1hdGguY2VpbChmaWxlU2l6ZSAvIHBhcnRTaXplKTtcblxuICBjb25zdCBwYXJ0T2ZmcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBhcnRzOyBpKyspIHtcbiAgICBjb25zdCBzdGFydCA9IHBhcnRTaXplICogaTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihzdGFydCArIHBhcnRTaXplLCBmaWxlU2l6ZSk7XG5cbiAgICBwYXJ0T2Zmcy5wdXNoKHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcGFydE9mZnM7XG59O1xuIiwiXG4vLyBjb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2FsaS1vc3M6b2JqZWN0Jyk7XG5jb25zdCB1dGlsaXR5ID0gcmVxdWlyZSgndXRpbGl0eScpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgaXMgPSByZXF1aXJlKCdpcy10eXBlLW9mJyk7XG5jb25zdCB1cmx1dGlsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBjb3B5ID0gcmVxdWlyZSgnY29weS10bycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IG1pbWUgPSByZXF1aXJlKCdtaW1lJyk7XG5jb25zdCBjYWxsYmFjayA9IHJlcXVpcmUoJy4uL2NvbW1vbi9jYWxsYmFjaycpO1xuY29uc3Qgc2lnbkhlbHBlciA9IHJlcXVpcmUoJy4uL2NvbW1vbi9zaWduVXRpbHMnKTtcblxuLy8gdmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5cbmNvbnN0IHByb3RvID0gZXhwb3J0cztcblxuLyoqXG4gKiBPYmplY3Qgb3BlcmF0aW9uc1xuICovXG5cbi8qKlxuICAqIGFwcGVuZCBhbiBvYmplY3QgZnJvbSBTdHJpbmcoZmlsZSBwYXRoKS9CdWZmZXIvUmVhZGFibGVTdHJlYW1cbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgb2JqZWN0IGtleVxuICAqIEBwYXJhbSB7TWl4ZWR9IGZpbGUgU3RyaW5nKGZpbGUgcGF0aCkvQnVmZmVyL1JlYWRhYmxlU3RyZWFtXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICovXG5wcm90by5hcHBlbmQgPSBhc3luYyBmdW5jdGlvbiBhcHBlbmQobmFtZSwgZmlsZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCkgb3B0aW9ucy5wb3NpdGlvbiA9ICcwJztcbiAgb3B0aW9ucy5zdWJyZXMgPSB7XG4gICAgYXBwZW5kOiAnJyxcbiAgICBwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvblxuICB9O1xuICBvcHRpb25zLm1ldGhvZCA9ICdQT1NUJztcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnB1dChuYW1lLCBmaWxlLCBvcHRpb25zKTtcbiAgcmVzdWx0Lm5leHRBcHBlbmRQb3NpdGlvbiA9IHJlc3VsdC5yZXMuaGVhZGVyc1sneC1vc3MtbmV4dC1hcHBlbmQtcG9zaXRpb24nXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogcHV0IGFuIG9iamVjdCBmcm9tIFN0cmluZyhmaWxlIHBhdGgpL0J1ZmZlci9SZWFkYWJsZVN0cmVhbVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG9iamVjdCBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IGZpbGUgU3RyaW5nKGZpbGUgcGF0aCkvQnVmZmVyL1JlYWRhYmxlU3RyZWFtXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgIHtPYmplY3R9IG9wdGlvbnMuY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHBhcmFtZXRlciBpcyBjb21wb3NlZCBvZiBhIEpTT04gc3RyaW5nIGVuY29kZWQgaW4gQmFzZTY0XG4gKiAgICAgICAge1N0cmluZ30gb3B0aW9ucy5jYWxsYmFjay51cmwgIHRoZSBPU1Mgc2VuZHMgYSBjYWxsYmFjayByZXF1ZXN0IHRvIHRoaXMgVVJMXG4gKiAgICAgICAge1N0cmluZ30gb3B0aW9ucy5jYWxsYmFjay5ob3N0ICBUaGUgaG9zdCBoZWFkZXIgdmFsdWUgZm9yIGluaXRpYXRpbmcgY2FsbGJhY2sgcmVxdWVzdHNcbiAqICAgICAgICB7U3RyaW5nfSBvcHRpb25zLmNhbGxiYWNrLmJvZHkgIFRoZSB2YWx1ZSBvZiB0aGUgcmVxdWVzdCBib2R5IHdoZW4gYSBjYWxsYmFjayBpcyBpbml0aWF0ZWRcbiAqICAgICAgICB7U3RyaW5nfSBvcHRpb25zLmNhbGxiYWNrLmNvbnRlbnRUeXBlICBUaGUgQ29udGVudC1UeXBlIG9mIHRoZSBjYWxsYmFjayByZXF1ZXN0cyBpbml0aWF0aWF0ZWRcbiAqICAgICAgICB7T2JqZWN0fSBvcHRpb25zLmNhbGxiYWNrLmN1c3RvbVZhbHVlICBDdXN0b20gcGFyYW1ldGVycyBhcmUgYSBtYXAgb2Yga2V5LXZhbHVlcywgZS5nOlxuICogICAgICAgICAgICAgICAgICBjdXN0b21WYWx1ZSA9IHtcbiAqICAgICAgICAgICAgICAgICAgICBrZXkxOiAndmFsdWUxJyxcbiAqICAgICAgICAgICAgICAgICAgICBrZXkyOiAndmFsdWUyJ1xuICogICAgICAgICAgICAgICAgICB9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnByb3RvLnB1dCA9IGFzeW5jIGZ1bmN0aW9uIHB1dChuYW1lLCBmaWxlLCBvcHRpb25zKSB7XG4gIGxldCBjb250ZW50O1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoaXMuYnVmZmVyKGZpbGUpKSB7XG4gICAgY29udGVudCA9IGZpbGU7XG4gIH0gZWxzZSBpZiAoaXMuYmxvYihmaWxlKSB8fCBpcy5maWxlKGZpbGUpKSB7XG4gICAgaWYgKCFvcHRpb25zLm1pbWUpIHtcbiAgICAgIGlmIChpcy5maWxlKGZpbGUpKSB7XG4gICAgICAgIG9wdGlvbnMubWltZSA9IG1pbWUuZ2V0VHlwZShwYXRoLmV4dG5hbWUoZmlsZS5uYW1lKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLm1pbWUgPSBmaWxlLnR5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fY3JlYXRlU3RyZWFtKGZpbGUsIDAsIGZpbGUuc2l6ZSk7XG4gICAgb3B0aW9ucy5jb250ZW50TGVuZ3RoID0gYXdhaXQgdGhpcy5fZ2V0RmlsZVNpemUoZmlsZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wdXRTdHJlYW0obmFtZSwgc3RyZWFtLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBCdWZmZXIvQmxvYiBmb3IgcHV0LicpO1xuICB9XG5cbiAgb3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICB0aGlzLl9jb252ZXJ0TWV0YVRvSGVhZGVycyhvcHRpb25zLm1ldGEsIG9wdGlvbnMuaGVhZGVycyk7XG5cbiAgY29uc3QgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgJ1BVVCc7XG4gIGNvbnN0IHBhcmFtcyA9IHRoaXMuX29iamVjdFJlcXVlc3RQYXJhbXMobWV0aG9kLCBuYW1lLCBvcHRpb25zKTtcbiAgY2FsbGJhY2suZW5jb2RlQ2FsbGJhY2socGFyYW1zLCBvcHRpb25zKTtcbiAgcGFyYW1zLm1pbWUgPSBvcHRpb25zLm1pbWU7XG4gIHBhcmFtcy5jb250ZW50ID0gY29udGVudDtcbiAgcGFyYW1zLnN1Y2Nlc3NTdGF0dXNlcyA9IFsyMDBdO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdChwYXJhbXMpO1xuXG4gIGNvbnN0IHJldCA9IHtcbiAgICBuYW1lLFxuICAgIHVybDogdGhpcy5fb2JqZWN0VXJsKG5hbWUpLFxuICAgIHJlczogcmVzdWx0LnJlc1xuICB9O1xuXG4gIGlmIChwYXJhbXMuaGVhZGVycyAmJiBwYXJhbXMuaGVhZGVyc1sneC1vc3MtY2FsbGJhY2snXSkge1xuICAgIHJldC5kYXRhID0gSlNPTi5wYXJzZShyZXN1bHQuZGF0YS50b1N0cmluZygpKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIHB1dCBhbiBvYmplY3QgZnJvbSBSZWFkYWJsZVN0cmVhbS4gSWYgYG9wdGlvbnMuY29udGVudExlbmd0aGAgaXNcbiAqIG5vdCBwcm92aWRlZCwgY2h1bmtlZCBlbmNvZGluZyBpcyB1c2VkLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG9iamVjdCBrZXlcbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSB0aGUgUmVhZGFibGVTdHJlYW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnByb3RvLnB1dFN0cmVhbSA9IGFzeW5jIGZ1bmN0aW9uIHB1dFN0cmVhbShuYW1lLCBzdHJlYW0sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMuY29udGVudExlbmd0aCkge1xuICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IG9wdGlvbnMuY29udGVudExlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmhlYWRlcnNbJ1RyYW5zZmVyLUVuY29kaW5nJ10gPSAnY2h1bmtlZCc7XG4gIH1cbiAgdGhpcy5fY29udmVydE1ldGFUb0hlYWRlcnMob3B0aW9ucy5tZXRhLCBvcHRpb25zLmhlYWRlcnMpO1xuXG4gIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8ICdQVVQnO1xuICBjb25zdCBwYXJhbXMgPSB0aGlzLl9vYmplY3RSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgbmFtZSwgb3B0aW9ucyk7XG4gIGNhbGxiYWNrLmVuY29kZUNhbGxiYWNrKHBhcmFtcywgb3B0aW9ucyk7XG4gIHBhcmFtcy5taW1lID0gb3B0aW9ucy5taW1lO1xuICBwYXJhbXMuc3RyZWFtID0gc3RyZWFtO1xuICBwYXJhbXMuc3VjY2Vzc1N0YXR1c2VzID0gWzIwMF07XG5cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHBhcmFtcyk7XG5cbiAgY29uc3QgcmV0ID0ge1xuICAgIG5hbWUsXG4gICAgdXJsOiB0aGlzLl9vYmplY3RVcmwobmFtZSksXG4gICAgcmVzOiByZXN1bHQucmVzXG4gIH07XG5cbiAgaWYgKHBhcmFtcy5oZWFkZXJzICYmIHBhcmFtcy5oZWFkZXJzWyd4LW9zcy1jYWxsYmFjayddKSB7XG4gICAgcmV0LmRhdGEgPSBKU09OLnBhcnNlKHJlc3VsdC5kYXRhLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbnByb3RvLmhlYWQgPSBhc3luYyBmdW5jdGlvbiBoZWFkKG5hbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFyYW1zID0gdGhpcy5fb2JqZWN0UmVxdWVzdFBhcmFtcygnSEVBRCcsIG5hbWUsIG9wdGlvbnMpO1xuICBwYXJhbXMuc3VjY2Vzc1N0YXR1c2VzID0gWzIwMCwgMzA0XTtcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3QocGFyYW1zKTtcblxuICBjb25zdCBkYXRhID0ge1xuICAgIG1ldGE6IG51bGwsXG4gICAgcmVzOiByZXN1bHQucmVzLFxuICAgIHN0YXR1czogcmVzdWx0LnN0YXR1c1xuICB9O1xuXG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAyMDApIHtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQuaGVhZGVycykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgaWYgKGsuaW5kZXhPZigneC1vc3MtbWV0YS0nKSA9PT0gMCkge1xuICAgICAgICBpZiAoIWRhdGEubWV0YSkge1xuICAgICAgICAgIGRhdGEubWV0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRhdGEubWV0YVtrLnN1YnN0cmluZygxMSldID0gcmVzdWx0LmhlYWRlcnNba107XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5wcm90by5nZXQgPSBhc3luYyBmdW5jdGlvbiBnZXQobmFtZSwgZmlsZSwgb3B0aW9ucykge1xuICBsZXQgd3JpdGVTdHJlYW0gPSBudWxsO1xuICBsZXQgbmVlZERlc3Ryb3kgPSBmYWxzZTtcblxuICBpZiAoaXMud3JpdGFibGVTdHJlYW0oZmlsZSkpIHtcbiAgICB3cml0ZVN0cmVhbSA9IGZpbGU7XG4gIH0gZWxzZSBpZiAoaXMuc3RyaW5nKGZpbGUpKSB7XG4gICAgd3JpdGVTdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShmaWxlKTtcbiAgICBuZWVkRGVzdHJveSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2V0KG5hbWUsIG9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IGZpbGU7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMucHJvY2Vzcykge1xuICAgIG9wdGlvbnMuc3VicmVzID0gb3B0aW9ucy5zdWJyZXMgfHwge307XG4gICAgb3B0aW9ucy5zdWJyZXNbJ3gtb3NzLXByb2Nlc3MnXSA9IG9wdGlvbnMucHJvY2VzcztcbiAgfVxuXG4gIGxldCByZXN1bHQ7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5fb2JqZWN0UmVxdWVzdFBhcmFtcygnR0VUJywgbmFtZSwgb3B0aW9ucyk7XG4gICAgcGFyYW1zLndyaXRlU3RyZWFtID0gd3JpdGVTdHJlYW07XG4gICAgcGFyYW1zLnN1Y2Nlc3NTdGF0dXNlcyA9IFsyMDAsIDIwNiwgMzA0XTtcblxuICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdChwYXJhbXMpO1xuXG4gICAgaWYgKG5lZWREZXN0cm95KSB7XG4gICAgICB3cml0ZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAobmVlZERlc3Ryb3kpIHtcbiAgICAgIHdyaXRlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIC8vIHNob3VsZCBkZWxldGUgdGhlIGV4aXN0cyBmaWxlIGJlZm9yZSB0aHJvdyBlcnJvclxuICAgICAgdGhpcy5kZWJ1ZygnZ2V0IGVycm9yOiAlcywgZGVsZXRlIHRoZSBleGlzdHMgZmlsZSAlcycsIGVyciwgZmlsZSwgJ2Vycm9yJyk7XG4gICAgICBhd2FpdCB0aGlzLl9kZWxldGVGaWxlU2FmZShmaWxlKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZXM6IHJlc3VsdC5yZXMsXG4gICAgY29udGVudDogcmVzdWx0LmRhdGFcbiAgfTtcbn07XG5cbnByb3RvLmRlbGV0ZSA9IGFzeW5jIGZ1bmN0aW9uIF9kZWxldGUobmFtZSwgb3B0aW9ucykge1xuICBjb25zdCBwYXJhbXMgPSB0aGlzLl9vYmplY3RSZXF1ZXN0UGFyYW1zKCdERUxFVEUnLCBuYW1lLCBvcHRpb25zKTtcbiAgcGFyYW1zLnN1Y2Nlc3NTdGF0dXNlcyA9IFsyMDRdO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdChwYXJhbXMpO1xuXG4gIHJldHVybiB7XG4gICAgcmVzOiByZXN1bHQucmVzXG4gIH07XG59O1xuXG5wcm90by5kZWxldGVNdWx0aSA9IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZU11bHRpKG5hbWVzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgeG1sID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/PlxcbjxEZWxldGU+XFxuJztcbiAgaWYgKG9wdGlvbnMucXVpZXQpIHtcbiAgICB4bWwgKz0gJyAgPFF1aWV0PnRydWU8L1F1aWV0Plxcbic7XG4gIH0gZWxzZSB7XG4gICAgeG1sICs9ICcgIDxRdWlldD5mYWxzZTwvUXVpZXQ+XFxuJztcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgeG1sICs9IGAgIDxPYmplY3Q+PEtleT4ke1xuICAgICAgdXRpbGl0eS5lc2NhcGUodGhpcy5fb2JqZWN0TmFtZShuYW1lc1tpXSkpfTwvS2V5PjwvT2JqZWN0PlxcbmA7XG4gIH1cbiAgeG1sICs9ICc8L0RlbGV0ZT4nO1xuICB0aGlzLmRlYnVnKCdkZWxldGUgbXVsdGkgb2JqZWN0czogJXMnLCB4bWwsICdpbmZvJyk7XG5cbiAgb3B0aW9ucy5zdWJyZXMgPSAnZGVsZXRlJztcbiAgY29uc3QgcGFyYW1zID0gdGhpcy5fb2JqZWN0UmVxdWVzdFBhcmFtcygnUE9TVCcsICcnLCBvcHRpb25zKTtcbiAgcGFyYW1zLm1pbWUgPSAneG1sJztcbiAgcGFyYW1zLmNvbnRlbnQgPSB4bWw7XG4gIHBhcmFtcy54bWxSZXNwb25zZSA9IHRydWU7XG4gIHBhcmFtcy5zdWNjZXNzU3RhdHVzZXMgPSBbMjAwXTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHBhcmFtcyk7XG5cbiAgY29uc3QgciA9IHJlc3VsdC5kYXRhO1xuICBsZXQgZGVsZXRlZCA9IChyICYmIHIuRGVsZXRlZCkgfHwgbnVsbDtcbiAgaWYgKGRlbGV0ZWQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVsZXRlZCkpIHtcbiAgICAgIGRlbGV0ZWQgPSBbZGVsZXRlZF07XG4gICAgfVxuICAgIGRlbGV0ZWQgPSBkZWxldGVkLm1hcChpdGVtID0+IGl0ZW0uS2V5KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlczogcmVzdWx0LnJlcyxcbiAgICBkZWxldGVkXG4gIH07XG59O1xuXG4vKiBlc2xpbnQgbm8tc2hhZG93OiBbMF0gKi9cbnByb3RvLmNvcHkgPSBhc3luYyBmdW5jdGlvbiBjb3B5KG5hbWUsIHNvdXJjZU5hbWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgT2JqZWN0LmtleXMob3B0aW9ucy5oZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBvcHRpb25zLmhlYWRlcnNbYHgtb3NzLWNvcHktc291cmNlLSR7a2V5LnRvTG93ZXJDYXNlKCl9YF0gPSBvcHRpb25zLmhlYWRlcnNba2V5XTtcbiAgfSk7XG5cbiAgaWYgKG9wdGlvbnMubWV0YSkge1xuICAgIG9wdGlvbnMuaGVhZGVyc1sneC1vc3MtbWV0YWRhdGEtZGlyZWN0aXZlJ10gPSAnUkVQTEFDRSc7XG4gIH1cbiAgdGhpcy5fY29udmVydE1ldGFUb0hlYWRlcnMob3B0aW9ucy5tZXRhLCBvcHRpb25zLmhlYWRlcnMpO1xuXG4gIGlmIChzb3VyY2VOYW1lWzBdICE9PSAnLycpIHtcbiAgICAvLyBubyBzcGVjaWZ5IGJ1Y2tldCBuYW1lXG4gICAgc291cmNlTmFtZSA9IGAvJHt0aGlzLm9wdGlvbnMuYnVja2V0fS8ke2VuY29kZVVSSUNvbXBvbmVudChzb3VyY2VOYW1lKX1gO1xuICB9IGVsc2Uge1xuICAgIHNvdXJjZU5hbWUgPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHNvdXJjZU5hbWUuc2xpY2UoMSkpfWA7XG4gIH1cblxuICBvcHRpb25zLmhlYWRlcnNbJ3gtb3NzLWNvcHktc291cmNlJ10gPSBzb3VyY2VOYW1lO1xuXG4gIGNvbnN0IHBhcmFtcyA9IHRoaXMuX29iamVjdFJlcXVlc3RQYXJhbXMoJ1BVVCcsIG5hbWUsIG9wdGlvbnMpO1xuICBwYXJhbXMueG1sUmVzcG9uc2UgPSB0cnVlO1xuICBwYXJhbXMuc3VjY2Vzc1N0YXR1c2VzID0gWzIwMCwgMzA0XTtcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3QocGFyYW1zKTtcblxuICBsZXQgeyBkYXRhIH0gPSByZXN1bHQ7XG4gIGlmIChkYXRhKSB7XG4gICAgZGF0YSA9IHtcbiAgICAgIGV0YWc6IGRhdGEuRVRhZyxcbiAgICAgIGxhc3RNb2RpZmllZDogZGF0YS5MYXN0TW9kaWZpZWRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIHJlczogcmVzdWx0LnJlc1xuICB9O1xufTtcblxucHJvdG8ucHV0TWV0YSA9IGFzeW5jIGZ1bmN0aW9uIHB1dE1ldGEobmFtZSwgbWV0YSwgb3B0aW9ucykge1xuICBjb25zdCBjb3B5UmVzdWx0ID0gYXdhaXQgdGhpcy5jb3B5KG5hbWUsIG5hbWUsIHtcbiAgICBtZXRhOiBtZXRhIHx8IHt9LFxuICAgIHRpbWVvdXQ6IG9wdGlvbnMgJiYgb3B0aW9ucy50aW1lb3V0LFxuICAgIGN0eDogb3B0aW9ucyAmJiBvcHRpb25zLmN0eFxuICB9KTtcbiAgcmV0dXJuIGNvcHlSZXN1bHQ7XG59O1xuXG5wcm90by5saXN0ID0gYXN5bmMgZnVuY3Rpb24gbGlzdChxdWVyeSwgb3B0aW9ucykge1xuICAvLyBwcmVmaXgsIG1hcmtlciwgbWF4LWtleXMsIGRlbGltaXRlclxuXG4gIGNvbnN0IHBhcmFtcyA9IHRoaXMuX29iamVjdFJlcXVlc3RQYXJhbXMoJ0dFVCcsICcnLCBvcHRpb25zKTtcbiAgcGFyYW1zLnF1ZXJ5ID0gcXVlcnk7XG4gIHBhcmFtcy54bWxSZXNwb25zZSA9IHRydWU7XG4gIHBhcmFtcy5zdWNjZXNzU3RhdHVzZXMgPSBbMjAwXTtcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3QocGFyYW1zKTtcbiAgbGV0IG9iamVjdHMgPSByZXN1bHQuZGF0YS5Db250ZW50cztcbiAgY29uc3QgdGhhdCA9IHRoaXM7XG4gIGlmIChvYmplY3RzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdHMpKSB7XG4gICAgICBvYmplY3RzID0gW29iamVjdHNdO1xuICAgIH1cbiAgICBvYmplY3RzID0gb2JqZWN0cy5tYXAob2JqID0+ICh7XG4gICAgICBuYW1lOiBvYmouS2V5LFxuICAgICAgdXJsOiB0aGF0Ll9vYmplY3RVcmwob2JqLktleSksXG4gICAgICBsYXN0TW9kaWZpZWQ6IG9iai5MYXN0TW9kaWZpZWQsXG4gICAgICBldGFnOiBvYmouRVRhZyxcbiAgICAgIHR5cGU6IG9iai5UeXBlLFxuICAgICAgc2l6ZTogTnVtYmVyKG9iai5TaXplKSxcbiAgICAgIHN0b3JhZ2VDbGFzczogb2JqLlN0b3JhZ2VDbGFzcyxcbiAgICAgIG93bmVyOiB7XG4gICAgICAgIGlkOiBvYmouT3duZXIuSUQsXG4gICAgICAgIGRpc3BsYXlOYW1lOiBvYmouT3duZXIuRGlzcGxheU5hbWVcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgbGV0IHByZWZpeGVzID0gcmVzdWx0LmRhdGEuQ29tbW9uUHJlZml4ZXMgfHwgbnVsbDtcbiAgaWYgKHByZWZpeGVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByZWZpeGVzKSkge1xuICAgICAgcHJlZml4ZXMgPSBbcHJlZml4ZXNdO1xuICAgIH1cbiAgICBwcmVmaXhlcyA9IHByZWZpeGVzLm1hcChpdGVtID0+IGl0ZW0uUHJlZml4KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlczogcmVzdWx0LnJlcyxcbiAgICBvYmplY3RzLFxuICAgIHByZWZpeGVzLFxuICAgIG5leHRNYXJrZXI6IHJlc3VsdC5kYXRhLk5leHRNYXJrZXIgfHwgbnVsbCxcbiAgICBpc1RydW5jYXRlZDogcmVzdWx0LmRhdGEuSXNUcnVuY2F0ZWQgPT09ICd0cnVlJ1xuICB9O1xufTtcblxuLypcbiAqIFNldCBvYmplY3QncyBBQ0xcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBvYmplY3Qga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gYWNsIHRoZSBvYmplY3QgQUNMXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5wcm90by5wdXRBQ0wgPSBhc3luYyBmdW5jdGlvbiBwdXRBQ0wobmFtZSwgYWNsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnN1YnJlcyA9ICdhY2wnO1xuICBvcHRpb25zLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gIG9wdGlvbnMuaGVhZGVyc1sneC1vc3Mtb2JqZWN0LWFjbCddID0gYWNsO1xuICBuYW1lID0gdGhpcy5fb2JqZWN0TmFtZShuYW1lKTtcblxuICBjb25zdCBwYXJhbXMgPSB0aGlzLl9vYmplY3RSZXF1ZXN0UGFyYW1zKCdQVVQnLCBuYW1lLCBvcHRpb25zKTtcbiAgcGFyYW1zLnN1Y2Nlc3NTdGF0dXNlcyA9IFsyMDBdO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdChwYXJhbXMpO1xuXG4gIHJldHVybiB7XG4gICAgcmVzOiByZXN1bHQucmVzXG4gIH07XG59O1xuXG4vKlxuICogR2V0IG9iamVjdCdzIEFDTFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG9iamVjdCBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnByb3RvLmdldEFDTCA9IGFzeW5jIGZ1bmN0aW9uIGdldEFDTChuYW1lLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnN1YnJlcyA9ICdhY2wnO1xuICBuYW1lID0gdGhpcy5fb2JqZWN0TmFtZShuYW1lKTtcblxuICBjb25zdCBwYXJhbXMgPSB0aGlzLl9vYmplY3RSZXF1ZXN0UGFyYW1zKCdHRVQnLCBuYW1lLCBvcHRpb25zKTtcbiAgcGFyYW1zLnN1Y2Nlc3NTdGF0dXNlcyA9IFsyMDBdO1xuICBwYXJhbXMueG1sUmVzcG9uc2UgPSB0cnVlO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxdWVzdChwYXJhbXMpO1xuXG4gIHJldHVybiB7XG4gICAgYWNsOiByZXN1bHQuZGF0YS5BY2Nlc3NDb250cm9sTGlzdC5HcmFudCxcbiAgICBvd25lcjoge1xuICAgICAgaWQ6IHJlc3VsdC5kYXRhLk93bmVyLklELFxuICAgICAgZGlzcGxheU5hbWU6IHJlc3VsdC5kYXRhLk93bmVyLkRpc3BsYXlOYW1lXG4gICAgfSxcbiAgICByZXM6IHJlc3VsdC5yZXNcbiAgfTtcbn07XG5cbi8qKlxuICogUmVzdG9yZSBPYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBvYmplY3Qga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge3tyZXN9fVxuICovXG5wcm90by5yZXN0b3JlID0gYXN5bmMgZnVuY3Rpb24gcmVzdG9yZShuYW1lLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnN1YnJlcyA9ICdyZXN0b3JlJztcbiAgY29uc3QgcGFyYW1zID0gdGhpcy5fb2JqZWN0UmVxdWVzdFBhcmFtcygnUE9TVCcsIG5hbWUsIG9wdGlvbnMpO1xuICBwYXJhbXMuc3VjY2Vzc1N0YXR1c2VzID0gWzIwMl07XG5cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHBhcmFtcyk7XG5cbiAgcmV0dXJuIHtcbiAgICByZXM6IHJlc3VsdC5yZXNcbiAgfTtcbn07XG5cbnByb3RvLnNpZ25hdHVyZVVybCA9IGZ1bmN0aW9uIHNpZ25hdHVyZVVybChuYW1lLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBuYW1lID0gdGhpcy5fb2JqZWN0TmFtZShuYW1lKTtcbiAgb3B0aW9ucy5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJztcbiAgY29uc3QgZXhwaXJlcyA9IHV0aWxpdHkudGltZXN0YW1wKCkgKyAob3B0aW9ucy5leHBpcmVzIHx8IDE4MDApO1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgYnVja2V0OiB0aGlzLm9wdGlvbnMuYnVja2V0LFxuICAgIG9iamVjdDogbmFtZVxuICB9O1xuXG4gIGNvbnN0IHJlc291cmNlID0gdGhpcy5fZ2V0UmVzb3VyY2UocGFyYW1zKTtcblxuICBpZiAodGhpcy5vcHRpb25zLnN0c1Rva2VuKSB7XG4gICAgb3B0aW9uc1snc2VjdXJpdHktdG9rZW4nXSA9IHRoaXMub3B0aW9ucy5zdHNUb2tlbjtcbiAgfVxuXG4gIGNvbnN0IHNpZ25SZXMgPSBzaWduSGVscGVyLl9zaWduYXR1cmVGb3JVUkwodGhpcy5vcHRpb25zLmFjY2Vzc0tleVNlY3JldCwgb3B0aW9ucywgcmVzb3VyY2UsIGV4cGlyZXMpO1xuXG4gIGNvbnN0IHVybCA9IHVybHV0aWwucGFyc2UodGhpcy5fZ2V0UmVxVXJsKHBhcmFtcykpO1xuICB1cmwucXVlcnkgPSB7XG4gICAgT1NTQWNjZXNzS2V5SWQ6IHRoaXMub3B0aW9ucy5hY2Nlc3NLZXlJZCxcbiAgICBFeHBpcmVzOiBleHBpcmVzLFxuICAgIFNpZ25hdHVyZTogc2lnblJlcy5TaWduYXR1cmVcbiAgfTtcblxuICBjb3B5KHNpZ25SZXMuc3ViUmVzb3VyY2UpLnRvKHVybC5xdWVyeSk7XG5cbiAgcmV0dXJuIHVybC5mb3JtYXQoKTtcbn07XG5cbi8qKlxuICogR2V0IE9iamVjdCB1cmwgYnkgbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBvYmplY3QgbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlVXJsXSAtIElmIHByb3ZpZGUgYGJhc2VVcmxgLFxuICogICAgICAgIHdpbGwgdXNlIGBiYXNlVXJsYCBpbnN0ZWFkIHRoZSBkZWZhdWx0IGBlbmRwb2ludGAuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG9iamVjdCB1cmxcbiAqL1xucHJvdG8uZ2V0T2JqZWN0VXJsID0gZnVuY3Rpb24gZ2V0T2JqZWN0VXJsKG5hbWUsIGJhc2VVcmwpIHtcbiAgaWYgKCFiYXNlVXJsKSB7XG4gICAgYmFzZVVybCA9IHRoaXMub3B0aW9ucy5lbmRwb2ludC5mb3JtYXQoKTtcbiAgfSBlbHNlIGlmIChiYXNlVXJsW2Jhc2VVcmwubGVuZ3RoIC0gMV0gIT09ICcvJykge1xuICAgIGJhc2VVcmwgKz0gJy8nO1xuICB9XG4gIHJldHVybiBiYXNlVXJsICsgdGhpcy5fZXNjYXBlKHRoaXMuX29iamVjdE5hbWUobmFtZSkpO1xufTtcblxucHJvdG8uX29iamVjdFVybCA9IGZ1bmN0aW9uIF9vYmplY3RVcmwobmFtZSkge1xuICByZXR1cm4gdGhpcy5fZ2V0UmVxVXJsKHsgYnVja2V0OiB0aGlzLm9wdGlvbnMuYnVja2V0LCBvYmplY3Q6IG5hbWUgfSk7XG59O1xuXG4vKipcbiAqIEdldCBPYmplY3QgdXJsIGJ5IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gb2JqZWN0IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVVybF0gLSBJZiBwcm92aWRlIGBiYXNlVXJsYCwgd2lsbCB1c2UgYGJhc2VVcmxgIGluc3RlYWQgdGhlIGRlZmF1bHQgYGVuZHBvaW50IGFuZCBidWNrZXRgLlxuICogQHJldHVybiB7U3RyaW5nfSBvYmplY3QgdXJsIGluY2x1ZGUgYnVja2V0XG4gKi9cbnByb3RvLmdlbmVyYXRlT2JqZWN0VXJsID0gZnVuY3Rpb24gKG5hbWUsIGJhc2VVcmwpIHtcbiAgaWYgKCFiYXNlVXJsKSB7XG4gICAgYmFzZVVybCA9IHRoaXMub3B0aW9ucy5lbmRwb2ludC5mb3JtYXQoKTtcbiAgICBjb25zdCBjb3B5VXJsID0gdXJsdXRpbC5wYXJzZShiYXNlVXJsKTtcbiAgICBjb25zdCB7IGJ1Y2tldCB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgY29weVVybC5ob3N0bmFtZSA9IGAke2J1Y2tldH0uJHtjb3B5VXJsLmhvc3RuYW1lfWA7XG4gICAgY29weVVybC5ob3N0ID0gYCR7YnVja2V0fS4ke2NvcHlVcmwuaG9zdH1gO1xuICAgIGJhc2VVcmwgPSBjb3B5VXJsLmZvcm1hdCgpO1xuICB9IGVsc2UgaWYgKGJhc2VVcmxbYmFzZVVybC5sZW5ndGggLSAxXSAhPT0gJy8nKSB7XG4gICAgYmFzZVVybCArPSAnLyc7XG4gIH1cbiAgcmV0dXJuIGJhc2VVcmwgKyB0aGlzLl9lc2NhcGUodGhpcy5fb2JqZWN0TmFtZShuYW1lKSk7XG59O1xuXG5cbi8qKlxuICogZ2VuZXJhdG9yIHJlcXVlc3QgcGFyYW1zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhcmFtc1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnByb3RvLl9vYmplY3RSZXF1ZXN0UGFyYW1zID0gZnVuY3Rpb24gX29iamVjdFJlcXVlc3RQYXJhbXMobWV0aG9kLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmICghdGhpcy5vcHRpb25zLmJ1Y2tldCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNyZWF0ZSBhIGJ1Y2tldCBmaXJzdCcpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG5hbWUgPSB0aGlzLl9vYmplY3ROYW1lKG5hbWUpO1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgb2JqZWN0OiBuYW1lLFxuICAgIGJ1Y2tldDogdGhpcy5vcHRpb25zLmJ1Y2tldCxcbiAgICBtZXRob2QsXG4gICAgc3VicmVzOiBvcHRpb25zICYmIG9wdGlvbnMuc3VicmVzLFxuICAgIHRpbWVvdXQ6IG9wdGlvbnMgJiYgb3B0aW9ucy50aW1lb3V0LFxuICAgIGN0eDogb3B0aW9ucyAmJiBvcHRpb25zLmN0eFxuICB9O1xuXG4gIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBwYXJhbXMuaGVhZGVycyA9IHt9O1xuICAgIGNvcHkob3B0aW9ucy5oZWFkZXJzKS50byhwYXJhbXMuaGVhZGVycyk7XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cbnByb3RvLl9vYmplY3ROYW1lID0gZnVuY3Rpb24gX29iamVjdE5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC9eXFwvKy8sICcnKTtcbn07XG5cbnByb3RvLl9zdGF0RmlsZSA9IGZ1bmN0aW9uIF9zdGF0RmlsZShmaWxlcGF0aCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLnN0YXQoZmlsZXBhdGgsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShzdGF0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxucHJvdG8uX2NvbnZlcnRNZXRhVG9IZWFkZXJzID0gZnVuY3Rpb24gX2NvbnZlcnRNZXRhVG9IZWFkZXJzKG1ldGEsIGhlYWRlcnMpIHtcbiAgaWYgKCFtZXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmtleXMobWV0YSkuZm9yRWFjaCgoaykgPT4ge1xuICAgIGhlYWRlcnNbYHgtb3NzLW1ldGEtJHtrfWBdID0gbWV0YVtrXTtcbiAgfSk7XG59O1xuXG5wcm90by5fZGVsZXRlRmlsZVNhZmUgPSBmdW5jdGlvbiBfZGVsZXRlRmlsZVNhZmUoZmlsZXBhdGgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgZnMuZXhpc3RzKGZpbGVwYXRoLCAoZXhpc3RzKSA9PiB7XG4gICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcy51bmxpbmsoZmlsZXBhdGgsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCd1bmxpbmsgJWogZXJyb3I6ICVzJywgZmlsZXBhdGgsIGVyciwgJ2Vycm9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsImV4cG9ydHMudmVyc2lvbj1cIjYuMS4xXCIiLCJcblxuZXhwb3J0cy5lbmNvZGVDYWxsYmFjayA9IGZ1bmN0aW9uIGVuY29kZUNhbGxiYWNrKHJlcVBhcmFtcywgb3B0aW9ucykge1xuICByZXFQYXJhbXMuaGVhZGVycyA9IHJlcVBhcmFtcy5oZWFkZXJzIHx8IHt9O1xuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXFQYXJhbXMuaGVhZGVycywgJ3gtb3NzLWNhbGxiYWNrJykpIHtcbiAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgY2FsbGJhY2tVcmw6IGVuY29kZVVSSShvcHRpb25zLmNhbGxiYWNrLnVybCksXG4gICAgICAgIGNhbGxiYWNrQm9keTogb3B0aW9ucy5jYWxsYmFjay5ib2R5XG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2suaG9zdCkge1xuICAgICAgICBqc29uLmNhbGxiYWNrSG9zdCA9IG9wdGlvbnMuY2FsbGJhY2suaG9zdDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgIGpzb24uY2FsbGJhY2tCb2R5VHlwZSA9IG9wdGlvbnMuY2FsbGJhY2suY29udGVudFR5cGU7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWxsYmFjayA9IG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoanNvbikpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIHJlcVBhcmFtcy5oZWFkZXJzWyd4LW9zcy1jYWxsYmFjayddID0gY2FsbGJhY2s7XG5cbiAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrLmN1c3RvbVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrVmFyID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuY2FsbGJhY2suY3VzdG9tVmFsdWUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrVmFyW2B4OiR7a2V5fWBdID0gb3B0aW9ucy5jYWxsYmFjay5jdXN0b21WYWx1ZVtrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxUGFyYW1zLmhlYWRlcnNbJ3gtb3NzLWNhbGxiYWNrLXZhciddID0gbmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShjYWxsYmFja1ZhcikpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iLCJcbmNvbnN0IGNvcHkgPSByZXF1aXJlKCdjb3B5LXRvJyk7XG5jb25zdCBjYWxsYmFjayA9IHJlcXVpcmUoJy4vY2FsbGJhY2snKTtcblxuY29uc3QgcHJvdG8gPSBleHBvcnRzO1xuXG5cbi8qKlxuICogTGlzdCB0aGUgb24tZ29pbmcgbXVsdGlwYXJ0IHVwbG9hZHNcbiAqIGh0dHBzOi8vaGVscC5hbGl5dW4uY29tL2RvY3VtZW50X2RldGFpbC8zMTk5Ny5odG1sXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7QXJyYXl9IHRoZSBtdWx0aXBhcnQgdXBsb2Fkc1xuICovXG5wcm90by5saXN0VXBsb2FkcyA9IGFzeW5jIGZ1bmN0aW9uIGxpc3RVcGxvYWRzKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBvcHQgPSB7fTtcbiAgY29weShvcHRpb25zKS50byhvcHQpO1xuICBvcHQuc3VicmVzID0gJ3VwbG9hZHMnO1xuICBjb25zdCBwYXJhbXMgPSB0aGlzLl9vYmplY3RSZXF1ZXN0UGFyYW1zKCdHRVQnLCAnJywgb3B0KTtcbiAgcGFyYW1zLnF1ZXJ5ID0gcXVlcnk7XG4gIHBhcmFtcy54bWxSZXNwb25zZSA9IHRydWU7XG4gIHBhcmFtcy5zdWNjZXNzU3RhdHVzZXMgPSBbMjAwXTtcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3QocGFyYW1zKTtcbiAgbGV0IHVwbG9hZHMgPSByZXN1bHQuZGF0YS5VcGxvYWQgfHwgW107XG4gIGlmICghQXJyYXkuaXNBcnJheSh1cGxvYWRzKSkge1xuICAgIHVwbG9hZHMgPSBbdXBsb2Fkc107XG4gIH1cbiAgdXBsb2FkcyA9IHVwbG9hZHMubWFwKHVwID0+ICh7XG4gICAgbmFtZTogdXAuS2V5LFxuICAgIHVwbG9hZElkOiB1cC5VcGxvYWRJZCxcbiAgICBpbml0aWF0ZWQ6IHVwLkluaXRpYXRlZFxuICB9KSk7XG5cbiAgcmV0dXJuIHtcbiAgICByZXM6IHJlc3VsdC5yZXMsXG4gICAgdXBsb2FkcyxcbiAgICBidWNrZXQ6IHJlc3VsdC5kYXRhLkJ1Y2tldCxcbiAgICBuZXh0S2V5TWFya2VyOiByZXN1bHQuZGF0YS5OZXh0S2V5TWFya2VyLFxuICAgIG5leHRVcGxvYWRJZE1hcmtlcjogcmVzdWx0LmRhdGEuTmV4dFVwbG9hZElkTWFya2VyLFxuICAgIGlzVHJ1bmNhdGVkOiByZXN1bHQuZGF0YS5Jc1RydW5jYXRlZCA9PT0gJ3RydWUnXG4gIH07XG59O1xuXG4vKipcbiAqIExpc3QgdGhlIGRvbmUgdXBsb2FkUGFydCBwYXJ0c1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2JqZWN0IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cGxvYWRJZCBtdWx0aXBhcnQgdXBsb2FkIGlkXG4gKiBAcGFyYW0ge09iamVjdH0gcXVlcnlcbiAqIHtOdW1iZXJ9IHF1ZXJ5Lm1heC1wYXJ0cyBUaGUgbWF4aW11bSBwYXJ0IG51bWJlciBpbiB0aGUgcmVzcG9uc2Ugb2YgdGhlIE9TUy4gRGVmYXVsdCB2YWx1ZTogMTAwMFxuICoge051bWJlcn0gcXVlcnkucGFydC1udW1iZXItbWFya2VyIFN0YXJ0aW5nIHBvc2l0aW9uIG9mIGEgc3BlY2lmaWMgbGlzdC5cbiAqIHtTdHJpbmd9IHF1ZXJ5LmVuY29kaW5nLXR5cGUgU3BlY2lmeSB0aGUgZW5jb2Rpbmcgb2YgdGhlIHJldHVybmVkIGNvbnRlbnQgYW5kIHRoZSBlbmNvZGluZyB0eXBlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0XG4gKi9cbnByb3RvLmxpc3RQYXJ0cyA9IGFzeW5jIGZ1bmN0aW9uIGxpc3RQYXJ0cyhuYW1lLCB1cGxvYWRJZCwgcXVlcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG9wdCA9IHt9O1xuICBjb3B5KG9wdGlvbnMpLnRvKG9wdCk7XG4gIG9wdC5zdWJyZXMgPSB7XG4gICAgdXBsb2FkSWRcbiAgfTtcbiAgY29uc3QgcGFyYW1zID0gdGhpcy5fb2JqZWN0UmVxdWVzdFBhcmFtcygnR0VUJywgbmFtZSwgb3B0KTtcbiAgcGFyYW1zLnF1ZXJ5ID0gcXVlcnk7XG4gIHBhcmFtcy54bWxSZXNwb25zZSA9IHRydWU7XG4gIHBhcmFtcy5zdWNjZXNzU3RhdHVzZXMgPSBbMjAwXTtcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3QocGFyYW1zKTtcblxuICByZXR1cm4ge1xuICAgIHJlczogcmVzdWx0LnJlcyxcbiAgICB1cGxvYWRJZDogcmVzdWx0LmRhdGEuVXBsb2FkSWQsXG4gICAgYnVja2V0OiByZXN1bHQuZGF0YS5CdWNrZXQsXG4gICAgbmFtZTogcmVzdWx0LmRhdGEuS2V5LFxuICAgIHBhcnROdW1iZXJNYXJrZXI6IHJlc3VsdC5kYXRhLlBhcnROdW1iZXJNYXJrZXIsXG4gICAgbmV4dFBhcnROdW1iZXJNYXJrZXI6IHJlc3VsdC5kYXRhLk5leHRQYXJ0TnVtYmVyTWFya2VyLFxuICAgIG1heFBhcnRzOiByZXN1bHQuZGF0YS5NYXhQYXJ0cyxcbiAgICBpc1RydW5jYXRlZDogcmVzdWx0LmRhdGEuSXNUcnVuY2F0ZWQsXG4gICAgcGFydHM6IHJlc3VsdC5kYXRhLlBhcnQgfHwgW11cbiAgfTtcbn07XG5cbi8qKlxuICogQWJvcnQgYSBtdWx0aXBhcnQgdXBsb2FkIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgb2JqZWN0IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cGxvYWRJZCB0aGUgdXBsb2FkIGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5wcm90by5hYm9ydE11bHRpcGFydFVwbG9hZCA9IGFzeW5jIGZ1bmN0aW9uIGFib3J0TXVsdGlwYXJ0VXBsb2FkKG5hbWUsIHVwbG9hZElkLCBvcHRpb25zKSB7XG4gIHRoaXMuX3N0b3AoKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG9wdCA9IHt9O1xuICBjb3B5KG9wdGlvbnMpLnRvKG9wdCk7XG4gIG9wdC5zdWJyZXMgPSB7IHVwbG9hZElkIH07XG4gIGNvbnN0IHBhcmFtcyA9IHRoaXMuX29iamVjdFJlcXVlc3RQYXJhbXMoJ0RFTEVURScsIG5hbWUsIG9wdCk7XG4gIHBhcmFtcy5zdWNjZXNzU3RhdHVzZXMgPSBbMjA0XTtcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3QocGFyYW1zKTtcbiAgcmV0dXJuIHtcbiAgICByZXM6IHJlc3VsdC5yZXNcbiAgfTtcbn07XG5cbi8qKlxuICogSW5pdGlhdGUgYSBtdWx0aXBhcnQgdXBsb2FkIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgb2JqZWN0IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHVwbG9hZCBpZFxuICovXG5wcm90by5pbml0TXVsdGlwYXJ0VXBsb2FkID0gYXN5bmMgZnVuY3Rpb24gaW5pdE11bHRpcGFydFVwbG9hZChuYW1lLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBvcHQgPSB7fTtcbiAgY29weShvcHRpb25zKS50byhvcHQpO1xuICBvcHQuaGVhZGVycyA9IG9wdC5oZWFkZXJzIHx8IHt9O1xuICB0aGlzLl9jb252ZXJ0TWV0YVRvSGVhZGVycyhvcHRpb25zLm1ldGEsIG9wdC5oZWFkZXJzKTtcblxuICBvcHQuc3VicmVzID0gJ3VwbG9hZHMnO1xuICBjb25zdCBwYXJhbXMgPSB0aGlzLl9vYmplY3RSZXF1ZXN0UGFyYW1zKCdQT1NUJywgbmFtZSwgb3B0KTtcbiAgcGFyYW1zLm1pbWUgPSBvcHRpb25zLm1pbWU7XG4gIHBhcmFtcy54bWxSZXNwb25zZSA9IHRydWU7XG4gIHBhcmFtcy5zdWNjZXNzU3RhdHVzZXMgPSBbMjAwXTtcblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3QocGFyYW1zKTtcblxuICByZXR1cm4ge1xuICAgIHJlczogcmVzdWx0LnJlcyxcbiAgICBidWNrZXQ6IHJlc3VsdC5kYXRhLkJ1Y2tldCxcbiAgICBuYW1lOiByZXN1bHQuZGF0YS5LZXksXG4gICAgdXBsb2FkSWQ6IHJlc3VsdC5kYXRhLlVwbG9hZElkXG4gIH07XG59O1xuXG4vKipcbiAqIFVwbG9hZCBhIHBhcnQgaW4gYSBtdWx0aXBhcnQgdXBsb2FkIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgb2JqZWN0IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cGxvYWRJZCB0aGUgdXBsb2FkIGlkXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHBhcnRObyB0aGUgcGFydCBudW1iZXJcbiAqIEBwYXJhbSB7RmlsZX0gZmlsZSB1cGxvYWQgRmlsZSwgd2hvbGUgRmlsZVxuICogQHBhcmFtIHtJbnRlZ2VyfSBzdGFydCAgcGFydCBzdGFydCBieXRlcyAgZS5nOiAxMDI0MDBcbiAqIEBwYXJhbSB7SW50ZWdlcn0gZW5kICBwYXJ0IGVuZCBieXRlcyAgZS5nOiAyMDQ4MDBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbnByb3RvLnVwbG9hZFBhcnQgPSBhc3luYyBmdW5jdGlvbiB1cGxvYWRQYXJ0KG5hbWUsIHVwbG9hZElkLCBwYXJ0Tm8sIGZpbGUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICBzdHJlYW06IHRoaXMuX2NyZWF0ZVN0cmVhbShmaWxlLCBzdGFydCwgZW5kKSxcbiAgICBzaXplOiBlbmQgLSBzdGFydFxuICB9O1xuICByZXR1cm4gYXdhaXQgdGhpcy5fdXBsb2FkUGFydChuYW1lLCB1cGxvYWRJZCwgcGFydE5vLCBkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ29tcGxldGUgYSBtdWx0aXBhcnQgdXBsb2FkIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgb2JqZWN0IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cGxvYWRJZCB0aGUgdXBsb2FkIGlkXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0cyB0aGUgdXBsb2FkZWQgcGFydHMsIGVhY2ggaW4gdGhlIHN0cnVjdHVyZTpcbiAqICAgICAgICB7SW50ZWdlcn0gbnVtYmVyIHBhcnROb1xuICogICAgICAgIHtTdHJpbmd9IGV0YWcgIHBhcnQgZXRhZyAgdXBsb2FkUGFydENvcHkgcmVzdWx0LnJlcy5oZWFkZXIuZXRhZ1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAge09iamVjdH0gb3B0aW9ucy5jYWxsYmFjayBUaGUgY2FsbGJhY2sgcGFyYW1ldGVyIGlzIGNvbXBvc2VkIG9mIGEgSlNPTiBzdHJpbmcgZW5jb2RlZCBpbiBCYXNlNjRcbiAqICAgICAgICAge1N0cmluZ30gb3B0aW9ucy5jYWxsYmFjay51cmwgIHRoZSBPU1Mgc2VuZHMgYSBjYWxsYmFjayByZXF1ZXN0IHRvIHRoaXMgVVJMXG4gKiAgICAgICAgIHtTdHJpbmd9IG9wdGlvbnMuY2FsbGJhY2suaG9zdCAgVGhlIGhvc3QgaGVhZGVyIHZhbHVlIGZvciBpbml0aWF0aW5nIGNhbGxiYWNrIHJlcXVlc3RzXG4gKiAgICAgICAgIHtTdHJpbmd9IG9wdGlvbnMuY2FsbGJhY2suYm9keSAgVGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN0IGJvZHkgd2hlbiBhIGNhbGxiYWNrIGlzIGluaXRpYXRlZFxuICogICAgICAgICB7U3RyaW5nfSBvcHRpb25zLmNhbGxiYWNrLmNvbnRlbnRUeXBlICBUaGUgQ29udGVudC1UeXBlIG9mIHRoZSBjYWxsYmFjayByZXF1ZXN0cyBpbml0aWF0aWF0ZWRcbiAqICAgICAgICAge09iamVjdH0gb3B0aW9ucy5jYWxsYmFjay5jdXN0b21WYWx1ZSAgQ3VzdG9tIHBhcmFtZXRlcnMgYXJlIGEgbWFwIG9mIGtleS12YWx1ZXMsIGUuZzpcbiAqICAgICAgICAgICAgICAgICAgIGN1c3RvbVZhbHVlID0ge1xuICogICAgICAgICAgICAgICAgICAgICBrZXkxOiAndmFsdWUxJyxcbiAqICAgICAgICAgICAgICAgICAgICAga2V5MjogJ3ZhbHVlMidcbiAqICAgICAgICAgICAgICAgICAgIH1cbiAqL1xucHJvdG8uY29tcGxldGVNdWx0aXBhcnRVcGxvYWQgPSBhc3luYyBmdW5jdGlvbiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZChuYW1lLCB1cGxvYWRJZCwgcGFydHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29tcGxldGVQYXJ0cyA9IHBhcnRzLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IGEubnVtYmVyIC0gYi5udW1iZXIpXG4gICAgLmZpbHRlcigoaXRlbSwgaW5kZXgsIGFycikgPT4gIWluZGV4IHx8IGl0ZW0ubnVtYmVyICE9PSBhcnJbaW5kZXggLSAxXS5udW1iZXIpO1xuICBsZXQgeG1sID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/PlxcbjxDb21wbGV0ZU11bHRpcGFydFVwbG9hZD5cXG4nO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBsZXRlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwID0gY29tcGxldGVQYXJ0c1tpXTtcbiAgICB4bWwgKz0gJzxQYXJ0Plxcbic7XG4gICAgeG1sICs9IGA8UGFydE51bWJlcj4ke3AubnVtYmVyfTwvUGFydE51bWJlcj5cXG5gO1xuICAgIHhtbCArPSBgPEVUYWc+JHtwLmV0YWd9PC9FVGFnPlxcbmA7XG4gICAgeG1sICs9ICc8L1BhcnQ+XFxuJztcbiAgfVxuICB4bWwgKz0gJzwvQ29tcGxldGVNdWx0aXBhcnRVcGxvYWQ+JztcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgb3B0ID0ge307XG4gIGNvcHkob3B0aW9ucykudG8ob3B0KTtcbiAgb3B0LnN1YnJlcyA9IHsgdXBsb2FkSWQgfTtcblxuICBjb25zdCBwYXJhbXMgPSB0aGlzLl9vYmplY3RSZXF1ZXN0UGFyYW1zKCdQT1NUJywgbmFtZSwgb3B0KTtcbiAgY2FsbGJhY2suZW5jb2RlQ2FsbGJhY2socGFyYW1zLCBvcHQpO1xuICBwYXJhbXMubWltZSA9ICd4bWwnO1xuICBwYXJhbXMuY29udGVudCA9IHhtbDtcblxuICBpZiAoIShwYXJhbXMuaGVhZGVycyAmJiBwYXJhbXMuaGVhZGVyc1sneC1vc3MtY2FsbGJhY2snXSkpIHtcbiAgICBwYXJhbXMueG1sUmVzcG9uc2UgPSB0cnVlO1xuICB9XG4gIHBhcmFtcy5zdWNjZXNzU3RhdHVzZXMgPSBbMjAwXTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHBhcmFtcyk7XG5cbiAgY29uc3QgcmV0ID0ge1xuICAgIHJlczogcmVzdWx0LnJlcyxcbiAgICBidWNrZXQ6IHBhcmFtcy5idWNrZXQsXG4gICAgbmFtZSxcbiAgICBldGFnOiByZXN1bHQucmVzLmhlYWRlcnMuZXRhZ1xuICB9O1xuXG4gIGlmIChwYXJhbXMuaGVhZGVycyAmJiBwYXJhbXMuaGVhZGVyc1sneC1vc3MtY2FsbGJhY2snXSkge1xuICAgIHJldC5kYXRhID0gSlNPTi5wYXJzZShyZXN1bHQuZGF0YS50b1N0cmluZygpKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFVwbG9hZCBhIHBhcnQgaW4gYSBtdWx0aXBhcnQgdXBsb2FkIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgb2JqZWN0IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cGxvYWRJZCB0aGUgdXBsb2FkIGlkXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHBhcnRObyB0aGUgcGFydCBudW1iZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHRoZSBib2R5IGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbnByb3RvLl91cGxvYWRQYXJ0ID0gYXN5bmMgZnVuY3Rpb24gX3VwbG9hZFBhcnQobmFtZSwgdXBsb2FkSWQsIHBhcnRObywgZGF0YSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgb3B0ID0ge307XG4gIGNvcHkob3B0aW9ucykudG8ob3B0KTtcbiAgb3B0LmhlYWRlcnMgPSB7XG4gICAgJ0NvbnRlbnQtTGVuZ3RoJzogZGF0YS5zaXplXG4gIH07XG5cbiAgb3B0LnN1YnJlcyA9IHtcbiAgICBwYXJ0TnVtYmVyOiBwYXJ0Tm8sXG4gICAgdXBsb2FkSWRcbiAgfTtcbiAgY29uc3QgcGFyYW1zID0gdGhpcy5fb2JqZWN0UmVxdWVzdFBhcmFtcygnUFVUJywgbmFtZSwgb3B0KTtcbiAgcGFyYW1zLm1pbWUgPSBvcHQubWltZTtcbiAgcGFyYW1zLnN0cmVhbSA9IGRhdGEuc3RyZWFtO1xuICBwYXJhbXMuc3VjY2Vzc1N0YXR1c2VzID0gWzIwMF07XG5cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHBhcmFtcyk7XG5cbiAgZGF0YS5zdHJlYW0gPSBudWxsO1xuICBwYXJhbXMuc3RyZWFtID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIGV0YWc6IHJlc3VsdC5yZXMuaGVhZGVycy5ldGFnLFxuICAgIHJlczogcmVzdWx0LnJlc1xuICB9O1xufTtcbiIsIlxuY29uc3QgcHJvdG8gPSBleHBvcnRzO1xuXG5wcm90by5fcGFyYWxsZWxOb2RlID0gYXN5bmMgZnVuY3Rpb24gX3BhcmFsbGVsTm9kZSh0b2RvLCBwYXJhbGxlbCwgZm4sIHNvdXJjZURhdGEpIHtcbiAgY29uc3QgdGhhdCA9IHRoaXM7XG4gIC8vIHVwbG9hZCBpbiBwYXJhbGxlbFxuICBjb25zdCBqb2JFcnIgPSBbXTtcbiAgbGV0IGpvYnMgPSBbXTtcbiAgY29uc3QgdGVtcEJhdGNoID0gdG9kby5sZW5ndGggLyBwYXJhbGxlbDtcbiAgY29uc3QgcmVtYWluZGVyID0gdG9kby5sZW5ndGggJSBwYXJhbGxlbDtcbiAgY29uc3QgYmF0Y2ggPSByZW1haW5kZXIgPT09IDAgPyB0ZW1wQmF0Y2ggOiAoKHRvZG8ubGVuZ3RoIC0gcmVtYWluZGVyKSAvIHBhcmFsbGVsKSArIDE7XG4gIGxldCB0YXNrSW5kZXggPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvZG8ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhhdC5pc0NhbmNlbCgpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc291cmNlRGF0YSkge1xuICAgICAgam9icy5wdXNoKGZuKHRoYXQsIHRvZG9baV0sIHNvdXJjZURhdGEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgam9icy5wdXNoKGZuKHRoYXQsIHRvZG9baV0pKTtcbiAgICB9XG5cbiAgICBpZiAoam9icy5sZW5ndGggPT09IHBhcmFsbGVsIHx8ICh0YXNrSW5kZXggPT09IGJhdGNoICYmIGkgPT09ICh0b2RvLmxlbmd0aCAtIDEpKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGFza0luZGV4ICs9IDE7XG4gICAgICAgIC8qIGVzbGludCBuby1hd2FpdC1pbi1sb29wOiBbMF0gKi9cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoam9icyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgam9iRXJyLnB1c2goZXJyKTtcbiAgICAgIH1cbiAgICAgIGpvYnMgPSBbXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gam9iRXJyO1xufTtcblxucHJvdG8uX3BhcmFsbGVsID0gZnVuY3Rpb24gX3BhcmFsbGVsKHRvZG8sIHBhcmFsbGVsLCBqb2JQcm9taXNlKSB7XG4gIGNvbnN0IHRoYXQgPSB0aGlzO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBfam9iRXJyID0gW107XG4gICAgaWYgKHBhcmFsbGVsIDw9IDAgfHwgIXRvZG8pIHtcbiAgICAgIHJlc29sdmUoX2pvYkVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25seU9uY2UoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAoZm4gPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLicpO1xuICAgICAgICBjb25zdCBjYWxsRm4gPSBmbjtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCkge1xuICAgICAgbGV0IGkgPSAtMTtcbiAgICAgIGNvbnN0IGxlbiA9IGNvbGwubGVuZ3RoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiAoKytpIDwgbGVuICYmICF0aGF0LmlzQ2FuY2VsKCkpID8geyB2YWx1ZTogY29sbFtpXSwga2V5OiBpIH0gOiBudWxsO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0RWxlbSA9IGNyZWF0ZUFycmF5SXRlcmF0b3IodG9kbyk7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBsZXQgcnVubmluZyA9IDA7XG4gICAgbGV0IGxvb3BpbmcgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVlQ2FsbGJhY2soZXJyLCB2YWx1ZSkge1xuICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgX2pvYkVyci5wdXNoKGVycik7XG4gICAgICAgIHJlc29sdmUoX2pvYkVycik7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB7fSB8fCAoZG9uZSAmJiBydW5uaW5nIDw9IDApKSB7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKF9qb2JFcnIpO1xuICAgICAgfSBlbHNlIGlmICghbG9vcGluZykge1xuICAgICAgICAvKiBlc2xpbnQgbm8tdXNlLWJlZm9yZS1kZWZpbmU6IFswXSAqL1xuICAgICAgICBpZiAodGhhdC5pc0NhbmNlbCgpKSB7XG4gICAgICAgICAgcmVzb2x2ZShfam9iRXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVlKHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgam9iUHJvbWlzZSh2YWx1ZSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsZW5pc2goKSB7XG4gICAgICBsb29waW5nID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChydW5uaW5nIDwgcGFyYWxsZWwgJiYgIWRvbmUgJiYgIXRoYXQuaXNDYW5jZWwoKSkge1xuICAgICAgICBjb25zdCBlbGVtID0gbmV4dEVsZW0oKTtcbiAgICAgICAgaWYgKGVsZW0gPT09IG51bGwgfHwgX2pvYkVyci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgaWYgKHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShfam9iRXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgaXRlcmF0ZWUoZWxlbS52YWx1ZSwgb25seU9uY2UoaXRlcmF0ZWVDYWxsYmFjaykpO1xuICAgICAgfVxuICAgICAgbG9vcGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJlcGxlbmlzaCgpO1xuICB9KTtcbn07XG5cbi8qKlxuICogY2FuY2VsIG9wZXJhdGlvbiwgbm93IGNhbiB1c2Ugd2l0aCBtdWx0aXBhcnRVcGxvYWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhYm9ydFxuICogICAgICAgIHtTdHJpbmd9IGFub3J0Lm5hbWUgb2JqZWN0IGtleVxuICogICAgICAgIHtTdHJpbmd9IGFub3J0LnVwbG9hZElkIHVwbG9hZCBpZFxuICogICAgICAgIHtTdHJpbmd9IGFub3J0Lm9wdGlvbnMgdGltZW91dFxuICovXG5wcm90by5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoYWJvcnQpIHtcbiAgdGhpcy5vcHRpb25zLmNhbmNlbEZsYWcgPSB0cnVlO1xuICBpZiAoYWJvcnQpIHtcbiAgICB0aGlzLmFib3J0TXVsdGlwYXJ0VXBsb2FkKGFib3J0Lm5hbWUsIGFib3J0LnVwbG9hZElkLCBhYm9ydC5vcHRpb25zKTtcbiAgfVxufTtcblxucHJvdG8uaXNDYW5jZWwgPSBmdW5jdGlvbiBpc0NhbmNlbCgpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5jYW5jZWxGbGFnO1xufTtcblxucHJvdG8ucmVzZXRDYW5jZWxGbGFnID0gZnVuY3Rpb24gcmVzZXRDYW5jZWxGbGFnKCkge1xuICB0aGlzLm9wdGlvbnMuY2FuY2VsRmxhZyA9IGZhbHNlO1xufTtcblxucHJvdG8uX3N0b3AgPSBmdW5jdGlvbiBfc3RvcCgpIHtcbiAgdGhpcy5vcHRpb25zLmNhbmNlbEZsYWcgPSB0cnVlO1xufTtcblxuLy8gY2FuY2VsIGlzIG5vdCBlcnJvciAsIHNvIGNyZWF0ZSBhbiBvYmplY3RcbnByb3RvLl9tYWtlQ2FuY2VsRXZlbnQgPSBmdW5jdGlvbiBfbWFrZUNhbmNlbEV2ZW50KCkge1xuICBjb25zdCBjYW5jZWxFdmVudCA9IHtcbiAgICBzdGF0dXM6IDAsXG4gICAgbmFtZTogJ2NhbmNlbCdcbiAgfTtcbiAgcmV0dXJuIGNhbmNlbEV2ZW50O1xufTtcbiIsIlxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBpcyA9IHJlcXVpcmUoJ2lzLXR5cGUtb2YnKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlc291cmNlUGF0aFxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5cbiAqL1xuZXhwb3J0cy5idWlsZENhbm9uaWNhbGl6ZWRSZXNvdXJjZSA9IGZ1bmN0aW9uIGJ1aWxkQ2Fub25pY2FsaXplZFJlc291cmNlKHJlc291cmNlUGF0aCwgcGFyYW1ldGVycykge1xuICBsZXQgY2Fub25pY2FsaXplZFJlc291cmNlID0gYCR7cmVzb3VyY2VQYXRofWA7XG4gIGxldCBzZXBhcmF0b3JTdHJpbmcgPSAnPyc7XG5cbiAgaWYgKGlzLnN0cmluZyhwYXJhbWV0ZXJzKSAmJiBwYXJhbWV0ZXJzLnRyaW0oKSAhPT0gJycpIHtcbiAgICBjYW5vbmljYWxpemVkUmVzb3VyY2UgKz0gc2VwYXJhdG9yU3RyaW5nICsgcGFyYW1ldGVycztcbiAgfSBlbHNlIGlmIChpcy5hcnJheShwYXJhbWV0ZXJzKSkge1xuICAgIHBhcmFtZXRlcnMuc29ydCgpO1xuICAgIGNhbm9uaWNhbGl6ZWRSZXNvdXJjZSArPSBzZXBhcmF0b3JTdHJpbmcgKyBwYXJhbWV0ZXJzLmpvaW4oJyYnKTtcbiAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgY29tcGFyZUZ1bmMgPSAoZW50cnkxLCBlbnRyeTIpID0+IHtcbiAgICAgIGlmIChlbnRyeTFbMF0gPiBlbnRyeTJbMF0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKGVudHJ5MVswXSA8IGVudHJ5MlswXSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NGdW5jID0gKGtleSkgPT4ge1xuICAgICAgY2Fub25pY2FsaXplZFJlc291cmNlICs9IHNlcGFyYXRvclN0cmluZyArIGtleTtcbiAgICAgIGlmIChwYXJhbWV0ZXJzW2tleV0pIHtcbiAgICAgICAgY2Fub25pY2FsaXplZFJlc291cmNlICs9IGA9JHtwYXJhbWV0ZXJzW2tleV19YDtcbiAgICAgIH1cbiAgICAgIHNlcGFyYXRvclN0cmluZyA9ICcmJztcbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpLnNvcnQoY29tcGFyZUZ1bmMpLmZvckVhY2gocHJvY2Vzc0Z1bmMpO1xuICB9XG5cbiAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRSZXNvdXJjZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHJlc291cmNlUGF0aFxuICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBpcmVzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGNhbm9uaWNhbFN0cmluZ1xuICovXG5leHBvcnRzLmJ1aWxkQ2Fub25pY2FsU3RyaW5nID0gZnVuY3Rpb24gY2Fub25pY2FsU3RyaW5nKG1ldGhvZCwgcmVzb3VyY2VQYXRoLCByZXF1ZXN0LCBleHBpcmVzKSB7XG4gIHJlcXVlc3QgPSByZXF1ZXN0IHx8IHt9O1xuICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzIHx8IHt9O1xuICBjb25zdCBPU1NfUFJFRklYID0gJ3gtb3NzLSc7XG4gIGNvbnN0IG9zc0hlYWRlcnMgPSBbXTtcbiAgY29uc3QgaGVhZGVyc1RvU2lnbiA9IHt9O1xuXG4gIGxldCBzaWduQ29udGVudCA9IFtcbiAgICBtZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICBoZWFkZXJzWydDb250ZW50LU1kNSddIHx8ICcnLFxuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddIHx8IGhlYWRlcnNbJ0NvbnRlbnQtVHlwZScudG9Mb3dlckNhc2UoKV0sXG4gICAgZXhwaXJlcyB8fCBoZWFkZXJzWyd4LW9zcy1kYXRlJ11cbiAgXTtcblxuICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBsb3dlcktleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlcktleS5pbmRleE9mKE9TU19QUkVGSVgpID09PSAwKSB7XG4gICAgICBoZWFkZXJzVG9TaWduW2xvd2VyS2V5XSA9IFN0cmluZyhoZWFkZXJzW2tleV0pLnRyaW0oKTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5rZXlzKGhlYWRlcnNUb1NpZ24pLnNvcnQoKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBvc3NIZWFkZXJzLnB1c2goYCR7a2V5fToke2hlYWRlcnNUb1NpZ25ba2V5XX1gKTtcbiAgfSk7XG5cbiAgc2lnbkNvbnRlbnQgPSBzaWduQ29udGVudC5jb25jYXQob3NzSGVhZGVycyk7XG5cbiAgc2lnbkNvbnRlbnQucHVzaCh0aGlzLmJ1aWxkQ2Fub25pY2FsaXplZFJlc291cmNlKHJlc291cmNlUGF0aCwgcmVxdWVzdC5wYXJhbWV0ZXJzKSk7XG5cbiAgcmV0dXJuIHNpZ25Db250ZW50LmpvaW4oJ1xcbicpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXNzS2V5U2VjcmV0XG4gKiBAcGFyYW0ge1N0cmluZ30gY2Fub25pY2FsU3RyaW5nXG4gKi9cbmV4cG9ydHMuY29tcHV0ZVNpZ25hdHVyZSA9IGZ1bmN0aW9uIGNvbXB1dGVTaWduYXR1cmUoYWNjZXNzS2V5U2VjcmV0LCBjYW5vbmljYWxTdHJpbmcpIHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTEnLCBhY2Nlc3NLZXlTZWNyZXQpO1xuICByZXR1cm4gc2lnbmF0dXJlLnVwZGF0ZShuZXcgQnVmZmVyKGNhbm9uaWNhbFN0cmluZywgJ3V0ZjgnKSkuZGlnZXN0KCdiYXNlNjQnKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2Vzc0tleUlkXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXNzS2V5U2VjcmV0XG4gKiBAcGFyYW0ge1N0cmluZ30gY2Fub25pY2FsU3RyaW5nXG4gKi9cbmV4cG9ydHMuYXV0aG9yaXphdGlvbiA9IGZ1bmN0aW9uIGF1dGhvcml6YXRpb24oYWNjZXNzS2V5SWQsIGFjY2Vzc0tleVNlY3JldCwgY2Fub25pY2FsU3RyaW5nKSB7XG4gIHJldHVybiBgT1NTICR7YWNjZXNzS2V5SWR9OiR7dGhpcy5jb21wdXRlU2lnbmF0dXJlKGFjY2Vzc0tleVNlY3JldCwgY2Fub25pY2FsU3RyaW5nKX1gO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2Vzc0tleVNlY3JldFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXNvdXJjZVxuICogQHBhcmFtIHtOdW1iZXJ9IGV4cGlyZXNcbiAqL1xuZXhwb3J0cy5fc2lnbmF0dXJlRm9yVVJMID0gZnVuY3Rpb24gX3NpZ25hdHVyZUZvclVSTChhY2Nlc3NLZXlTZWNyZXQsIG9wdGlvbnMsIHJlc291cmNlLCBleHBpcmVzKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgY29uc3Qgc3ViUmVzb3VyY2UgPSB7fTtcblxuICBpZiAob3B0aW9ucy5wcm9jZXNzKSB7XG4gICAgY29uc3QgcHJvY2Vzc0tleXdvcmQgPSAneC1vc3MtcHJvY2Vzcyc7XG4gICAgc3ViUmVzb3VyY2VbcHJvY2Vzc0tleXdvcmRdID0gb3B0aW9ucy5wcm9jZXNzO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVzcG9uc2UpIHtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zLnJlc3BvbnNlKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBgcmVzcG9uc2UtJHtrLnRvTG93ZXJDYXNlKCl9YDtcbiAgICAgIHN1YlJlc291cmNlW2tleV0gPSBvcHRpb25zLnJlc3BvbnNlW2tdO1xuICAgIH0pO1xuICB9XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgbG93ZXJLZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAobG93ZXJLZXkuaW5kZXhPZigneC1vc3MtJykgPT09IDApIHtcbiAgICAgIGhlYWRlcnNbbG93ZXJLZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChsb3dlcktleS5pbmRleE9mKCdjb250ZW50LW1kNScpID09PSAwKSB7XG4gICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGxvd2VyS2V5LmluZGV4T2YoJ2NvbnRlbnQtdHlwZScpID09PSAwKSB7XG4gICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGxvd2VyS2V5ICE9PSAnZXhwaXJlcycgJiYgbG93ZXJLZXkgIT09ICdyZXNwb25zZScgJiYgbG93ZXJLZXkgIT09ICdwcm9jZXNzJyAmJiBsb3dlcktleSAhPT0gJ21ldGhvZCcpIHtcbiAgICAgIHN1YlJlc291cmNlW2xvd2VyS2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc2VjdXJpdHktdG9rZW4nKSkge1xuICAgIHN1YlJlc291cmNlWydzZWN1cml0eS10b2tlbiddID0gb3B0aW9uc1snc2VjdXJpdHktdG9rZW4nXTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ2NhbGxiYWNrJykpIHtcbiAgICBjb25zdCBqc29uID0ge1xuICAgICAgY2FsbGJhY2tVcmw6IGVuY29kZVVSSShvcHRpb25zLmNhbGxiYWNrLnVybCksXG4gICAgICBjYWxsYmFja0JvZHk6IG9wdGlvbnMuY2FsbGJhY2suYm9keVxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMuY2FsbGJhY2suaG9zdCkge1xuICAgICAganNvbi5jYWxsYmFja0hvc3QgPSBvcHRpb25zLmNhbGxiYWNrLmhvc3Q7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNhbGxiYWNrLmNvbnRlbnRUeXBlKSB7XG4gICAgICBqc29uLmNhbGxiYWNrQm9keVR5cGUgPSBvcHRpb25zLmNhbGxiYWNrLmNvbnRlbnRUeXBlO1xuICAgIH1cbiAgICBzdWJSZXNvdXJjZS5jYWxsYmFjayA9IG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoanNvbikpLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuICAgIGlmIChvcHRpb25zLmNhbGxiYWNrLmN1c3RvbVZhbHVlKSB7XG4gICAgICBjb25zdCBjYWxsYmFja1ZhciA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5jYWxsYmFjay5jdXN0b21WYWx1ZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNhbGxiYWNrVmFyW2B4OiR7a2V5fWBdID0gb3B0aW9ucy5jYWxsYmFjay5jdXN0b21WYWx1ZVtrZXldO1xuICAgICAgfSk7XG4gICAgICBzdWJSZXNvdXJjZVsnY2FsbGJhY2stdmFyJ10gPSBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KGNhbGxiYWNrVmFyKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNhbm9uaWNhbFN0cmluZyA9IHRoaXMuYnVpbGRDYW5vbmljYWxTdHJpbmcob3B0aW9ucy5tZXRob2QsIHJlc291cmNlLCB7XG4gICAgaGVhZGVycyxcbiAgICBwYXJhbWV0ZXJzOiBzdWJSZXNvdXJjZVxuICB9LCBleHBpcmVzLnRvU3RyaW5nKCkpO1xuXG4gIHJldHVybiB7XG4gICAgU2lnbmF0dXJlOiB0aGlzLmNvbXB1dGVTaWduYXR1cmUoYWNjZXNzS2V5U2VjcmV0LCBjYW5vbmljYWxTdHJpbmcpLFxuICAgIHN1YlJlc291cmNlXG4gIH07XG59O1xuIiwiXG4vLyBpdCBwcm92aWRlIGNvbW1vbnQgbWV0aG9kcyBmb3Igbm9kZSBhbmQgYnJvd3NlciAsIHdlIHdpbGwgYWRkIG1vcmUgc29sdXRpb25zIGxhdGVyIGluIHRoaXMgZmlsZVxuXG4vKipcbiAqIEp1ZGdlIGlzSVAgaW5jbHVkZSBpcHY0IG9yIGlwdjZcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zXG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIG11bHRpcGFydCB1cGxvYWRzXG4gKi9cbmV4cG9ydHMuX2lzSVAgPSBmdW5jdGlvbiAoaG9zdCkge1xuICBjb25zdCBpcHY0UmVnZXggPSAvXigyNVswLTVdfDJbMC00XVxcZHxbMC0xXT9cXGQ/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8WzAtMV0/XFxkP1xcZCkpezN9JC87XG4gIGNvbnN0IGlwdjZSZWdleCA9IC9eXFxzKigoKFswLTlBLUZhLWZdezEsNH06KXs3fShbMC05QS1GYS1mXXsxLDR9fDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs2fSg6WzAtOUEtRmEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezV9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezR9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsM30pfCgoOlswLTlBLUZhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXszfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezJ9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNX0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7MX0oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSglLispP1xccyokLztcbiAgY29uc3QgaXNJUCA9IGlwdjRSZWdleC50ZXN0KGhvc3QpIHx8IGlwdjZSZWdleC50ZXN0KGhvc3QpO1xuICByZXR1cm4gaXNJUDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5vb3A7XG5tb2R1bGUuZXhwb3J0cy5IdHRwc0FnZW50ID0gbm9vcDtcblxuLy8gTm9vcCBmdW5jdGlvbiBmb3IgYnJvd3NlciBzaW5jZSBuYXRpdmUgYXBpJ3MgZG9uJ3QgdXNlIGFnZW50cy5cbmZ1bmN0aW9uIG5vb3AgKCkge31cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWdpc3RlcicpKCkuUHJvbWlzZVxuIiwiXCJ1c2Ugc3RyaWN0XCJcbiAgICAvLyBnbG9iYWwga2V5IGZvciB1c2VyIHByZWZlcnJlZCByZWdpc3RyYXRpb25cbnZhciBSRUdJU1RSQVRJT05fS0VZID0gJ0BAYW55LXByb21pc2UvUkVHSVNUUkFUSU9OJyxcbiAgICAvLyBQcmlvciByZWdpc3RyYXRpb24gKHByZWZlcnJlZCBvciBkZXRlY3RlZClcbiAgICByZWdpc3RlcmVkID0gbnVsbFxuXG4vKipcbiAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gaW1wbGVtZW50YXRpb24uICBBbiBpbXBsZW1lbnRhdGlvbiBtdXN0XG4gKiBiZSByZWdpc3RlcmVkIHByaW9yIHRvIGFueSBjYWxsIHRvIGByZXF1aXJlKFwiYW55LXByb21pc2VcIilgLFxuICogdHlwaWNhbGx5IG9uIGFwcGxpY2F0aW9uIGxvYWQuXG4gKlxuICogSWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCB3aWxsIHJldHVybiByZWdpc3RyYXRpb24gaW5cbiAqIGZvbGxvd2luZyBwcmlvcml0eTpcbiAqXG4gKiBGb3IgTm9kZS5qczpcbiAqXG4gKiAxLiBQcmV2aW91cyByZWdpc3RyYXRpb25cbiAqIDIuIGdsb2JhbC5Qcm9taXNlIGlmIG5vZGUuanMgdmVyc2lvbiA+PSAwLjEyXG4gKiAzLiBBdXRvIGRldGVjdGVkIHByb21pc2UgYmFzZWQgb24gZmlyc3Qgc3VjZXNzZnVsIHJlcXVpcmUgb2ZcbiAqICAgIGtub3duIHByb21pc2UgbGlicmFyaWVzLiBOb3RlIHRoaXMgaXMgYSBsYXN0IHJlc29ydCwgYXMgdGhlXG4gKiAgICBsb2FkZWQgbGlicmFyeSBpcyBub24tZGV0ZXJtaW5pc3RpYy4gbm9kZS5qcyA+PSAwLjEyIHdpbGxcbiAqICAgIGFsd2F5cyB1c2UgZ2xvYmFsLlByb21pc2Ugb3ZlciB0aGlzIHByaW9yaXR5IGxpc3QuXG4gKiA0LiBUaHJvd3MgZXJyb3IuXG4gKlxuICogRm9yIEJyb3dzZXI6XG4gKlxuICogMS4gUHJldmlvdXMgcmVnaXN0cmF0aW9uXG4gKiAyLiB3aW5kb3cuUHJvbWlzZVxuICogMy4gVGhyb3dzIGVycm9yLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogUHJvbWlzZTogRGVzaXJlZCBQcm9taXNlIGNvbnN0cnVjdG9yXG4gKiBnbG9iYWw6IEJvb2xlYW4gLSBTaG91bGQgdGhlIHJlZ2lzdHJhdGlvbiBiZSBjYWNoZWQgaW4gYSBnbG9iYWwgdmFyaWFibGUgdG9cbiAqIGFsbG93IGNyb3NzIGRlcGVuZGVuY3kvYnVuZGxlIHJlZ2lzdHJhdGlvbj8gIChkZWZhdWx0IHRydWUpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocm9vdCwgbG9hZEltcGxlbWVudGF0aW9uKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlZ2lzdGVyKGltcGxlbWVudGF0aW9uLCBvcHRzKXtcbiAgICBpbXBsZW1lbnRhdGlvbiA9IGltcGxlbWVudGF0aW9uIHx8IG51bGxcbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuICAgIC8vIGdsb2JhbCByZWdpc3RyYXRpb24gdW5sZXNzIGV4cGxpY2l0bHkgIHtnbG9iYWw6IGZhbHNlfSBpbiBvcHRpb25zIChkZWZhdWx0IHRydWUpXG4gICAgdmFyIHJlZ2lzdGVyR2xvYmFsID0gb3B0cy5nbG9iYWwgIT09IGZhbHNlO1xuXG4gICAgLy8gbG9hZCBhbnkgcHJldmlvdXMgZ2xvYmFsIHJlZ2lzdHJhdGlvblxuICAgIGlmKHJlZ2lzdGVyZWQgPT09IG51bGwgJiYgcmVnaXN0ZXJHbG9iYWwpe1xuICAgICAgcmVnaXN0ZXJlZCA9IHJvb3RbUkVHSVNUUkFUSU9OX0tFWV0gfHwgbnVsbFxuICAgIH1cblxuICAgIGlmKHJlZ2lzdGVyZWQgIT09IG51bGxcbiAgICAgICAgJiYgaW1wbGVtZW50YXRpb24gIT09IG51bGxcbiAgICAgICAgJiYgcmVnaXN0ZXJlZC5pbXBsZW1lbnRhdGlvbiAhPT0gaW1wbGVtZW50YXRpb24pe1xuICAgICAgLy8gVGhyb3cgZXJyb3IgaWYgYXR0ZW1wdGluZyB0byByZWRlZmluZSBpbXBsZW1lbnRhdGlvblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbnktcHJvbWlzZSBhbHJlYWR5IGRlZmluZWQgYXMgXCInK3JlZ2lzdGVyZWQuaW1wbGVtZW50YXRpb24rXG4gICAgICAgICdcIi4gIFlvdSBjYW4gb25seSByZWdpc3RlciBhbiBpbXBsZW1lbnRhdGlvbiBiZWZvcmUgdGhlIGZpcnN0ICcrXG4gICAgICAgICcgY2FsbCB0byByZXF1aXJlKFwiYW55LXByb21pc2VcIikgYW5kIGFuIGltcGxlbWVudGF0aW9uIGNhbm5vdCBiZSBjaGFuZ2VkJylcbiAgICB9XG5cbiAgICBpZihyZWdpc3RlcmVkID09PSBudWxsKXtcbiAgICAgIC8vIHVzZSBwcm92aWRlZCBpbXBsZW1lbnRhdGlvblxuICAgICAgaWYoaW1wbGVtZW50YXRpb24gIT09IG51bGwgJiYgdHlwZW9mIG9wdHMuUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICByZWdpc3RlcmVkID0ge1xuICAgICAgICAgIFByb21pc2U6IG9wdHMuUHJvbWlzZSxcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVxdWlyZSBpbXBsZW1lbnRhdGlvbiBpZiBpbXBsZW1lbnRhdGlvbiBpcyBzcGVjaWZpZWQgYnV0IG5vdCBwcm92aWRlZFxuICAgICAgICByZWdpc3RlcmVkID0gbG9hZEltcGxlbWVudGF0aW9uKGltcGxlbWVudGF0aW9uKVxuICAgICAgfVxuXG4gICAgICBpZihyZWdpc3Rlckdsb2JhbCl7XG4gICAgICAgIC8vIHJlZ2lzdGVyIHByZWZlcmVuY2UgZ2xvYmFsbHkgaW4gY2FzZSBtdWx0aXBsZSBpbnN0YWxsYXRpb25zXG4gICAgICAgIHJvb3RbUkVHSVNUUkFUSU9OX0tFWV0gPSByZWdpc3RlcmVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2lzdGVyZWRcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbG9hZGVyJykod2luZG93LCBsb2FkSW1wbGVtZW50YXRpb24pXG5cbi8qKlxuICogQnJvd3NlciBzcGVjaWZpYyBsb2FkSW1wbGVtZW50YXRpb24uICBBbHdheXMgdXNlcyBgd2luZG93LlByb21pc2VgXG4gKlxuICogVG8gcmVnaXN0ZXIgYSBjdXN0b20gaW1wbGVtZW50YXRpb24sIG11c3QgcmVnaXN0ZXIgd2l0aCBgUHJvbWlzZWAgb3B0aW9uLlxuICovXG5mdW5jdGlvbiBsb2FkSW1wbGVtZW50YXRpb24oKXtcbiAgaWYodHlwZW9mIHdpbmRvdy5Qcm9taXNlID09PSAndW5kZWZpbmVkJyl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYW55LXByb21pc2UgYnJvd3NlciByZXF1aXJlcyBhIHBvbHlmaWxsIG9yIGV4cGxpY2l0IHJlZ2lzdHJhdGlvblwiK1xuICAgICAgXCIgZS5nOiByZXF1aXJlKCdhbnktcHJvbWlzZS9yZWdpc3Rlci9ibHVlYmlyZCcpXCIpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBQcm9taXNlOiB3aW5kb3cuUHJvbWlzZSxcbiAgICBpbXBsZW1lbnRhdGlvbjogJ3dpbmRvdy5Qcm9taXNlJ1xuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1uYW1lc1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5c1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3NldC1pbW1lZGlhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3RyaW5nL2Zyb20tY29kZS1wb2ludFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2hhcy1pbnN0YW5jZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBCb3dzZXIgLSBhIGJyb3dzZXIgZGV0ZWN0b3JcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWQvYm93c2VyXG4gKiBNSVQgTGljZW5zZSB8IChjKSBEdXN0aW4gRGlheiAyMDE1XG4gKi9cblxuIWZ1bmN0aW9uIChyb290LCBuYW1lLCBkZWZpbml0aW9uKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKG5hbWUsIGRlZmluaXRpb24pXG4gIGVsc2Ugcm9vdFtuYW1lXSA9IGRlZmluaXRpb24oKVxufSh0aGlzLCAnYm93c2VyJywgZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICAqIFNlZSB1c2VyYWdlbnRzLmpzIGZvciBleGFtcGxlcyBvZiBuYXZpZ2F0b3IudXNlckFnZW50XG4gICAgKi9cblxuICB2YXIgdCA9IHRydWVcblxuICBmdW5jdGlvbiBkZXRlY3QodWEpIHtcblxuICAgIGZ1bmN0aW9uIGdldEZpcnN0TWF0Y2gocmVnZXgpIHtcbiAgICAgIHZhciBtYXRjaCA9IHVhLm1hdGNoKHJlZ2V4KTtcbiAgICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaFsxXSkgfHwgJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2Vjb25kTWF0Y2gocmVnZXgpIHtcbiAgICAgIHZhciBtYXRjaCA9IHVhLm1hdGNoKHJlZ2V4KTtcbiAgICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaFsyXSkgfHwgJyc7XG4gICAgfVxuXG4gICAgdmFyIGlvc2RldmljZSA9IGdldEZpcnN0TWF0Y2goLyhpcG9kfGlwaG9uZXxpcGFkKS9pKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGxpa2VBbmRyb2lkID0gL2xpa2UgYW5kcm9pZC9pLnRlc3QodWEpXG4gICAgICAsIGFuZHJvaWQgPSAhbGlrZUFuZHJvaWQgJiYgL2FuZHJvaWQvaS50ZXN0KHVhKVxuICAgICAgLCBuZXh1c01vYmlsZSA9IC9uZXh1c1xccypbMC02XVxccyovaS50ZXN0KHVhKVxuICAgICAgLCBuZXh1c1RhYmxldCA9ICFuZXh1c01vYmlsZSAmJiAvbmV4dXNcXHMqWzAtOV0rL2kudGVzdCh1YSlcbiAgICAgICwgY2hyb21lb3MgPSAvQ3JPUy8udGVzdCh1YSlcbiAgICAgICwgc2lsayA9IC9zaWxrL2kudGVzdCh1YSlcbiAgICAgICwgc2FpbGZpc2ggPSAvc2FpbGZpc2gvaS50ZXN0KHVhKVxuICAgICAgLCB0aXplbiA9IC90aXplbi9pLnRlc3QodWEpXG4gICAgICAsIHdlYm9zID0gLyh3ZWJ8aHB3KShvfDApcy9pLnRlc3QodWEpXG4gICAgICAsIHdpbmRvd3NwaG9uZSA9IC93aW5kb3dzIHBob25lL2kudGVzdCh1YSlcbiAgICAgICwgc2Ftc3VuZ0Jyb3dzZXIgPSAvU2Ftc3VuZ0Jyb3dzZXIvaS50ZXN0KHVhKVxuICAgICAgLCB3aW5kb3dzID0gIXdpbmRvd3NwaG9uZSAmJiAvd2luZG93cy9pLnRlc3QodWEpXG4gICAgICAsIG1hYyA9ICFpb3NkZXZpY2UgJiYgIXNpbGsgJiYgL21hY2ludG9zaC9pLnRlc3QodWEpXG4gICAgICAsIGxpbnV4ID0gIWFuZHJvaWQgJiYgIXNhaWxmaXNoICYmICF0aXplbiAmJiAhd2Vib3MgJiYgL2xpbnV4L2kudGVzdCh1YSlcbiAgICAgICwgZWRnZVZlcnNpb24gPSBnZXRTZWNvbmRNYXRjaCgvZWRnKFtlYV18aW9zKVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgICwgdmVyc2lvbklkZW50aWZpZXIgPSBnZXRGaXJzdE1hdGNoKC92ZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgLCB0YWJsZXQgPSAvdGFibGV0L2kudGVzdCh1YSkgJiYgIS90YWJsZXQgcGMvaS50ZXN0KHVhKVxuICAgICAgLCBtb2JpbGUgPSAhdGFibGV0ICYmIC9bXi1dbW9iaS9pLnRlc3QodWEpXG4gICAgICAsIHhib3ggPSAveGJveC9pLnRlc3QodWEpXG4gICAgICAsIHJlc3VsdFxuXG4gICAgaWYgKC9vcGVyYS9pLnRlc3QodWEpKSB7XG4gICAgICAvLyAgYW4gb2xkIE9wZXJhXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdPcGVyYSdcbiAgICAgICwgb3BlcmE6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86b3BlcmF8b3ByfG9waW9zKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL29wclxcL3xvcGlvcy9pLnRlc3QodWEpKSB7XG4gICAgICAvLyBhIG5ldyBPcGVyYVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnT3BlcmEnXG4gICAgICAgICwgb3BlcmE6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpvcHJ8b3Bpb3MpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9TYW1zdW5nQnJvd3Nlci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkJ1xuICAgICAgICAsIHNhbXN1bmdCcm93c2VyOiB0XG4gICAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86U2Ftc3VuZ0Jyb3dzZXIpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9XaGFsZS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdOQVZFUiBXaGFsZSBicm93c2VyJ1xuICAgICAgICAsIHdoYWxlOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86d2hhbGUpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL01aQnJvd3Nlci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdNWiBCcm93c2VyJ1xuICAgICAgICAsIG16YnJvd3NlcjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/Ok1aQnJvd3NlcilbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvY29hc3QvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnT3BlcmEgQ29hc3QnXG4gICAgICAgICwgY29hc3Q6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC8oPzpjb2FzdClbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2ZvY3VzL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0ZvY3VzJ1xuICAgICAgICAsIGZvY3VzOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Zm9jdXMpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3lhYnJvd3Nlci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdZYW5kZXggQnJvd3NlcidcbiAgICAgICwgeWFuZGV4YnJvd3NlcjogdFxuICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC8oPzp5YWJyb3dzZXIpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC91Y2Jyb3dzZXIvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIG5hbWU6ICdVQyBCcm93c2VyJ1xuICAgICAgICAsIHVjYnJvd3NlcjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnVjYnJvd3NlcilbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvbXhpb3MvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnTWF4dGhvbidcbiAgICAgICAgLCBtYXh0aG9uOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86bXhpb3MpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2VwaXBoYW55L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0VwaXBoYW55J1xuICAgICAgICAsIGVwaXBoYW55OiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ZXBpcGhhbnkpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3B1ZmZpbi9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdQdWZmaW4nXG4gICAgICAgICwgcHVmZmluOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86cHVmZmluKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9zbGVpcG5pci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTbGVpcG5pcidcbiAgICAgICAgLCBzbGVpcG5pcjogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnNsZWlwbmlyKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9rLW1lbGVvbi9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdLLU1lbGVvbidcbiAgICAgICAgLCBrTWVsZW9uOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ay1tZWxlb24pW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93c3Bob25lKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdXaW5kb3dzIFBob25lJ1xuICAgICAgLCBvc25hbWU6ICdXaW5kb3dzIFBob25lJ1xuICAgICAgLCB3aW5kb3dzcGhvbmU6IHRcbiAgICAgIH1cbiAgICAgIGlmIChlZGdlVmVyc2lvbikge1xuICAgICAgICByZXN1bHQubXNlZGdlID0gdFxuICAgICAgICByZXN1bHQudmVyc2lvbiA9IGVkZ2VWZXJzaW9uXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0Lm1zaWUgPSB0XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvaWVtb2JpbGVcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9tc2llfHRyaWRlbnQvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnSW50ZXJuZXQgRXhwbG9yZXInXG4gICAgICAsIG1zaWU6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86bXNpZSB8cnY6KShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNocm9tZW9zKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWUnXG4gICAgICAsIG9zbmFtZTogJ0Nocm9tZSBPUydcbiAgICAgICwgY2hyb21lb3M6IHRcbiAgICAgICwgY2hyb21lQm9vazogdFxuICAgICAgLCBjaHJvbWU6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21lfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL2VkZyhbZWFdfGlvcykvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnTWljcm9zb2Z0IEVkZ2UnXG4gICAgICAsIG1zZWRnZTogdFxuICAgICAgLCB2ZXJzaW9uOiBlZGdlVmVyc2lvblxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvdml2YWxkaS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdWaXZhbGRpJ1xuICAgICAgICAsIHZpdmFsZGk6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC92aXZhbGRpXFwvKFxcZCsoXFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzYWlsZmlzaCkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2FpbGZpc2gnXG4gICAgICAsIG9zbmFtZTogJ1NhaWxmaXNoIE9TJ1xuICAgICAgLCBzYWlsZmlzaDogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9zYWlsZmlzaFxccz9icm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2VhbW9ua2V5XFwvL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NlYU1vbmtleSdcbiAgICAgICwgc2VhbW9ua2V5OiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3NlYW1vbmtleVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0ZpcmVmb3gnXG4gICAgICAsIGZpcmVmb3g6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86ZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MpWyBcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgICAgaWYgKC9cXCgobW9iaWxlfHRhYmxldCk7W15cXCldKnJ2OltcXGRcXC5dK1xcKS9pLnRlc3QodWEpKSB7XG4gICAgICAgIHJlc3VsdC5maXJlZm94b3MgPSB0XG4gICAgICAgIHJlc3VsdC5vc25hbWUgPSAnRmlyZWZveCBPUydcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2lsaykge1xuICAgICAgcmVzdWx0ID0gIHtcbiAgICAgICAgbmFtZTogJ0FtYXpvbiBTaWxrJ1xuICAgICAgLCBzaWxrOiB0XG4gICAgICAsIHZlcnNpb24gOiBnZXRGaXJzdE1hdGNoKC9zaWxrXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvcGhhbnRvbS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdQaGFudG9tSlMnXG4gICAgICAsIHBoYW50b206IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvcGhhbnRvbWpzXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2xpbWVyanMvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2xpbWVySlMnXG4gICAgICAgICwgc2xpbWVyOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2xpbWVyanNcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9ibGFja2JlcnJ5fFxcYmJiXFxkKy9pLnRlc3QodWEpIHx8IC9yaW1cXHN0YWJsZXQvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQmxhY2tCZXJyeSdcbiAgICAgICwgb3NuYW1lOiAnQmxhY2tCZXJyeSBPUydcbiAgICAgICwgYmxhY2tiZXJyeTogdFxuICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC9ibGFja2JlcnJ5W1xcZF0rXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh3ZWJvcykge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnV2ViT1MnXG4gICAgICAsIG9zbmFtZTogJ1dlYk9TJ1xuICAgICAgLCB3ZWJvczogdFxuICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC93KD86ZWIpP29zYnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH07XG4gICAgICAvdG91Y2hwYWRcXC8vaS50ZXN0KHVhKSAmJiAocmVzdWx0LnRvdWNocGFkID0gdClcbiAgICB9XG4gICAgZWxzZSBpZiAoL2JhZGEvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQmFkYSdcbiAgICAgICwgb3NuYW1lOiAnQmFkYSdcbiAgICAgICwgYmFkYTogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9kb2xmaW5cXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0aXplbikge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnVGl6ZW4nXG4gICAgICAsIG9zbmFtZTogJ1RpemVuJ1xuICAgICAgLCB0aXplbjogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzp0aXplblxccz8pP2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgvcXVwemlsbGEvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnUXVwWmlsbGEnXG4gICAgICAgICwgcXVwemlsbGE6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpxdXB6aWxsYSlbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvY2hyb21pdW0vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQ2hyb21pdW0nXG4gICAgICAgICwgY2hyb21pdW06IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWl1bSlbXFxzXFwvXShcXGQrKD86XFwuXFxkKyk/KS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvY2hyb21lfGNyaW9zfGNybW8vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQ2hyb21lJ1xuICAgICAgICAsIGNocm9tZTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmNocm9tZXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYW5kcm9pZCkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnQW5kcm9pZCdcbiAgICAgICAgLCB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvc2FmYXJpfGFwcGxld2Via2l0L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NhZmFyaSdcbiAgICAgICwgc2FmYXJpOiB0XG4gICAgICB9XG4gICAgICBpZiAodmVyc2lvbklkZW50aWZpZXIpIHtcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpb3NkZXZpY2UpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZSA6IGlvc2RldmljZSA9PSAnaXBob25lJyA/ICdpUGhvbmUnIDogaW9zZGV2aWNlID09ICdpcGFkJyA/ICdpUGFkJyA6ICdpUG9kJ1xuICAgICAgfVxuICAgICAgLy8gV1RGOiB2ZXJzaW9uIGlzIG5vdCBwYXJ0IG9mIHVzZXIgYWdlbnQgaW4gd2ViIGFwcHNcbiAgICAgIGlmICh2ZXJzaW9uSWRlbnRpZmllcikge1xuICAgICAgICByZXN1bHQudmVyc2lvbiA9IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYoL2dvb2dsZWJvdC9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdHb29nbGVib3QnXG4gICAgICAsIGdvb2dsZWJvdDogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9nb29nbGVib3RcXC8oXFxkKyhcXC5cXGQrKSkvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6IGdldEZpcnN0TWF0Y2goL14oLiopXFwvKC4qKSAvKSxcbiAgICAgICAgdmVyc2lvbjogZ2V0U2Vjb25kTWF0Y2goL14oLiopXFwvKC4qKSAvKVxuICAgICB9O1xuICAgfVxuXG4gICAgLy8gc2V0IHdlYmtpdCBvciBnZWNrbyBmbGFnIGZvciBicm93c2VycyBiYXNlZCBvbiB0aGVzZSBlbmdpbmVzXG4gICAgaWYgKCFyZXN1bHQubXNlZGdlICYmIC8oYXBwbGUpP3dlYmtpdC9pLnRlc3QodWEpKSB7XG4gICAgICBpZiAoLyhhcHBsZSk/d2Via2l0XFwvNTM3XFwuMzYvaS50ZXN0KHVhKSkge1xuICAgICAgICByZXN1bHQubmFtZSA9IHJlc3VsdC5uYW1lIHx8IFwiQmxpbmtcIlxuICAgICAgICByZXN1bHQuYmxpbmsgPSB0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQubmFtZSA9IHJlc3VsdC5uYW1lIHx8IFwiV2Via2l0XCJcbiAgICAgICAgcmVzdWx0LndlYmtpdCA9IHRcbiAgICAgIH1cbiAgICAgIGlmICghcmVzdWx0LnZlcnNpb24gJiYgdmVyc2lvbklkZW50aWZpZXIpIHtcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXJlc3VsdC5vcGVyYSAmJiAvZ2Vja29cXC8vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcIkdlY2tvXCJcbiAgICAgIHJlc3VsdC5nZWNrbyA9IHRcbiAgICAgIHJlc3VsdC52ZXJzaW9uID0gcmVzdWx0LnZlcnNpb24gfHwgZ2V0Rmlyc3RNYXRjaCgvZ2Vja29cXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgfVxuXG4gICAgLy8gc2V0IE9TIGZsYWdzIGZvciBwbGF0Zm9ybXMgdGhhdCBoYXZlIG11bHRpcGxlIGJyb3dzZXJzXG4gICAgaWYgKCFyZXN1bHQud2luZG93c3Bob25lICYmIChhbmRyb2lkIHx8IHJlc3VsdC5zaWxrKSkge1xuICAgICAgcmVzdWx0LmFuZHJvaWQgPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ0FuZHJvaWQnXG4gICAgfSBlbHNlIGlmICghcmVzdWx0LndpbmRvd3NwaG9uZSAmJiBpb3NkZXZpY2UpIHtcbiAgICAgIHJlc3VsdFtpb3NkZXZpY2VdID0gdFxuICAgICAgcmVzdWx0LmlvcyA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnaU9TJ1xuICAgIH0gZWxzZSBpZiAobWFjKSB7XG4gICAgICByZXN1bHQubWFjID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdtYWNPUydcbiAgICB9IGVsc2UgaWYgKHhib3gpIHtcbiAgICAgIHJlc3VsdC54Ym94ID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdYYm94J1xuICAgIH0gZWxzZSBpZiAod2luZG93cykge1xuICAgICAgcmVzdWx0LndpbmRvd3MgPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ1dpbmRvd3MnXG4gICAgfSBlbHNlIGlmIChsaW51eCkge1xuICAgICAgcmVzdWx0LmxpbnV4ID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdMaW51eCdcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaW5kb3dzVmVyc2lvbiAocykge1xuICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgJ05UJzogcmV0dXJuICdOVCdcbiAgICAgICAgY2FzZSAnWFAnOiByZXR1cm4gJ1hQJ1xuICAgICAgICBjYXNlICdOVCA1LjAnOiByZXR1cm4gJzIwMDAnXG4gICAgICAgIGNhc2UgJ05UIDUuMSc6IHJldHVybiAnWFAnXG4gICAgICAgIGNhc2UgJ05UIDUuMic6IHJldHVybiAnMjAwMydcbiAgICAgICAgY2FzZSAnTlQgNi4wJzogcmV0dXJuICdWaXN0YSdcbiAgICAgICAgY2FzZSAnTlQgNi4xJzogcmV0dXJuICc3J1xuICAgICAgICBjYXNlICdOVCA2LjInOiByZXR1cm4gJzgnXG4gICAgICAgIGNhc2UgJ05UIDYuMyc6IHJldHVybiAnOC4xJ1xuICAgICAgICBjYXNlICdOVCAxMC4wJzogcmV0dXJuICcxMCdcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9TIHZlcnNpb24gZXh0cmFjdGlvblxuICAgIHZhciBvc1ZlcnNpb24gPSAnJztcbiAgICBpZiAocmVzdWx0LndpbmRvd3MpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldFdpbmRvd3NWZXJzaW9uKGdldEZpcnN0TWF0Y2goL1dpbmRvd3MgKChOVHxYUCkoIFxcZFxcZD8uXFxkKT8pL2kpKVxuICAgIH0gZWxzZSBpZiAocmVzdWx0LndpbmRvd3NwaG9uZSkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvd2luZG93cyBwaG9uZSAoPzpvcyk/XFxzPyhcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQubWFjKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9NYWMgT1MgWCAoXFxkKyhbX1xcLlxcc11cXGQrKSopL2kpO1xuICAgICAgb3NWZXJzaW9uID0gb3NWZXJzaW9uLnJlcGxhY2UoL1tfXFxzXS9nLCAnLicpO1xuICAgIH0gZWxzZSBpZiAoaW9zZGV2aWNlKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9vcyAoXFxkKyhbX1xcc11cXGQrKSopIGxpa2UgbWFjIG9zIHgvaSk7XG4gICAgICBvc1ZlcnNpb24gPSBvc1ZlcnNpb24ucmVwbGFjZSgvW19cXHNdL2csICcuJyk7XG4gICAgfSBlbHNlIGlmIChhbmRyb2lkKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9hbmRyb2lkWyBcXC8tXShcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQud2Vib3MpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goLyg/OndlYnxocHcpb3NcXC8oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LmJsYWNrYmVycnkpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL3JpbVxcc3RhYmxldFxcc29zXFxzKFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5iYWRhKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9iYWRhXFwvKFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC50aXplbikge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvdGl6ZW5bXFwvXFxzXShcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfVxuICAgIGlmIChvc1ZlcnNpb24pIHtcbiAgICAgIHJlc3VsdC5vc3ZlcnNpb24gPSBvc1ZlcnNpb247XG4gICAgfVxuXG4gICAgLy8gZGV2aWNlIHR5cGUgZXh0cmFjdGlvblxuICAgIHZhciBvc01ham9yVmVyc2lvbiA9ICFyZXN1bHQud2luZG93cyAmJiBvc1ZlcnNpb24uc3BsaXQoJy4nKVswXTtcbiAgICBpZiAoXG4gICAgICAgICB0YWJsZXRcbiAgICAgIHx8IG5leHVzVGFibGV0XG4gICAgICB8fCBpb3NkZXZpY2UgPT0gJ2lwYWQnXG4gICAgICB8fCAoYW5kcm9pZCAmJiAob3NNYWpvclZlcnNpb24gPT0gMyB8fCAob3NNYWpvclZlcnNpb24gPj0gNCAmJiAhbW9iaWxlKSkpXG4gICAgICB8fCByZXN1bHQuc2lsa1xuICAgICkge1xuICAgICAgcmVzdWx0LnRhYmxldCA9IHRcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgbW9iaWxlXG4gICAgICB8fCBpb3NkZXZpY2UgPT0gJ2lwaG9uZSdcbiAgICAgIHx8IGlvc2RldmljZSA9PSAnaXBvZCdcbiAgICAgIHx8IGFuZHJvaWRcbiAgICAgIHx8IG5leHVzTW9iaWxlXG4gICAgICB8fCByZXN1bHQuYmxhY2tiZXJyeVxuICAgICAgfHwgcmVzdWx0LndlYm9zXG4gICAgICB8fCByZXN1bHQuYmFkYVxuICAgICkge1xuICAgICAgcmVzdWx0Lm1vYmlsZSA9IHRcbiAgICB9XG5cbiAgICAvLyBHcmFkZWQgQnJvd3NlciBTdXBwb3J0XG4gICAgLy8gaHR0cDovL2RldmVsb3Blci55YWhvby5jb20veXVpL2FydGljbGVzL2dic1xuICAgIGlmIChyZXN1bHQubXNlZGdlIHx8XG4gICAgICAgIChyZXN1bHQubXNpZSAmJiByZXN1bHQudmVyc2lvbiA+PSAxMCkgfHxcbiAgICAgICAgKHJlc3VsdC55YW5kZXhicm93c2VyICYmIHJlc3VsdC52ZXJzaW9uID49IDE1KSB8fFxuXHRcdCAgICAocmVzdWx0LnZpdmFsZGkgJiYgcmVzdWx0LnZlcnNpb24gPj0gMS4wKSB8fFxuICAgICAgICAocmVzdWx0LmNocm9tZSAmJiByZXN1bHQudmVyc2lvbiA+PSAyMCkgfHxcbiAgICAgICAgKHJlc3VsdC5zYW1zdW5nQnJvd3NlciAmJiByZXN1bHQudmVyc2lvbiA+PSA0KSB8fFxuICAgICAgICAocmVzdWx0LndoYWxlICYmIGNvbXBhcmVWZXJzaW9ucyhbcmVzdWx0LnZlcnNpb24sICcxLjAnXSkgPT09IDEpIHx8XG4gICAgICAgIChyZXN1bHQubXpicm93c2VyICYmIGNvbXBhcmVWZXJzaW9ucyhbcmVzdWx0LnZlcnNpb24sICc2LjAnXSkgPT09IDEpIHx8XG4gICAgICAgIChyZXN1bHQuZm9jdXMgJiYgY29tcGFyZVZlcnNpb25zKFtyZXN1bHQudmVyc2lvbiwgJzEuMCddKSA9PT0gMSkgfHxcbiAgICAgICAgKHJlc3VsdC5maXJlZm94ICYmIHJlc3VsdC52ZXJzaW9uID49IDIwLjApIHx8XG4gICAgICAgIChyZXN1bHQuc2FmYXJpICYmIHJlc3VsdC52ZXJzaW9uID49IDYpIHx8XG4gICAgICAgIChyZXN1bHQub3BlcmEgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5pb3MgJiYgcmVzdWx0Lm9zdmVyc2lvbiAmJiByZXN1bHQub3N2ZXJzaW9uLnNwbGl0KFwiLlwiKVswXSA+PSA2KSB8fFxuICAgICAgICAocmVzdWx0LmJsYWNrYmVycnkgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMSlcbiAgICAgICAgfHwgKHJlc3VsdC5jaHJvbWl1bSAmJiByZXN1bHQudmVyc2lvbiA+PSAyMClcbiAgICAgICAgKSB7XG4gICAgICByZXN1bHQuYSA9IHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKChyZXN1bHQubXNpZSAmJiByZXN1bHQudmVyc2lvbiA8IDEwKSB8fFxuICAgICAgICAocmVzdWx0LmNocm9tZSAmJiByZXN1bHQudmVyc2lvbiA8IDIwKSB8fFxuICAgICAgICAocmVzdWx0LmZpcmVmb3ggJiYgcmVzdWx0LnZlcnNpb24gPCAyMC4wKSB8fFxuICAgICAgICAocmVzdWx0LnNhZmFyaSAmJiByZXN1bHQudmVyc2lvbiA8IDYpIHx8XG4gICAgICAgIChyZXN1bHQub3BlcmEgJiYgcmVzdWx0LnZlcnNpb24gPCAxMC4wKSB8fFxuICAgICAgICAocmVzdWx0LmlvcyAmJiByZXN1bHQub3N2ZXJzaW9uICYmIHJlc3VsdC5vc3ZlcnNpb24uc3BsaXQoXCIuXCIpWzBdIDwgNilcbiAgICAgICAgfHwgKHJlc3VsdC5jaHJvbWl1bSAmJiByZXN1bHQudmVyc2lvbiA8IDIwKVxuICAgICAgICApIHtcbiAgICAgIHJlc3VsdC5jID0gdFxuICAgIH0gZWxzZSByZXN1bHQueCA9IHRcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHZhciBib3dzZXIgPSBkZXRlY3QodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnIDogJycpXG5cbiAgYm93c2VyLnRlc3QgPSBmdW5jdGlvbiAoYnJvd3Nlckxpc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyb3dzZXJMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYnJvd3Nlckl0ZW0gPSBicm93c2VyTGlzdFtpXTtcbiAgICAgIGlmICh0eXBlb2YgYnJvd3Nlckl0ZW09PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGJyb3dzZXJJdGVtIGluIGJvd3Nlcikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdmVyc2lvbiBwcmVjaXNpb25zIGNvdW50XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgZ2V0VmVyc2lvblByZWNpc2lvbihcIjEuMTAuM1wiKSAvLyAzXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmVyc2lvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb24pIHtcbiAgICByZXR1cm4gdmVyc2lvbi5zcGxpdChcIi5cIikubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEFycmF5OjptYXAgcG9seWZpbGxcbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiBtYXAoYXJyLCBpdGVyYXRvcikge1xuICAgIHZhciByZXN1bHQgPSBbXSwgaTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLm1hcCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhcnIsIGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goaXRlcmF0b3IoYXJyW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGJyb3dzZXIgdmVyc2lvbiB3ZWlnaHRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICBjb21wYXJlVmVyc2lvbnMoWycxLjEwLjIuMScsICAnMS44LjIuMS45MCddKSAgICAvLyAxXG4gICAqICAgY29tcGFyZVZlcnNpb25zKFsnMS4wMTAuMi4xJywgJzEuMDkuMi4xLjkwJ10pOyAgLy8gMVxuICAgKiAgIGNvbXBhcmVWZXJzaW9ucyhbJzEuMTAuMi4xJywgICcxLjEwLjIuMSddKTsgICAgIC8vIDBcbiAgICogICBjb21wYXJlVmVyc2lvbnMoWycxLjEwLjIuMScsICAnMS4wODAwLjInXSk7ICAgICAvLyAtMVxuICAgKlxuICAgKiBAcGFyYW0gIHtBcnJheTxTdHJpbmc+fSB2ZXJzaW9ucyB2ZXJzaW9ucyB0byBjb21wYXJlXG4gICAqIEByZXR1cm4ge051bWJlcn0gY29tcGFyaXNvbiByZXN1bHRcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2ZXJzaW9ucykge1xuICAgIC8vIDEpIGdldCBjb21tb24gcHJlY2lzaW9uIGZvciBib3RoIHZlcnNpb25zLCBmb3IgZXhhbXBsZSBmb3IgXCIxMC4wXCIgYW5kIFwiOVwiIGl0IHNob3VsZCBiZSAyXG4gICAgdmFyIHByZWNpc2lvbiA9IE1hdGgubWF4KGdldFZlcnNpb25QcmVjaXNpb24odmVyc2lvbnNbMF0pLCBnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb25zWzFdKSk7XG4gICAgdmFyIGNodW5rcyA9IG1hcCh2ZXJzaW9ucywgZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgIHZhciBkZWx0YSA9IHByZWNpc2lvbiAtIGdldFZlcnNpb25QcmVjaXNpb24odmVyc2lvbik7XG5cbiAgICAgIC8vIDIpIFwiOVwiIC0+IFwiOS4wXCIgKGZvciBwcmVjaXNpb24gPSAyKVxuICAgICAgdmVyc2lvbiA9IHZlcnNpb24gKyBuZXcgQXJyYXkoZGVsdGEgKyAxKS5qb2luKFwiLjBcIik7XG5cbiAgICAgIC8vIDMpIFwiOS4wXCIgLT4gW1wiMDAwMDAwMDAwXCJcIiwgXCIwMDAwMDAwMDlcIl1cbiAgICAgIHJldHVybiBtYXAodmVyc2lvbi5zcGxpdChcIi5cIiksIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5KDIwIC0gY2h1bmsubGVuZ3RoKS5qb2luKFwiMFwiKSArIGNodW5rO1xuICAgICAgfSkucmV2ZXJzZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gaXRlcmF0ZSBpbiByZXZlcnNlIG9yZGVyIGJ5IHJldmVyc2VkIGNodW5rcyBhcnJheVxuICAgIHdoaWxlICgtLXByZWNpc2lvbiA+PSAwKSB7XG4gICAgICAvLyA0KSBjb21wYXJlOiBcIjAwMDAwMDAwOVwiID4gXCIwMDAwMDAwMTBcIiA9IGZhbHNlIChidXQgXCI5XCIgPiBcIjEwXCIgPSB0cnVlKVxuICAgICAgaWYgKGNodW5rc1swXVtwcmVjaXNpb25dID4gY2h1bmtzWzFdW3ByZWNpc2lvbl0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjaHVua3NbMF1bcHJlY2lzaW9uXSA9PT0gY2h1bmtzWzFdW3ByZWNpc2lvbl0pIHtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gMCkge1xuICAgICAgICAgIC8vIGFsbCB2ZXJzaW9uIGNodW5rcyBhcmUgc2FtZVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBicm93c2VyIGlzIHVuc3VwcG9ydGVkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgYm93c2VyLmlzVW5zdXBwb3J0ZWRCcm93c2VyKHtcbiAgICogICAgIG1zaWU6IFwiMTBcIixcbiAgICogICAgIGZpcmVmb3g6IFwiMjNcIixcbiAgICogICAgIGNocm9tZTogXCIyOVwiLFxuICAgKiAgICAgc2FmYXJpOiBcIjUuMVwiLFxuICAgKiAgICAgb3BlcmE6IFwiMTZcIixcbiAgICogICAgIHBoYW50b206IFwiNTM0XCJcbiAgICogICB9KTtcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgbWluVmVyc2lvbnMgbWFwIG9mIG1pbmltYWwgdmVyc2lvbiB0byBicm93c2VyXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtzdHJpY3RNb2RlID0gZmFsc2VdIGZsYWcgdG8gcmV0dXJuIGZhbHNlIGlmIGJyb3dzZXIgd2Fzbid0IGZvdW5kIGluIG1hcFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBbdWFdIHVzZXIgYWdlbnQgc3RyaW5nXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc1Vuc3VwcG9ydGVkQnJvd3NlcihtaW5WZXJzaW9ucywgc3RyaWN0TW9kZSwgdWEpIHtcbiAgICB2YXIgX2Jvd3NlciA9IGJvd3NlcjtcblxuICAgIC8vIG1ha2Ugc3RyaWN0TW9kZSBwYXJhbSBvcHRpb25hbCB3aXRoIHVhIHBhcmFtIHVzYWdlXG4gICAgaWYgKHR5cGVvZiBzdHJpY3RNb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgdWEgPSBzdHJpY3RNb2RlO1xuICAgICAgc3RyaWN0TW9kZSA9IHZvaWQoMCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cmljdE1vZGUgPT09IHZvaWQoMCkpIHtcbiAgICAgIHN0cmljdE1vZGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHVhKSB7XG4gICAgICBfYm93c2VyID0gZGV0ZWN0KHVhKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IFwiXCIgKyBfYm93c2VyLnZlcnNpb247XG4gICAgZm9yICh2YXIgYnJvd3NlciBpbiBtaW5WZXJzaW9ucykge1xuICAgICAgaWYgKG1pblZlcnNpb25zLmhhc093blByb3BlcnR5KGJyb3dzZXIpKSB7XG4gICAgICAgIGlmIChfYm93c2VyW2Jyb3dzZXJdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtaW5WZXJzaW9uc1ticm93c2VyXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciB2ZXJzaW9uIGluIHRoZSBtaW5WZXJzaW9uIG1hcCBzaG91bGQgYmUgYSBzdHJpbmc6ICcgKyBicm93c2VyICsgJzogJyArIFN0cmluZyhtaW5WZXJzaW9ucykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGJyb3dzZXIgdmVyc2lvbiBhbmQgbWluIHN1cHBvcnRlZCB2ZXJzaW9uLlxuICAgICAgICAgIHJldHVybiBjb21wYXJlVmVyc2lvbnMoW3ZlcnNpb24sIG1pblZlcnNpb25zW2Jyb3dzZXJdXSkgPCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmljdE1vZGU7IC8vIG5vdCBmb3VuZFxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGJyb3dzZXIgaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gbWluVmVyc2lvbnMgbWFwIG9mIG1pbmltYWwgdmVyc2lvbiB0byBicm93c2VyXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtzdHJpY3RNb2RlID0gZmFsc2VdIGZsYWcgdG8gcmV0dXJuIGZhbHNlIGlmIGJyb3dzZXIgd2Fzbid0IGZvdW5kIGluIG1hcFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBbdWFdIHVzZXIgYWdlbnQgc3RyaW5nXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBjaGVjayhtaW5WZXJzaW9ucywgc3RyaWN0TW9kZSwgdWEpIHtcbiAgICByZXR1cm4gIWlzVW5zdXBwb3J0ZWRCcm93c2VyKG1pblZlcnNpb25zLCBzdHJpY3RNb2RlLCB1YSk7XG4gIH1cblxuICBib3dzZXIuaXNVbnN1cHBvcnRlZEJyb3dzZXIgPSBpc1Vuc3VwcG9ydGVkQnJvd3NlcjtcbiAgYm93c2VyLmNvbXBhcmVWZXJzaW9ucyA9IGNvbXBhcmVWZXJzaW9ucztcbiAgYm93c2VyLmNoZWNrID0gY2hlY2s7XG5cbiAgLypcbiAgICogU2V0IG91ciBkZXRlY3QgbWV0aG9kIHRvIHRoZSBtYWluIGJvd3NlciBvYmplY3Qgc28gd2UgY2FuXG4gICAqIHJldXNlIGl0IHRvIHRlc3Qgb3RoZXIgdXNlciBhZ2VudHMuXG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIGltcGxlbWVudCBmdXR1cmUgdGVzdHMuXG4gICAqL1xuICBib3dzZXIuX2RldGVjdCA9IGRldGVjdDtcblxuICAvKlxuICAgKiBTZXQgb3VyIGRldGVjdCBwdWJsaWMgbWV0aG9kIHRvIHRoZSBtYWluIGJvd3NlciBvYmplY3RcbiAgICogVGhpcyBpcyBuZWVkZWQgdG8gaW1wbGVtZW50IGJvd3NlciBpbiBzZXJ2ZXIgc2lkZVxuICAgKi9cbiAgYm93c2VyLmRldGVjdCA9IGRldGVjdDtcbiAgcmV0dXJuIGJvd3NlclxufSk7XG4iLCIiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gIFwiMTAxXCI6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICBcIjEwMlwiOiBcIlByb2Nlc3NpbmdcIixcbiAgXCIyMDBcIjogXCJPS1wiLFxuICBcIjIwMVwiOiBcIkNyZWF0ZWRcIixcbiAgXCIyMDJcIjogXCJBY2NlcHRlZFwiLFxuICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gIFwiMjA0XCI6IFwiTm8gQ29udGVudFwiLFxuICBcIjIwNVwiOiBcIlJlc2V0IENvbnRlbnRcIixcbiAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgXCIyMDdcIjogXCJNdWx0aS1TdGF0dXNcIixcbiAgXCIyMDhcIjogXCJBbHJlYWR5IFJlcG9ydGVkXCIsXG4gIFwiMjI2XCI6IFwiSU0gVXNlZFwiLFxuICBcIjMwMFwiOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgXCIzMDFcIjogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICBcIjMwMlwiOiBcIkZvdW5kXCIsXG4gIFwiMzAzXCI6IFwiU2VlIE90aGVyXCIsXG4gIFwiMzA0XCI6IFwiTm90IE1vZGlmaWVkXCIsXG4gIFwiMzA1XCI6IFwiVXNlIFByb3h5XCIsXG4gIFwiMzA3XCI6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gIFwiMzA4XCI6IFwiUGVybWFuZW50IFJlZGlyZWN0XCIsXG4gIFwiNDAwXCI6IFwiQmFkIFJlcXVlc3RcIixcbiAgXCI0MDFcIjogXCJVbmF1dGhvcml6ZWRcIixcbiAgXCI0MDJcIjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gIFwiNDAzXCI6IFwiRm9yYmlkZGVuXCIsXG4gIFwiNDA0XCI6IFwiTm90IEZvdW5kXCIsXG4gIFwiNDA1XCI6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gIFwiNDA2XCI6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgXCI0MDdcIjogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQwOFwiOiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICBcIjQwOVwiOiBcIkNvbmZsaWN0XCIsXG4gIFwiNDEwXCI6IFwiR29uZVwiLFxuICBcIjQxMVwiOiBcIkxlbmd0aCBSZXF1aXJlZFwiLFxuICBcIjQxMlwiOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgXCI0MTNcIjogXCJQYXlsb2FkIFRvbyBMYXJnZVwiLFxuICBcIjQxNFwiOiBcIlVSSSBUb28gTG9uZ1wiLFxuICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgXCI0MTZcIjogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgXCI0MTdcIjogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgXCI0MThcIjogXCJJJ20gYSB0ZWFwb3RcIixcbiAgXCI0MjFcIjogXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXG4gIFwiNDIyXCI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgXCI0MjRcIjogXCJGYWlsZWQgRGVwZW5kZW5jeVwiLFxuICBcIjQyNVwiOiBcIlVub3JkZXJlZCBDb2xsZWN0aW9uXCIsXG4gIFwiNDI2XCI6IFwiVXBncmFkZSBSZXF1aXJlZFwiLFxuICBcIjQyOFwiOiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gIFwiNDMxXCI6IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiLFxuICBcIjQ1MVwiOiBcIlVuYXZhaWxhYmxlIEZvciBMZWdhbCBSZWFzb25zXCIsXG4gIFwiNTAwXCI6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gIFwiNTAxXCI6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gIFwiNTAyXCI6IFwiQmFkIEdhdGV3YXlcIixcbiAgXCI1MDNcIjogXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCIsXG4gIFwiNTA0XCI6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gIFwiNTA1XCI6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgXCI1MDZcIjogXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiLFxuICBcIjUwN1wiOiBcIkluc3VmZmljaWVudCBTdG9yYWdlXCIsXG4gIFwiNTA4XCI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICBcIjUwOVwiOiBcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFwiLFxuICBcIjUxMFwiOiBcIk5vdCBFeHRlbmRlZFwiLFxuICBcIjUxMVwiOiBcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIk9fUkRPTkxZXCI6IDAsXG4gIFwiT19XUk9OTFlcIjogMSxcbiAgXCJPX1JEV1JcIjogMixcbiAgXCJTX0lGTVRcIjogNjE0NDAsXG4gIFwiU19JRlJFR1wiOiAzMjc2OCxcbiAgXCJTX0lGRElSXCI6IDE2Mzg0LFxuICBcIlNfSUZDSFJcIjogODE5MixcbiAgXCJTX0lGQkxLXCI6IDI0NTc2LFxuICBcIlNfSUZJRk9cIjogNDA5NixcbiAgXCJTX0lGTE5LXCI6IDQwOTYwLFxuICBcIlNfSUZTT0NLXCI6IDQ5MTUyLFxuICBcIk9fQ1JFQVRcIjogNTEyLFxuICBcIk9fRVhDTFwiOiAyMDQ4LFxuICBcIk9fTk9DVFRZXCI6IDEzMTA3MixcbiAgXCJPX1RSVU5DXCI6IDEwMjQsXG4gIFwiT19BUFBFTkRcIjogOCxcbiAgXCJPX0RJUkVDVE9SWVwiOiAxMDQ4NTc2LFxuICBcIk9fTk9GT0xMT1dcIjogMjU2LFxuICBcIk9fU1lOQ1wiOiAxMjgsXG4gIFwiT19TWU1MSU5LXCI6IDIwOTcxNTIsXG4gIFwiT19OT05CTE9DS1wiOiA0LFxuICBcIlNfSVJXWFVcIjogNDQ4LFxuICBcIlNfSVJVU1JcIjogMjU2LFxuICBcIlNfSVdVU1JcIjogMTI4LFxuICBcIlNfSVhVU1JcIjogNjQsXG4gIFwiU19JUldYR1wiOiA1NixcbiAgXCJTX0lSR1JQXCI6IDMyLFxuICBcIlNfSVdHUlBcIjogMTYsXG4gIFwiU19JWEdSUFwiOiA4LFxuICBcIlNfSVJXWE9cIjogNyxcbiAgXCJTX0lST1RIXCI6IDQsXG4gIFwiU19JV09USFwiOiAyLFxuICBcIlNfSVhPVEhcIjogMSxcbiAgXCJFMkJJR1wiOiA3LFxuICBcIkVBQ0NFU1wiOiAxMyxcbiAgXCJFQUREUklOVVNFXCI6IDQ4LFxuICBcIkVBRERSTk9UQVZBSUxcIjogNDksXG4gIFwiRUFGTk9TVVBQT1JUXCI6IDQ3LFxuICBcIkVBR0FJTlwiOiAzNSxcbiAgXCJFQUxSRUFEWVwiOiAzNyxcbiAgXCJFQkFERlwiOiA5LFxuICBcIkVCQURNU0dcIjogOTQsXG4gIFwiRUJVU1lcIjogMTYsXG4gIFwiRUNBTkNFTEVEXCI6IDg5LFxuICBcIkVDSElMRFwiOiAxMCxcbiAgXCJFQ09OTkFCT1JURURcIjogNTMsXG4gIFwiRUNPTk5SRUZVU0VEXCI6IDYxLFxuICBcIkVDT05OUkVTRVRcIjogNTQsXG4gIFwiRURFQURMS1wiOiAxMSxcbiAgXCJFREVTVEFERFJSRVFcIjogMzksXG4gIFwiRURPTVwiOiAzMyxcbiAgXCJFRFFVT1RcIjogNjksXG4gIFwiRUVYSVNUXCI6IDE3LFxuICBcIkVGQVVMVFwiOiAxNCxcbiAgXCJFRkJJR1wiOiAyNyxcbiAgXCJFSE9TVFVOUkVBQ0hcIjogNjUsXG4gIFwiRUlEUk1cIjogOTAsXG4gIFwiRUlMU0VRXCI6IDkyLFxuICBcIkVJTlBST0dSRVNTXCI6IDM2LFxuICBcIkVJTlRSXCI6IDQsXG4gIFwiRUlOVkFMXCI6IDIyLFxuICBcIkVJT1wiOiA1LFxuICBcIkVJU0NPTk5cIjogNTYsXG4gIFwiRUlTRElSXCI6IDIxLFxuICBcIkVMT09QXCI6IDYyLFxuICBcIkVNRklMRVwiOiAyNCxcbiAgXCJFTUxJTktcIjogMzEsXG4gIFwiRU1TR1NJWkVcIjogNDAsXG4gIFwiRU1VTFRJSE9QXCI6IDk1LFxuICBcIkVOQU1FVE9PTE9OR1wiOiA2MyxcbiAgXCJFTkVURE9XTlwiOiA1MCxcbiAgXCJFTkVUUkVTRVRcIjogNTIsXG4gIFwiRU5FVFVOUkVBQ0hcIjogNTEsXG4gIFwiRU5GSUxFXCI6IDIzLFxuICBcIkVOT0JVRlNcIjogNTUsXG4gIFwiRU5PREFUQVwiOiA5NixcbiAgXCJFTk9ERVZcIjogMTksXG4gIFwiRU5PRU5UXCI6IDIsXG4gIFwiRU5PRVhFQ1wiOiA4LFxuICBcIkVOT0xDS1wiOiA3NyxcbiAgXCJFTk9MSU5LXCI6IDk3LFxuICBcIkVOT01FTVwiOiAxMixcbiAgXCJFTk9NU0dcIjogOTEsXG4gIFwiRU5PUFJPVE9PUFRcIjogNDIsXG4gIFwiRU5PU1BDXCI6IDI4LFxuICBcIkVOT1NSXCI6IDk4LFxuICBcIkVOT1NUUlwiOiA5OSxcbiAgXCJFTk9TWVNcIjogNzgsXG4gIFwiRU5PVENPTk5cIjogNTcsXG4gIFwiRU5PVERJUlwiOiAyMCxcbiAgXCJFTk9URU1QVFlcIjogNjYsXG4gIFwiRU5PVFNPQ0tcIjogMzgsXG4gIFwiRU5PVFNVUFwiOiA0NSxcbiAgXCJFTk9UVFlcIjogMjUsXG4gIFwiRU5YSU9cIjogNixcbiAgXCJFT1BOT1RTVVBQXCI6IDEwMixcbiAgXCJFT1ZFUkZMT1dcIjogODQsXG4gIFwiRVBFUk1cIjogMSxcbiAgXCJFUElQRVwiOiAzMixcbiAgXCJFUFJPVE9cIjogMTAwLFxuICBcIkVQUk9UT05PU1VQUE9SVFwiOiA0MyxcbiAgXCJFUFJPVE9UWVBFXCI6IDQxLFxuICBcIkVSQU5HRVwiOiAzNCxcbiAgXCJFUk9GU1wiOiAzMCxcbiAgXCJFU1BJUEVcIjogMjksXG4gIFwiRVNSQ0hcIjogMyxcbiAgXCJFU1RBTEVcIjogNzAsXG4gIFwiRVRJTUVcIjogMTAxLFxuICBcIkVUSU1FRE9VVFwiOiA2MCxcbiAgXCJFVFhUQlNZXCI6IDI2LFxuICBcIkVXT1VMREJMT0NLXCI6IDM1LFxuICBcIkVYREVWXCI6IDE4LFxuICBcIlNJR0hVUFwiOiAxLFxuICBcIlNJR0lOVFwiOiAyLFxuICBcIlNJR1FVSVRcIjogMyxcbiAgXCJTSUdJTExcIjogNCxcbiAgXCJTSUdUUkFQXCI6IDUsXG4gIFwiU0lHQUJSVFwiOiA2LFxuICBcIlNJR0lPVFwiOiA2LFxuICBcIlNJR0JVU1wiOiAxMCxcbiAgXCJTSUdGUEVcIjogOCxcbiAgXCJTSUdLSUxMXCI6IDksXG4gIFwiU0lHVVNSMVwiOiAzMCxcbiAgXCJTSUdTRUdWXCI6IDExLFxuICBcIlNJR1VTUjJcIjogMzEsXG4gIFwiU0lHUElQRVwiOiAxMyxcbiAgXCJTSUdBTFJNXCI6IDE0LFxuICBcIlNJR1RFUk1cIjogMTUsXG4gIFwiU0lHQ0hMRFwiOiAyMCxcbiAgXCJTSUdDT05UXCI6IDE5LFxuICBcIlNJR1NUT1BcIjogMTcsXG4gIFwiU0lHVFNUUFwiOiAxOCxcbiAgXCJTSUdUVElOXCI6IDIxLFxuICBcIlNJR1RUT1VcIjogMjIsXG4gIFwiU0lHVVJHXCI6IDE2LFxuICBcIlNJR1hDUFVcIjogMjQsXG4gIFwiU0lHWEZTWlwiOiAyNSxcbiAgXCJTSUdWVEFMUk1cIjogMjYsXG4gIFwiU0lHUFJPRlwiOiAyNyxcbiAgXCJTSUdXSU5DSFwiOiAyOCxcbiAgXCJTSUdJT1wiOiAyMyxcbiAgXCJTSUdTWVNcIjogMTIsXG4gIFwiU1NMX09QX0FMTFwiOiAyMTQ3NDg2NzE5LFxuICBcIlNTTF9PUF9BTExPV19VTlNBRkVfTEVHQUNZX1JFTkVHT1RJQVRJT05cIjogMjYyMTQ0LFxuICBcIlNTTF9PUF9DSVBIRVJfU0VSVkVSX1BSRUZFUkVOQ0VcIjogNDE5NDMwNCxcbiAgXCJTU0xfT1BfQ0lTQ09fQU5ZQ09OTkVDVFwiOiAzMjc2OCxcbiAgXCJTU0xfT1BfQ09PS0lFX0VYQ0hBTkdFXCI6IDgxOTIsXG4gIFwiU1NMX09QX0NSWVBUT1BST19UTFNFWFRfQlVHXCI6IDIxNDc0ODM2NDgsXG4gIFwiU1NMX09QX0RPTlRfSU5TRVJUX0VNUFRZX0ZSQUdNRU5UU1wiOiAyMDQ4LFxuICBcIlNTTF9PUF9FUEhFTUVSQUxfUlNBXCI6IDAsXG4gIFwiU1NMX09QX0xFR0FDWV9TRVJWRVJfQ09OTkVDVFwiOiA0LFxuICBcIlNTTF9PUF9NSUNST1NPRlRfQklHX1NTTFYzX0JVRkZFUlwiOiAzMixcbiAgXCJTU0xfT1BfTUlDUk9TT0ZUX1NFU1NfSURfQlVHXCI6IDEsXG4gIFwiU1NMX09QX01TSUVfU1NMVjJfUlNBX1BBRERJTkdcIjogMCxcbiAgXCJTU0xfT1BfTkVUU0NBUEVfQ0FfRE5fQlVHXCI6IDUzNjg3MDkxMixcbiAgXCJTU0xfT1BfTkVUU0NBUEVfQ0hBTExFTkdFX0JVR1wiOiAyLFxuICBcIlNTTF9PUF9ORVRTQ0FQRV9ERU1PX0NJUEhFUl9DSEFOR0VfQlVHXCI6IDEwNzM3NDE4MjQsXG4gIFwiU1NMX09QX05FVFNDQVBFX1JFVVNFX0NJUEhFUl9DSEFOR0VfQlVHXCI6IDgsXG4gIFwiU1NMX09QX05PX0NPTVBSRVNTSU9OXCI6IDEzMTA3MixcbiAgXCJTU0xfT1BfTk9fUVVFUllfTVRVXCI6IDQwOTYsXG4gIFwiU1NMX09QX05PX1NFU1NJT05fUkVTVU1QVElPTl9PTl9SRU5FR09USUFUSU9OXCI6IDY1NTM2LFxuICBcIlNTTF9PUF9OT19TU0x2MlwiOiAxNjc3NzIxNixcbiAgXCJTU0xfT1BfTk9fU1NMdjNcIjogMzM1NTQ0MzIsXG4gIFwiU1NMX09QX05PX1RJQ0tFVFwiOiAxNjM4NCxcbiAgXCJTU0xfT1BfTk9fVExTdjFcIjogNjcxMDg4NjQsXG4gIFwiU1NMX09QX05PX1RMU3YxXzFcIjogMjY4NDM1NDU2LFxuICBcIlNTTF9PUF9OT19UTFN2MV8yXCI6IDEzNDIxNzcyOCxcbiAgXCJTU0xfT1BfUEtDUzFfQ0hFQ0tfMVwiOiAwLFxuICBcIlNTTF9PUF9QS0NTMV9DSEVDS18yXCI6IDAsXG4gIFwiU1NMX09QX1NJTkdMRV9ESF9VU0VcIjogMTA0ODU3NixcbiAgXCJTU0xfT1BfU0lOR0xFX0VDREhfVVNFXCI6IDUyNDI4OCxcbiAgXCJTU0xfT1BfU1NMRUFZXzA4MF9DTElFTlRfREhfQlVHXCI6IDEyOCxcbiAgXCJTU0xfT1BfU1NMUkVGMl9SRVVTRV9DRVJUX1RZUEVfQlVHXCI6IDAsXG4gIFwiU1NMX09QX1RMU19CTE9DS19QQURESU5HX0JVR1wiOiA1MTIsXG4gIFwiU1NMX09QX1RMU19ENV9CVUdcIjogMjU2LFxuICBcIlNTTF9PUF9UTFNfUk9MTEJBQ0tfQlVHXCI6IDgzODg2MDgsXG4gIFwiRU5HSU5FX01FVEhPRF9EU0FcIjogMixcbiAgXCJFTkdJTkVfTUVUSE9EX0RIXCI6IDQsXG4gIFwiRU5HSU5FX01FVEhPRF9SQU5EXCI6IDgsXG4gIFwiRU5HSU5FX01FVEhPRF9FQ0RIXCI6IDE2LFxuICBcIkVOR0lORV9NRVRIT0RfRUNEU0FcIjogMzIsXG4gIFwiRU5HSU5FX01FVEhPRF9DSVBIRVJTXCI6IDY0LFxuICBcIkVOR0lORV9NRVRIT0RfRElHRVNUU1wiOiAxMjgsXG4gIFwiRU5HSU5FX01FVEhPRF9TVE9SRVwiOiAyNTYsXG4gIFwiRU5HSU5FX01FVEhPRF9QS0VZX01FVEhTXCI6IDUxMixcbiAgXCJFTkdJTkVfTUVUSE9EX1BLRVlfQVNOMV9NRVRIU1wiOiAxMDI0LFxuICBcIkVOR0lORV9NRVRIT0RfQUxMXCI6IDY1NTM1LFxuICBcIkVOR0lORV9NRVRIT0RfTk9ORVwiOiAwLFxuICBcIkRIX0NIRUNLX1BfTk9UX1NBRkVfUFJJTUVcIjogMixcbiAgXCJESF9DSEVDS19QX05PVF9QUklNRVwiOiAxLFxuICBcIkRIX1VOQUJMRV9UT19DSEVDS19HRU5FUkFUT1JcIjogNCxcbiAgXCJESF9OT1RfU1VJVEFCTEVfR0VORVJBVE9SXCI6IDgsXG4gIFwiTlBOX0VOQUJMRURcIjogMSxcbiAgXCJSU0FfUEtDUzFfUEFERElOR1wiOiAxLFxuICBcIlJTQV9TU0xWMjNfUEFERElOR1wiOiAyLFxuICBcIlJTQV9OT19QQURESU5HXCI6IDMsXG4gIFwiUlNBX1BLQ1MxX09BRVBfUEFERElOR1wiOiA0LFxuICBcIlJTQV9YOTMxX1BBRERJTkdcIjogNSxcbiAgXCJSU0FfUEtDUzFfUFNTX1BBRERJTkdcIjogNixcbiAgXCJQT0lOVF9DT05WRVJTSU9OX0NPTVBSRVNTRURcIjogMixcbiAgXCJQT0lOVF9DT05WRVJTSU9OX1VOQ09NUFJFU1NFRFwiOiA0LFxuICBcIlBPSU5UX0NPTlZFUlNJT05fSFlCUklEXCI6IDYsXG4gIFwiRl9PS1wiOiAwLFxuICBcIlJfT0tcIjogNCxcbiAgXCJXX09LXCI6IDIsXG4gIFwiWF9PS1wiOiAxLFxuICBcIlVWX1VEUF9SRVVTRUFERFJcIjogNFxufVxuIiwiLyohXG4gKiBjb3B5LXRvIC0gaW5kZXguanNcbiAqIENvcHlyaWdodChjKSAyMDE0IGRlYWRfaG9yc2UgPGRlYWRfaG9yc2VAcXEuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIHNsaWNlKCkgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBFeHBvc2UgY29weVxuICpcbiAqIGBgYFxuICogY29weSh7Zm9vOiAnbmFyJywgaGVsbG86ICdjb3B5J30pLnRvKHtoZWxsbzogJ3dvcmxkJ30pO1xuICogY29weSh7Zm9vOiAnbmFyJywgaGVsbG86ICdjb3B5J30pLnRvQ292ZXIoe2hlbGxvOiAnd29ybGQnfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJuIHtDb3B5fVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQ29weTtcblxuXG4vKipcbiAqIENvcHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2l0aEFjY2Vzc1xuICovXG5cbmZ1bmN0aW9uIENvcHkoc3JjLCB3aXRoQWNjZXNzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb3B5KSkgcmV0dXJuIG5ldyBDb3B5KHNyYywgd2l0aEFjY2Vzcyk7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLl93aXRoQWNjZXNzID0gd2l0aEFjY2Vzcztcbn1cblxuLyoqXG4gKiBjb3B5IHByb3BlcnRpZXMgaW5jbHVkZSBnZXR0ZXIgYW5kIHNldHRlclxuICogQHBhcmFtIHtbdHlwZV19IHZhbCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5Db3B5LnByb3RvdHlwZS53aXRoQWNjZXNzID0gZnVuY3Rpb24gKHcpIHtcbiAgdGhpcy5fd2l0aEFjY2VzcyA9IHcgIT09IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogcGljayBrZXlzIGluIHNyY1xuICpcbiAqIEBhcGk6IHB1YmxpY1xuICovXG5cbkNvcHkucHJvdG90eXBlLnBpY2sgPSBmdW5jdGlvbihrZXlzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgIGtleXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIH1cbiAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogY29weSBzcmMgdG8gdGFyZ2V0LFxuICogZG8gbm90IGNvdmVyIGFueSBwcm9wZXJ0eSB0YXJnZXQgaGFzXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqXG4gKiBAYXBpOiBwdWJsaWNcbiAqL1xuXG5Db3B5LnByb3RvdHlwZS50byA9IGZ1bmN0aW9uKHRvKSB7XG4gIHRvID0gdG8gfHwge307XG5cbiAgaWYgKCF0aGlzLnNyYykgcmV0dXJuIHRvO1xuICB2YXIga2V5cyA9IHRoaXMua2V5cyB8fCBPYmplY3Qua2V5cyh0aGlzLnNyYyk7XG5cbiAgaWYgKCF0aGlzLl93aXRoQWNjZXNzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHRvW2tleV0gIT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICB0b1trZXldID0gdGhpcy5zcmNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRvO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFub3REZWZpbmVkKHRvLCBrZXkpKSBjb250aW51ZTtcbiAgICB2YXIgZ2V0dGVyID0gdGhpcy5zcmMuX19sb29rdXBHZXR0ZXJfXyhrZXkpO1xuICAgIHZhciBzZXR0ZXIgPSB0aGlzLnNyYy5fX2xvb2t1cFNldHRlcl9fKGtleSk7XG4gICAgaWYgKGdldHRlcikgdG8uX19kZWZpbmVHZXR0ZXJfXyhrZXksIGdldHRlcik7XG4gICAgaWYgKHNldHRlcikgdG8uX19kZWZpbmVTZXR0ZXJfXyhrZXksIHNldHRlcik7XG5cbiAgICBpZiAoIWdldHRlciAmJiAhc2V0dGVyKSB7XG4gICAgICB0b1trZXldID0gdGhpcy5zcmNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcblxuLyoqXG4gKiBjb3B5IHNyYyB0byB0YXJnZXQsXG4gKiBvdmVycmlkZSBhbnkgcHJvcGVydHkgdGFyZ2V0IGhhc1xuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKlxuICogQGFwaTogcHVibGljXG4gKi9cblxuQ29weS5wcm90b3R5cGUudG9Db3ZlciA9IGZ1bmN0aW9uKHRvKSB7XG4gIHZhciBrZXlzID0gdGhpcy5rZXlzIHx8IE9iamVjdC5rZXlzKHRoaXMuc3JjKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWxldGUgdG9ba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdGhpcy5zcmMuX19sb29rdXBHZXR0ZXJfXyhrZXkpO1xuICAgIHZhciBzZXR0ZXIgPSB0aGlzLnNyYy5fX2xvb2t1cFNldHRlcl9fKGtleSk7XG4gICAgaWYgKGdldHRlcikgdG8uX19kZWZpbmVHZXR0ZXJfXyhrZXksIGdldHRlcik7XG4gICAgaWYgKHNldHRlcikgdG8uX19kZWZpbmVTZXR0ZXJfXyhrZXksIHNldHRlcik7XG5cbiAgICBpZiAoIWdldHRlciAmJiAhc2V0dGVyKSB7XG4gICAgICB0b1trZXldID0gdGhpcy5zcmNba2V5XTtcbiAgICB9XG4gIH1cbn07XG5cbkNvcHkucHJvdG90eXBlLm92ZXJyaWRlID0gQ29weS5wcm90b3R5cGUudG9Db3ZlcjtcblxuLyoqXG4gKiBhcHBlbmQgYW5vdGhlciBvYmplY3QgdG8gc3JjXG4gKiBAcGFyYW0ge09ian0gb2JqXG4gKiBAcmV0dXJuIHtDb3B5fVxuICovXG5cbkNvcHkucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHNyYyA9IHt9O1xuICB0aGlzLnRvKHNyYyk7XG4gIHRoaXMuc3JjID0gb2JqO1xuICB0aGlzLnRvKHNyYyk7XG4gIHRoaXMuc3JjID0gc3JjO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBjaGVjayBvYmpba2V5XSBpZiBub3QgZGVmaWVuZFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBub3REZWZpbmVkKG9iaiwga2V5KSB7XG4gIHJldHVybiBvYmpba2V5XSA9PT0gdW5kZWZpbmVkXG4gICAgJiYgb2JqLl9fbG9va3VwR2V0dGVyX18oa2V5KSA9PT0gdW5kZWZpbmVkXG4gICAgJiYgb2JqLl9fbG9va3VwU2V0dGVyX18oa2V5KSA9PT0gdW5kZWZpbmVkO1xufVxuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mcm9tO1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJyk7XG52YXIgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHsgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSB9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkge1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuICRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Qua2V5cztcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnByb21pc2UudHJ5Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5Qcm9taXNlO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5zZXRJbW1lZGlhdGU7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TdHJpbmcuZnJvbUNvZGVQb2ludDtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaGFzSW5zdGFuY2UnKTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjUnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYgaGFzKGV4cG9ydHMsIGtleSkpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgU2FmYXJpIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICB9IGVsc2UgaWYgKE9ic2VydmVyICYmICEoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnN0YW5kYWxvbmUpKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZiAoIWhlYWQpIHtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxuZnVuY3Rpb24gUHJvbWlzZUNhcGFiaWxpdHkoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAoc2FmZSAmJiB0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICBlbHNlIGhpZGUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IHR5cGVvZiBjb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IGNvcmVbS0VZXSA6IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG4iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IHJlcXVpcmUoJy4vX2xpYnJhcnknKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIEhBU19JTlNUQU5DRSA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpO1xudmFyIEZ1bmN0aW9uUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcbmlmICghKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSkgcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihGdW5jdGlvblByb3RvLCBIQVNfSU5TVEFOQ0UsIHsgdmFsdWU6IGZ1bmN0aW9uIChPKSB7XG4gIGlmICh0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSkgcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKSBpZiAodGhpcy5wcm90b3R5cGUgPT09IE8pIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59IH0pO1xuIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG4iLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pO1xuIiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnM7XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52OCB8fCAnJztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpXG4gICAgICAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2VcbiAgICAgIC8vIHY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcbiAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAgICAgLy8gd2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgICAgICYmIHY4LmluZGV4T2YoJzYuNicpICE9PSAwXG4gICAgICAmJiB1c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lLzY2JykgPT09IC0xO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIG1heSB0aHJvd1xuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGRvbWFpbiAmJiAhZXhpdGVkKSBkb21haW4uZXhpdCgpO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UuX2ggIT09IDEgJiYgKHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYykubGVuZ3RoID09PSAwO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgY29kZTtcbiAgICB3aGlsZSAoYUxlbiA+IGkpIHtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZiAodG9BYnNvbHV0ZUluZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSkgdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLWZpbmFsbHlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdQcm9taXNlJywgeyAnZmluYWxseSc6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKTtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2Ygb25GaW5hbGx5ID09ICdmdW5jdGlvbic7XG4gIHJldHVybiB0aGlzLnRoZW4oXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG4gICAgfSA6IG9uRmluYWxseSxcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IGU7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHlcbiAgKTtcbn0gfSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLXRyeVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1Byb21pc2UnLCB7ICd0cnknOiBmdW5jdGlvbiAoY2FsbGJhY2tmbikge1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gcGVyZm9ybShjYWxsYmFja2ZuKTtcbiAgKHJlc3VsdC5lID8gcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0IDogcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZSkocmVzdWx0LnYpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn0gfSk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxudmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICtcbiAgJ0RPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsJyArXG4gICdNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LCcgK1xuICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArXG4gICdUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCcpLnNwbGl0KCcsJyk7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gRE9NSXRlcmFibGVzW2ldO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHRhc2sgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8qXHJcbiAqIERhdGUgRm9ybWF0IDEuMi4zXHJcbiAqIChjKSAyMDA3LTIwMDkgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XHJcbiAqIE1JVCBsaWNlbnNlXHJcbiAqXHJcbiAqIEluY2x1ZGVzIGVuaGFuY2VtZW50cyBieSBTY290dCBUcmVuZGEgPHNjb3R0LnRyZW5kYS5uZXQ+XHJcbiAqIGFuZCBLcmlzIEtvd2FsIDxjaXhhci5jb20vfmtyaXMua293YWwvPlxyXG4gKlxyXG4gKiBBY2NlcHRzIGEgZGF0ZSwgYSBtYXNrLCBvciBhIGRhdGUgYW5kIGEgbWFzay5cclxuICogUmV0dXJucyBhIGZvcm1hdHRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBkYXRlLlxyXG4gKiBUaGUgZGF0ZSBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBkYXRlL3RpbWUuXHJcbiAqIFRoZSBtYXNrIGRlZmF1bHRzIHRvIGRhdGVGb3JtYXQubWFza3MuZGVmYXVsdC5cclxuICovXHJcblxyXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgZGF0ZUZvcm1hdCA9IChmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHRva2VuID0gL2R7MSw0fXxtezEsNH18eXkoPzp5eSk/fChbSGhNc1R0XSlcXDE/fFtMbG9TWldOXXwnW14nXSonfCdbXiddKicvZztcclxuICAgICAgdmFyIHRpbWV6b25lID0gL1xcYig/OltQTUNFQV1bU0RQXVR8KD86UGFjaWZpY3xNb3VudGFpbnxDZW50cmFsfEVhc3Rlcm58QXRsYW50aWMpICg/OlN0YW5kYXJkfERheWxpZ2h0fFByZXZhaWxpbmcpIFRpbWV8KD86R01UfFVUQykoPzpbLStdXFxkezR9KT8pXFxiL2c7XHJcbiAgICAgIHZhciB0aW1lem9uZUNsaXAgPSAvW14tK1xcZEEtWl0vZztcclxuICBcclxuICAgICAgLy8gUmVnZXhlcyBhbmQgc3VwcG9ydGluZyBmdW5jdGlvbnMgYXJlIGNhY2hlZCB0aHJvdWdoIGNsb3N1cmVcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBtYXNrLCB1dGMsIGdtdCkge1xyXG4gIFxyXG4gICAgICAgIC8vIFlvdSBjYW4ndCBwcm92aWRlIHV0YyBpZiB5b3Ugc2tpcCBvdGhlciBhcmdzICh1c2UgdGhlICdVVEM6JyBtYXNrIHByZWZpeClcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBraW5kT2YoZGF0ZSkgPT09ICdzdHJpbmcnICYmICEvXFxkLy50ZXN0KGRhdGUpKSB7XHJcbiAgICAgICAgICBtYXNrID0gZGF0ZTtcclxuICAgICAgICAgIGRhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIGRhdGUgPSBkYXRlIHx8IG5ldyBEYXRlO1xyXG4gIFxyXG4gICAgICAgIGlmKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSB7XHJcbiAgICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIGlmIChpc05hTihkYXRlKSkge1xyXG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIGRhdGUnKTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgbWFzayA9IFN0cmluZyhkYXRlRm9ybWF0Lm1hc2tzW21hc2tdIHx8IG1hc2sgfHwgZGF0ZUZvcm1hdC5tYXNrc1snZGVmYXVsdCddKTtcclxuICBcclxuICAgICAgICAvLyBBbGxvdyBzZXR0aW5nIHRoZSB1dGMvZ210IGFyZ3VtZW50IHZpYSB0aGUgbWFza1xyXG4gICAgICAgIHZhciBtYXNrU2xpY2UgPSBtYXNrLnNsaWNlKDAsIDQpO1xyXG4gICAgICAgIGlmIChtYXNrU2xpY2UgPT09ICdVVEM6JyB8fCBtYXNrU2xpY2UgPT09ICdHTVQ6Jykge1xyXG4gICAgICAgICAgbWFzayA9IG1hc2suc2xpY2UoNCk7XHJcbiAgICAgICAgICB1dGMgPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKG1hc2tTbGljZSA9PT0gJ0dNVDonKSB7XHJcbiAgICAgICAgICAgIGdtdCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIHZhciBfID0gdXRjID8gJ2dldFVUQycgOiAnZ2V0JztcclxuICAgICAgICB2YXIgZCA9IGRhdGVbXyArICdEYXRlJ10oKTtcclxuICAgICAgICB2YXIgRCA9IGRhdGVbXyArICdEYXknXSgpO1xyXG4gICAgICAgIHZhciBtID0gZGF0ZVtfICsgJ01vbnRoJ10oKTtcclxuICAgICAgICB2YXIgeSA9IGRhdGVbXyArICdGdWxsWWVhciddKCk7XHJcbiAgICAgICAgdmFyIEggPSBkYXRlW18gKyAnSG91cnMnXSgpO1xyXG4gICAgICAgIHZhciBNID0gZGF0ZVtfICsgJ01pbnV0ZXMnXSgpO1xyXG4gICAgICAgIHZhciBzID0gZGF0ZVtfICsgJ1NlY29uZHMnXSgpO1xyXG4gICAgICAgIHZhciBMID0gZGF0ZVtfICsgJ01pbGxpc2Vjb25kcyddKCk7XHJcbiAgICAgICAgdmFyIG8gPSB1dGMgPyAwIDogZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gICAgICAgIHZhciBXID0gZ2V0V2VlayhkYXRlKTtcclxuICAgICAgICB2YXIgTiA9IGdldERheU9mV2VlayhkYXRlKTtcclxuICAgICAgICB2YXIgZmxhZ3MgPSB7XHJcbiAgICAgICAgICBkOiAgICBkLFxyXG4gICAgICAgICAgZGQ6ICAgcGFkKGQpLFxyXG4gICAgICAgICAgZGRkOiAgZGF0ZUZvcm1hdC5pMThuLmRheU5hbWVzW0RdLFxyXG4gICAgICAgICAgZGRkZDogZGF0ZUZvcm1hdC5pMThuLmRheU5hbWVzW0QgKyA3XSxcclxuICAgICAgICAgIG06ICAgIG0gKyAxLFxyXG4gICAgICAgICAgbW06ICAgcGFkKG0gKyAxKSxcclxuICAgICAgICAgIG1tbTogIGRhdGVGb3JtYXQuaTE4bi5tb250aE5hbWVzW21dLFxyXG4gICAgICAgICAgbW1tbTogZGF0ZUZvcm1hdC5pMThuLm1vbnRoTmFtZXNbbSArIDEyXSxcclxuICAgICAgICAgIHl5OiAgIFN0cmluZyh5KS5zbGljZSgyKSxcclxuICAgICAgICAgIHl5eXk6IHksXHJcbiAgICAgICAgICBoOiAgICBIICUgMTIgfHwgMTIsXHJcbiAgICAgICAgICBoaDogICBwYWQoSCAlIDEyIHx8IDEyKSxcclxuICAgICAgICAgIEg6ICAgIEgsXHJcbiAgICAgICAgICBISDogICBwYWQoSCksXHJcbiAgICAgICAgICBNOiAgICBNLFxyXG4gICAgICAgICAgTU06ICAgcGFkKE0pLFxyXG4gICAgICAgICAgczogICAgcyxcclxuICAgICAgICAgIHNzOiAgIHBhZChzKSxcclxuICAgICAgICAgIGw6ICAgIHBhZChMLCAzKSxcclxuICAgICAgICAgIEw6ICAgIHBhZChNYXRoLnJvdW5kKEwgLyAxMCkpLFxyXG4gICAgICAgICAgdDogICAgSCA8IDEyID8gJ2EnICA6ICdwJyxcclxuICAgICAgICAgIHR0OiAgIEggPCAxMiA/ICdhbScgOiAncG0nLFxyXG4gICAgICAgICAgVDogICAgSCA8IDEyID8gJ0EnICA6ICdQJyxcclxuICAgICAgICAgIFRUOiAgIEggPCAxMiA/ICdBTScgOiAnUE0nLFxyXG4gICAgICAgICAgWjogICAgZ210ID8gJ0dNVCcgOiB1dGMgPyAnVVRDJyA6IChTdHJpbmcoZGF0ZSkubWF0Y2godGltZXpvbmUpIHx8IFsnJ10pLnBvcCgpLnJlcGxhY2UodGltZXpvbmVDbGlwLCAnJyksXHJcbiAgICAgICAgICBvOiAgICAobyA+IDAgPyAnLScgOiAnKycpICsgcGFkKE1hdGguZmxvb3IoTWF0aC5hYnMobykgLyA2MCkgKiAxMDAgKyBNYXRoLmFicyhvKSAlIDYwLCA0KSxcclxuICAgICAgICAgIFM6ICAgIFsndGgnLCAnc3QnLCAnbmQnLCAncmQnXVtkICUgMTAgPiAzID8gMCA6IChkICUgMTAwIC0gZCAlIDEwICE9IDEwKSAqIGQgJSAxMF0sXHJcbiAgICAgICAgICBXOiAgICBXLFxyXG4gICAgICAgICAgTjogICAgTlxyXG4gICAgICAgIH07XHJcbiAgXHJcbiAgICAgICAgcmV0dXJuIG1hc2sucmVwbGFjZSh0b2tlbiwgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICBpZiAobWF0Y2ggaW4gZmxhZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZsYWdzW21hdGNoXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBtYXRjaC5zbGljZSgxLCBtYXRjaC5sZW5ndGggLSAxKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG4gIGRhdGVGb3JtYXQubWFza3MgPSB7XHJcbiAgICAnZGVmYXVsdCc6ICAgICAgICAgICAgICAgJ2RkZCBtbW0gZGQgeXl5eSBISDpNTTpzcycsXHJcbiAgICAnc2hvcnREYXRlJzogICAgICAgICAgICAgJ20vZC95eScsXHJcbiAgICAnbWVkaXVtRGF0ZSc6ICAgICAgICAgICAgJ21tbSBkLCB5eXl5JyxcclxuICAgICdsb25nRGF0ZSc6ICAgICAgICAgICAgICAnbW1tbSBkLCB5eXl5JyxcclxuICAgICdmdWxsRGF0ZSc6ICAgICAgICAgICAgICAnZGRkZCwgbW1tbSBkLCB5eXl5JyxcclxuICAgICdzaG9ydFRpbWUnOiAgICAgICAgICAgICAnaDpNTSBUVCcsXHJcbiAgICAnbWVkaXVtVGltZSc6ICAgICAgICAgICAgJ2g6TU06c3MgVFQnLFxyXG4gICAgJ2xvbmdUaW1lJzogICAgICAgICAgICAgICdoOk1NOnNzIFRUIFonLFxyXG4gICAgJ2lzb0RhdGUnOiAgICAgICAgICAgICAgICd5eXl5LW1tLWRkJyxcclxuICAgICdpc29UaW1lJzogICAgICAgICAgICAgICAnSEg6TU06c3MnLFxyXG4gICAgJ2lzb0RhdGVUaW1lJzogICAgICAgICAgICd5eXl5LW1tLWRkXFwnVFxcJ0hIOk1NOnNzbycsXHJcbiAgICAnaXNvVXRjRGF0ZVRpbWUnOiAgICAgICAgJ1VUQzp5eXl5LW1tLWRkXFwnVFxcJ0hIOk1NOnNzXFwnWlxcJycsXHJcbiAgICAnZXhwaXJlc0hlYWRlckZvcm1hdCc6ICAgJ2RkZCwgZGQgbW1tIHl5eXkgSEg6TU06c3MgWidcclxuICB9O1xyXG5cclxuICAvLyBJbnRlcm5hdGlvbmFsaXphdGlvbiBzdHJpbmdzXHJcbiAgZGF0ZUZvcm1hdC5pMThuID0ge1xyXG4gICAgZGF5TmFtZXM6IFtcclxuICAgICAgJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCcsXHJcbiAgICAgICdTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSdcclxuICAgIF0sXHJcbiAgICBtb250aE5hbWVzOiBbXHJcbiAgICAgICdKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYycsXHJcbiAgICAgICdKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ1xyXG4gICAgXVxyXG4gIH07XHJcblxyXG5mdW5jdGlvbiBwYWQodmFsLCBsZW4pIHtcclxuICB2YWwgPSBTdHJpbmcodmFsKTtcclxuICBsZW4gPSBsZW4gfHwgMjtcclxuICB3aGlsZSAodmFsLmxlbmd0aCA8IGxlbikge1xyXG4gICAgdmFsID0gJzAnICsgdmFsO1xyXG4gIH1cclxuICByZXR1cm4gdmFsO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBJU08gODYwMSB3ZWVrIG51bWJlclxyXG4gKiBCYXNlZCBvbiBjb21tZW50cyBmcm9tXHJcbiAqIGh0dHA6Ly90ZWNoYmxvZy5wcm9jdXJpb3Mubmwvay9uNjE4L25ld3Mvdmlldy8zMzc5Ni8xNDg2My9DYWxjdWxhdGUtSVNPLTg2MDEtd2Vlay1hbmQteWVhci1pbi1qYXZhc2NyaXB0Lmh0bWxcclxuICpcclxuICogQHBhcmFtICB7T2JqZWN0fSBgZGF0ZWBcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0V2VlayhkYXRlKSB7XHJcbiAgLy8gUmVtb3ZlIHRpbWUgY29tcG9uZW50cyBvZiBkYXRlXHJcbiAgdmFyIHRhcmdldFRodXJzZGF5ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcclxuXHJcbiAgLy8gQ2hhbmdlIGRhdGUgdG8gVGh1cnNkYXkgc2FtZSB3ZWVrXHJcbiAgdGFyZ2V0VGh1cnNkYXkuc2V0RGF0ZSh0YXJnZXRUaHVyc2RheS5nZXREYXRlKCkgLSAoKHRhcmdldFRodXJzZGF5LmdldERheSgpICsgNikgJSA3KSArIDMpO1xyXG5cclxuICAvLyBUYWtlIEphbnVhcnkgNHRoIGFzIGl0IGlzIGFsd2F5cyBpbiB3ZWVrIDEgKHNlZSBJU08gODYwMSlcclxuICB2YXIgZmlyc3RUaHVyc2RheSA9IG5ldyBEYXRlKHRhcmdldFRodXJzZGF5LmdldEZ1bGxZZWFyKCksIDAsIDQpO1xyXG5cclxuICAvLyBDaGFuZ2UgZGF0ZSB0byBUaHVyc2RheSBzYW1lIHdlZWtcclxuICBmaXJzdFRodXJzZGF5LnNldERhdGUoZmlyc3RUaHVyc2RheS5nZXREYXRlKCkgLSAoKGZpcnN0VGh1cnNkYXkuZ2V0RGF5KCkgKyA2KSAlIDcpICsgMyk7XHJcblxyXG4gIC8vIENoZWNrIGlmIGRheWxpZ2h0LXNhdmluZy10aW1lLXN3aXRjaCBvY2N1cnJlZCBhbmQgY29ycmVjdCBmb3IgaXRcclxuICB2YXIgZHMgPSB0YXJnZXRUaHVyc2RheS5nZXRUaW1lem9uZU9mZnNldCgpIC0gZmlyc3RUaHVyc2RheS5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gIHRhcmdldFRodXJzZGF5LnNldEhvdXJzKHRhcmdldFRodXJzZGF5LmdldEhvdXJzKCkgLSBkcyk7XHJcblxyXG4gIC8vIE51bWJlciBvZiB3ZWVrcyBiZXR3ZWVuIHRhcmdldCBUaHVyc2RheSBhbmQgZmlyc3QgVGh1cnNkYXlcclxuICB2YXIgd2Vla0RpZmYgPSAodGFyZ2V0VGh1cnNkYXkgLSBmaXJzdFRodXJzZGF5KSAvICg4NjQwMDAwMCo3KTtcclxuICByZXR1cm4gMSArIE1hdGguZmxvb3Iod2Vla0RpZmYpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IElTTy04NjAxIG51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRheSBvZiB0aGUgd2Vla1xyXG4gKiAxIChmb3IgTW9uZGF5KSB0aHJvdWdoIDcgKGZvciBTdW5kYXkpXHJcbiAqIFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBkYXRlYFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREYXlPZldlZWsoZGF0ZSkge1xyXG4gIHZhciBkb3cgPSBkYXRlLmdldERheSgpO1xyXG4gIGlmKGRvdyA9PT0gMCkge1xyXG4gICAgZG93ID0gNztcclxuICB9XHJcbiAgcmV0dXJuIGRvdztcclxufVxyXG5cclxuLyoqXHJcbiAqIGtpbmQtb2Ygc2hvcnRjdXRcclxuICogQHBhcmFtICB7Kn0gdmFsXHJcbiAqIEByZXR1cm4ge1N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcclxuICBpZiAodmFsID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gJ251bGwnO1xyXG4gIH1cclxuXHJcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsO1xyXG4gIH1cclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgcmV0dXJuICdhcnJheSc7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh2YWwpXHJcbiAgICAuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XHJcbn07XHJcblxyXG5cclxuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIGRhdGVGb3JtYXQ7XHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkYXRlRm9ybWF0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBnbG9iYWwuZGF0ZUZvcm1hdCA9IGRhdGVGb3JtYXQ7XHJcbiAgfVxyXG59KSh0aGlzKTtcclxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qIVxuICogZXNjYXBlLWh0bWxcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTMgVEogSG9sb3dheWNodWtcbiAqIENvcHlyaWdodChjKSAyMDE1IEFuZHJlYXMgTHViYmVcbiAqIENvcHlyaWdodChjKSAyMDE1IFRpYW5jaGVuZyBcIlRpbW90aHlcIiBHdVxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlSHRtbDtcblxuLyoqXG4gKiBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBzdHJpbmcgb2YgaHRtbC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZSBmb3IgaW5zZXJ0aW5nIGludG8gSFRNTFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIHZhciBzdHIgPSAnJyArIHN0cmluZztcbiAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWMoc3RyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBlc2NhcGU7XG4gIHZhciBodG1sID0gJyc7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0SW5kZXggPSAwO1xuXG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgIGNhc2UgMzQ6IC8vIFwiXG4gICAgICAgIGVzY2FwZSA9ICcmcXVvdDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6IC8vICZcbiAgICAgICAgZXNjYXBlID0gJyZhbXA7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM5OiAvLyAnXG4gICAgICAgIGVzY2FwZSA9ICcmIzM5Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDogLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjogLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleFxuICAgID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleClcbiAgICA6IGh0bWw7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcblxudmFyIGh0dHBzID0gbW9kdWxlLmV4cG9ydHM7XG5cbmZvciAodmFyIGtleSBpbiBodHRwKSB7XG4gICAgaWYgKGh0dHAuaGFzT3duUHJvcGVydHkoa2V5KSkgaHR0cHNba2V5XSA9IGh0dHBba2V5XTtcbn07XG5cbmh0dHBzLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICBwYXJhbXMuc2NoZW1lID0gJ2h0dHBzJztcbiAgICBwYXJhbXMucHJvdG9jb2wgPSAnaHR0cHM6JztcbiAgICByZXR1cm4gaHR0cC5yZXF1ZXN0LmNhbGwodGhpcywgcGFyYW1zLCBjYik7XG59XG4iLCIvKiFcbiAqIGh1bWFuaXplLW1zIC0gaW5kZXguanNcbiAqIENvcHlyaWdodChjKSAyMDE0IGRlYWRfaG9yc2UgPGRlYWRfaG9yc2VAcXEuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgbXMgPSByZXF1aXJlKCdtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0KSB7XG4gIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicpIHJldHVybiB0O1xuICB2YXIgciA9IG1zKHQpO1xuICBpZiAociA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnaHVtYW5pemUtbXMoJWopIHJlc3VsdCB1bmRlZmluZWQnLCB0KSk7XG4gICAgY29uc29sZS53YXJuKGVyci5zdGFjayk7XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIihmdW5jdGlvbihyb290KSB7XG4gIHZhciB0b1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuICBmdW5jdGlvbiBmbkJvZHkoZm4pIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChmbikucmVwbGFjZSgvXltee10qe1xccyovLCcnKS5yZXBsYWNlKC9cXHMqfVtefV0qJC8sJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDbGFzcyhmbikge1xuICAgIHJldHVybiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAoL15jbGFzcyg/Olxcc3x7KS8udGVzdCh0b1N0cmluZy5jYWxsKGZuKSkgfHxcbiAgICAgICAgICAgICAgKC9eLipjbGFzc0NhbGxDaGVja1xcKC8udGVzdChmbkJvZHkoZm4pKSkpIC8vIGJhYmVsLmpzXG4gICAgICAgICAgICApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaXNDbGFzcztcbiAgICB9XG4gICAgZXhwb3J0cy5pc0NsYXNzID0gaXNDbGFzcztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzQ2xhc3M7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5pc0NsYXNzID0gaXNDbGFzcztcbiAgfVxuXG59KSh0aGlzKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG52YXIgaXNTdGVhcm0gPSByZXF1aXJlKCdpc3N0cmVhbScpO1xuLy8gd2FpdCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbG1vdGEvaXMtY2xhc3MvcHVsbC82IG1lcmdlXG52YXIgaXNDbGFzcyA9IHJlcXVpcmUoJ2lzLWNsYXNzLWhvdGZpeCcpO1xuXG4vKipcbiAqIEV4cG9zZSBhbGwgbWV0aG9kcyBpbiBjb3JlLXV0aWwtaXNcbiAqL1xuXG5PYmplY3Qua2V5cyh1dGlscykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gIGV4cG9ydHNbdHJhbnNmb3JtKG5hbWUpXSA9IHV0aWxzW25hbWVdO1xufSk7XG5cbi8qKlxuICogU3RyZWFtIGRldGVjdGVkIGJ5IGlzc3RyZWFtXG4gKi9cblxuZXhwb3J0cy5zdHJlYW0gPSBpc1N0ZWFybTtcbmV4cG9ydHMucmVhZGFibGVTdHJlYW0gPSBpc1N0ZWFybS5pc1JlYWRhYmxlO1xuZXhwb3J0cy53cml0YWJsZVN0cmVhbSA9IGlzU3RlYXJtLmlzV3JpdGFibGU7XG5leHBvcnRzLmR1cGxleFN0cmVhbSA9IGlzU3RlYXJtLmlzRHVwbGV4O1xuXG4vKipcbiAqIENsYXNzIGRldGVjdGVkIGJ5IGlzLWNsYXNzXG4gKi9cbiBleHBvcnRzLmNsYXNzID0gaXNDbGFzcztcblxuLyoqXG4gKiBFeHRlbmQgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5maW5pdGUgPSBOdW1iZXIuaXNGaW5pdGU7XG5cbmV4cG9ydHMuTmFOID0gTnVtYmVyLmlzTmFOXG5cbmV4cG9ydHMuZ2VuZXJhdG9yID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqXG4gICAgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9iai5uZXh0XG4gICAgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9iai50aHJvdztcbn07XG5cbmV4cG9ydHMuZ2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmpcbiAgICAmJiBvYmouY29uc3RydWN0b3JcbiAgICAmJiAnR2VuZXJhdG9yRnVuY3Rpb24nID09PSBvYmouY29uc3RydWN0b3IubmFtZTtcbn07XG5cbmV4cG9ydHMuYXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9ialxuICAgICYmIG9iai5jb25zdHJ1Y3RvclxuICAgICYmICdBc3luY0Z1bmN0aW9uJyA9PT0gb2JqLmNvbnN0cnVjdG9yLm5hbWU7XG59O1xuXG5leHBvcnRzLnByb21pc2UgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmpcbiAgICAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2Ygb2JqLnRoZW47XG59O1xuXG52YXIgTUFYX0lOVF8zMSA9IE1hdGgucG93KDIsIDMxKTtcblxuZXhwb3J0cy5pbnQgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB1dGlscy5pc051bWJlcihvYmopXG4gICAgJiYgb2JqICUgMSA9PT0gMDtcbn07XG5cbmV4cG9ydHMuaW50MzIgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBleHBvcnRzLmludChvYmopXG4gICAgJiYgb2JqIDwgTUFYX0lOVF8zMVxuICAgICYmIG9iaiA+PSAtTUFYX0lOVF8zMTtcbn07XG5cbmV4cG9ydHMubG9uZyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIGV4cG9ydHMuaW50KG9iailcbiAgICAmJiAob2JqID49IE1BWF9JTlRfMzEgfHwgb2JqIDwgLU1BWF9JTlRfMzEpO1xufTtcblxuZXhwb3J0cy5Mb25nID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gZXhwb3J0cy5vYmplY3Qob2JqKVxuICAgICYmIGV4cG9ydHMubnVtYmVyKG9iai5oaWdoKVxuICAgICYmIGV4cG9ydHMubnVtYmVyKG9iai5sb3cpO1xufTtcblxuZXhwb3J0cy5kb3VibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB1dGlscy5pc051bWJlcihvYmopXG4gICAgJiYgIWlzTmFOKG9iailcbiAgICAmJiBvYmogJSAxICE9PSAwO1xufTtcblxuLyoqXG4gKiBvdmVycmlkZSBjb3JlLXV0aWwtaXNcbiAqL1xuXG5leHBvcnRzLmRhdGUgPSBmdW5jdGlvbiBpc0RhdGUob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBEYXRlO1xufTtcblxuZXhwb3J0cy5yZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFJlZ0V4cDtcbn07XG5leHBvcnRzLnJlZ2V4cCA9IGV4cG9ydHMucmVnRXhwO1xuXG5leHBvcnRzLmVycm9yID0gZnVuY3Rpb24gaXNFcnJvcihvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVycm9yO1xufTtcblxuZXhwb3J0cy5hcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogdHJhbnNmb3JtIGlzTnVsbCB0eXBlIHRvIG51bGxcbiAqIEBwYXJhbSB7W3R5cGVdfSBtIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShtKSB7XG4gIHZhciBuYW1lID0gbS5zbGljZSgyKTtcbiAgbmFtZSA9IG5hbWVbMF0udG9Mb3dlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gIHJldHVybiBuYW1lO1xufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJ2YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcblxuXG5mdW5jdGlvbiBpc1N0cmVhbSAob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBzdHJlYW0uU3RyZWFtXG59XG5cblxuZnVuY3Rpb24gaXNSZWFkYWJsZSAob2JqKSB7XG4gIHJldHVybiBpc1N0cmVhbShvYmopICYmIHR5cGVvZiBvYmouX3JlYWQgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLl9yZWFkYWJsZVN0YXRlID09ICdvYmplY3QnXG59XG5cblxuZnVuY3Rpb24gaXNXcml0YWJsZSAob2JqKSB7XG4gIHJldHVybiBpc1N0cmVhbShvYmopICYmIHR5cGVvZiBvYmouX3dyaXRlID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5fd3JpdGFibGVTdGF0ZSA9PSAnb2JqZWN0J1xufVxuXG5cbmZ1bmN0aW9uIGlzRHVwbGV4IChvYmopIHtcbiAgcmV0dXJuIGlzUmVhZGFibGUob2JqKSAmJiBpc1dyaXRhYmxlKG9iailcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyAgICAgICAgICAgID0gaXNTdHJlYW1cbm1vZHVsZS5leHBvcnRzLmlzUmVhZGFibGUgPSBpc1JlYWRhYmxlXG5tb2R1bGUuZXhwb3J0cy5pc1dyaXRhYmxlID0gaXNXcml0YWJsZVxubW9kdWxlLmV4cG9ydHMuaXNEdXBsZXggICA9IGlzRHVwbGV4XG4iLCIvKiFcbiAqIG1lcmdlLWRlc2NyaXB0b3JzXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlXG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXG4vKipcbiAqIE1lcmdlIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBvZiBgc3JjYCBpbnRvIGBkZXN0YFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXN0IE9iamVjdCB0byBhZGQgZGVzY3JpcHRvcnMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBzcmMgT2JqZWN0IHRvIGNsb25lIGRlc2NyaXB0b3JzIGZyb21cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZGVmaW5lPXRydWVdIFJlZGVmaW5lIGBkZXN0YCBwcm9wZXJ0aWVzIHdpdGggYHNyY2AgcHJvcGVydGllc1xuICogQHJldHVybnMge29iamVjdH0gUmVmZXJlbmNlIHRvIGRlc3RcbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMsIHJlZGVmaW5lKSB7XG4gIGlmICghZGVzdCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IGRlc3QgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKCFzcmMpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzcmMgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKHJlZGVmaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBEZWZhdWx0IHRvIHRydWVcbiAgICByZWRlZmluZSA9IHRydWVcbiAgfVxuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNyYykuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoT3duUHJvcGVydHlOYW1lKG5hbWUpIHtcbiAgICBpZiAoIXJlZGVmaW5lICYmIGhhc093blByb3BlcnR5LmNhbGwoZGVzdCwgbmFtZSkpIHtcbiAgICAgIC8vIFNraXAgZGVzcmlwdG9yXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBDb3B5IGRlc2NyaXB0b3JcbiAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3JjLCBuYW1lKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBuYW1lLCBkZXNjcmlwdG9yKVxuICB9KVxuXG4gIHJldHVybiBkZXN0XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLT9cXGQ/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCIvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSB7XG4gICAgLy8gcmV0dXJuICcvLyc7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdCBmaXg6XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufTtcblxuZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuXG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuXG4vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gYmFzZW5hbWUocGF0aCk7XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLyohXG4gKiBQbGF0Zm9ybS5qcyA8aHR0cHM6Ly9tdGhzLmJlL3BsYXRmb3JtPlxuICogQ29weXJpZ2h0IDIwMTQtMjAxOCBCZW5qYW1pbiBUYW4gPGh0dHBzOi8vYm5qbW50NG4ubm93LnNoLz5cbiAqIENvcHlyaWdodCAyMDExLTIwMTMgSm9obi1EYXZpZCBEYWx0b24gPGh0dHA6Ly9hbGx5b3VjYW5sZWV0LmNvbS8+XG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbXRocy5iZS9taXQ+XG4gKi9cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBgT2JqZWN0YC4gKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWVcbiAgfTtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIHJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KSB8fCB0aGlzO1xuXG4gIC8qKiBCYWNrdXAgcG9zc2libGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIG9sZFJvb3QgPSByb290O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSBhbmQgdXNlIGl0IGFzIGByb290YC4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYXMgdGhlIG1heGltdW0gbGVuZ3RoIG9mIGFuIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgKiBTZWUgdGhlIFtFUzYgc3BlY10oaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4gIC8qKiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gZGV0ZWN0IE9wZXJhLiAqL1xuICB2YXIgcmVPcGVyYSA9IC9cXGJPcGVyYS87XG5cbiAgLyoqIFBvc3NpYmxlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciB0aGlzQmluZGluZyA9IHRoaXM7XG5cbiAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byBjaGVjayBmb3Igb3duIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LiAqL1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBpbnRlcm5hbCBgW1tDbGFzc11dYCBvZiB2YWx1ZXMuICovXG4gIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDYXBpdGFsaXplcyBhIHN0cmluZyB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpO1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG4gIH1cblxuICAvKipcbiAgICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIGNsZWFuIHVwIHRoZSBPUyBuYW1lLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3MgVGhlIE9TIG5hbWUgdG8gY2xlYW4gdXAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0dGVybl0gQSBgUmVnRXhwYCBwYXR0ZXJuIG1hdGNoaW5nIHRoZSBPUyBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXSBBIGxhYmVsIGZvciB0aGUgT1MuXG4gICAqL1xuICBmdW5jdGlvbiBjbGVhbnVwT1Mob3MsIHBhdHRlcm4sIGxhYmVsKSB7XG4gICAgLy8gUGxhdGZvcm0gdG9rZW5zIGFyZSBkZWZpbmVkIGF0OlxuICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNzUwMyhWUy44NSkuYXNweFxuICAgIC8vIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMDgxMTIyMDUzOTUwL2h0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNzUwMyhWUy44NSkuYXNweFxuICAgIHZhciBkYXRhID0ge1xuICAgICAgJzEwLjAnOiAnMTAnLFxuICAgICAgJzYuNCc6ICAnMTAgVGVjaG5pY2FsIFByZXZpZXcnLFxuICAgICAgJzYuMyc6ICAnOC4xJyxcbiAgICAgICc2LjInOiAgJzgnLFxuICAgICAgJzYuMSc6ICAnU2VydmVyIDIwMDggUjIgLyA3JyxcbiAgICAgICc2LjAnOiAgJ1NlcnZlciAyMDA4IC8gVmlzdGEnLFxuICAgICAgJzUuMic6ICAnU2VydmVyIDIwMDMgLyBYUCA2NC1iaXQnLFxuICAgICAgJzUuMSc6ICAnWFAnLFxuICAgICAgJzUuMDEnOiAnMjAwMCBTUDEnLFxuICAgICAgJzUuMCc6ICAnMjAwMCcsXG4gICAgICAnNC4wJzogICdOVCcsXG4gICAgICAnNC45MCc6ICdNRSdcbiAgICB9O1xuICAgIC8vIERldGVjdCBXaW5kb3dzIHZlcnNpb24gZnJvbSBwbGF0Zm9ybSB0b2tlbnMuXG4gICAgaWYgKHBhdHRlcm4gJiYgbGFiZWwgJiYgL15XaW4vaS50ZXN0KG9zKSAmJiAhL15XaW5kb3dzIFBob25lIC9pLnRlc3Qob3MpICYmXG4gICAgICAgIChkYXRhID0gZGF0YVsvW1xcZC5dKyQvLmV4ZWMob3MpXSkpIHtcbiAgICAgIG9zID0gJ1dpbmRvd3MgJyArIGRhdGE7XG4gICAgfVxuICAgIC8vIENvcnJlY3QgY2hhcmFjdGVyIGNhc2UgYW5kIGNsZWFudXAgc3RyaW5nLlxuICAgIG9zID0gU3RyaW5nKG9zKTtcblxuICAgIGlmIChwYXR0ZXJuICYmIGxhYmVsKSB7XG4gICAgICBvcyA9IG9zLnJlcGxhY2UoUmVnRXhwKHBhdHRlcm4sICdpJyksIGxhYmVsKTtcbiAgICB9XG5cbiAgICBvcyA9IGZvcm1hdChcbiAgICAgIG9zLnJlcGxhY2UoLyBjZSQvaSwgJyBDRScpXG4gICAgICAgIC5yZXBsYWNlKC9cXGJocHcvaSwgJ3dlYicpXG4gICAgICAgIC5yZXBsYWNlKC9cXGJNYWNpbnRvc2hcXGIvLCAnTWFjIE9TJylcbiAgICAgICAgLnJlcGxhY2UoL19Qb3dlclBDXFxiL2ksICcgT1MnKVxuICAgICAgICAucmVwbGFjZSgvXFxiKE9TIFgpIFteIFxcZF0rL2ksICckMScpXG4gICAgICAgIC5yZXBsYWNlKC9cXGJNYWMgKE9TIFgpXFxiLywgJyQxJylcbiAgICAgICAgLnJlcGxhY2UoL1xcLyhcXGQpLywgJyAkMScpXG4gICAgICAgIC5yZXBsYWNlKC9fL2csICcuJylcbiAgICAgICAgLnJlcGxhY2UoLyg/OiBCZVBDfFsgLl0qZmNbIFxcZC5dKykkL2ksICcnKVxuICAgICAgICAucmVwbGFjZSgvXFxieDg2XFwuNjRcXGIvZ2ksICd4ODZfNjQnKVxuICAgICAgICAucmVwbGFjZSgvXFxiKFdpbmRvd3MgUGhvbmUpIE9TXFxiLywgJyQxJylcbiAgICAgICAgLnJlcGxhY2UoL1xcYihDaHJvbWUgT1MgXFx3KykgW1xcZC5dK1xcYi8sICckMScpXG4gICAgICAgIC5zcGxpdCgnIG9uICcpWzBdXG4gICAgKTtcblxuICAgIHJldHVybiBvcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpdGVyYXRpb24gdXRpbGl0eSBmb3IgYXJyYXlzIGFuZCBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBlYWNoKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gb2JqZWN0ID8gb2JqZWN0Lmxlbmd0aCA6IDA7XG5cbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPiAtMSAmJiBsZW5ndGggPD0gbWF4U2FmZUludGVnZXIpIHtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtpbmRleF0sIGluZGV4LCBvYmplY3QpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JPd24ob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaW0gYW5kIGNvbmRpdGlvbmFsbHkgY2FwaXRhbGl6ZSBzdHJpbmcgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZm9ybWF0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGZvcm1hdChzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSB0cmltKHN0cmluZyk7XG4gICAgcmV0dXJuIC9eKD86d2ViT1N8aSg/Ok9TfFApKS8udGVzdChzdHJpbmcpXG4gICAgICA/IHN0cmluZ1xuICAgICAgOiBjYXBpdGFsaXplKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcywgZXhlY3V0aW5nIHRoZSBgY2FsbGJhY2tgIGZvciBlYWNoLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gZXhlY3V0ZWQgcGVyIG93biBwcm9wZXJ0eS5cbiAgICovXG4gIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGludGVybmFsIGBbW0NsYXNzXV1gIG9mIGEgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYFtbQ2xhc3NdXWAuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRDbGFzc09mKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICAgID8gY2FwaXRhbGl6ZSh2YWx1ZSlcbiAgICAgIDogdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhvc3Qgb2JqZWN0cyBjYW4gcmV0dXJuIHR5cGUgdmFsdWVzIHRoYXQgYXJlIGRpZmZlcmVudCBmcm9tIHRoZWlyIGFjdHVhbFxuICAgKiBkYXRhIHR5cGUuIFRoZSBvYmplY3RzIHdlIGFyZSBjb25jZXJuZWQgd2l0aCB1c3VhbGx5IHJldHVybiBub24tcHJpbWl0aXZlXG4gICAqIHR5cGVzIG9mIFwib2JqZWN0XCIsIFwiZnVuY3Rpb25cIiwgb3IgXCJ1bmtub3duXCIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvd25lciBvZiB0aGUgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgdmFsdWUgaXMgYSBub24tcHJpbWl0aXZlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc0hvc3RUeXBlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB2YXIgdHlwZSA9IG9iamVjdCAhPSBudWxsID8gdHlwZW9mIG9iamVjdFtwcm9wZXJ0eV0gOiAnbnVtYmVyJztcbiAgICByZXR1cm4gIS9eKD86Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZCkkLy50ZXN0KHR5cGUpICYmXG4gICAgICAodHlwZSA9PSAnb2JqZWN0JyA/ICEhb2JqZWN0W3Byb3BlcnR5XSA6IHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIGEgc3RyaW5nIGZvciB1c2UgaW4gYSBgUmVnRXhwYCBieSBtYWtpbmcgaHlwaGVucyBhbmQgc3BhY2VzIG9wdGlvbmFsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gcXVhbGlmeS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHF1YWxpZmllZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBxdWFsaWZ5KHN0cmluZykge1xuICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC8oWyAtXSkoPyEkKS9nLCAnJDE/Jyk7XG4gIH1cblxuICAvKipcbiAgICogQSBiYXJlLWJvbmVzIGBBcnJheSNyZWR1Y2VgIGxpa2UgdXRpbGl0eSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIGFjY3VtdWxhdGVkIHJlc3VsdC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlZHVjZShhcnJheSwgY2FsbGJhY2spIHtcbiAgICB2YXIgYWNjdW11bGF0b3IgPSBudWxsO1xuICAgIGVhY2goYXJyYXksIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBhcnJheSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBmcm9tIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbShzdHJpbmcpIHtcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvXiArfCArJC9nLCAnJyk7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwbGF0Zm9ybSBvYmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFt1YT1uYXZpZ2F0b3IudXNlckFnZW50XSBUaGUgdXNlciBhZ2VudCBzdHJpbmcgb3JcbiAgICogIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIHBsYXRmb3JtIG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlKHVhKSB7XG5cbiAgICAvKiogVGhlIGVudmlyb25tZW50IGNvbnRleHQgb2JqZWN0LiAqL1xuICAgIHZhciBjb250ZXh0ID0gcm9vdDtcblxuICAgIC8qKiBVc2VkIHRvIGZsYWcgd2hlbiBhIGN1c3RvbSBjb250ZXh0IGlzIHByb3ZpZGVkLiAqL1xuICAgIHZhciBpc0N1c3RvbUNvbnRleHQgPSB1YSAmJiB0eXBlb2YgdWEgPT0gJ29iamVjdCcgJiYgZ2V0Q2xhc3NPZih1YSkgIT0gJ1N0cmluZyc7XG5cbiAgICAvLyBKdWdnbGUgYXJndW1lbnRzLlxuICAgIGlmIChpc0N1c3RvbUNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQgPSB1YTtcbiAgICAgIHVhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKiogQnJvd3NlciBuYXZpZ2F0b3Igb2JqZWN0LiAqL1xuICAgIHZhciBuYXYgPSBjb250ZXh0Lm5hdmlnYXRvciB8fCB7fTtcblxuICAgIC8qKiBCcm93c2VyIHVzZXIgYWdlbnQgc3RyaW5nLiAqL1xuICAgIHZhciB1c2VyQWdlbnQgPSBuYXYudXNlckFnZW50IHx8ICcnO1xuXG4gICAgdWEgfHwgKHVhID0gdXNlckFnZW50KTtcblxuICAgIC8qKiBVc2VkIHRvIGZsYWcgd2hlbiBgdGhpc0JpbmRpbmdgIGlzIHRoZSBbTW9kdWxlU2NvcGVdLiAqL1xuICAgIHZhciBpc01vZHVsZVNjb3BlID0gaXNDdXN0b21Db250ZXh0IHx8IHRoaXNCaW5kaW5nID09IG9sZFJvb3Q7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYnJvd3NlciBpcyBsaWtlIENocm9tZS4gKi9cbiAgICB2YXIgbGlrZUNocm9tZSA9IGlzQ3VzdG9tQ29udGV4dFxuICAgICAgPyAhIW5hdi5saWtlQ2hyb21lXG4gICAgICA6IC9cXGJDaHJvbWVcXGIvLnRlc3QodWEpICYmICEvaW50ZXJuYWx8XFxuL2kudGVzdCh0b1N0cmluZy50b1N0cmluZygpKTtcblxuICAgIC8qKiBJbnRlcm5hbCBgW1tDbGFzc11dYCB2YWx1ZSBzaG9ydGN1dHMuICovXG4gICAgdmFyIG9iamVjdENsYXNzID0gJ09iamVjdCcsXG4gICAgICAgIGFpclJ1bnRpbWVDbGFzcyA9IGlzQ3VzdG9tQ29udGV4dCA/IG9iamVjdENsYXNzIDogJ1NjcmlwdEJyaWRnaW5nUHJveHlPYmplY3QnLFxuICAgICAgICBlbnZpcm9DbGFzcyA9IGlzQ3VzdG9tQ29udGV4dCA/IG9iamVjdENsYXNzIDogJ0Vudmlyb25tZW50JyxcbiAgICAgICAgamF2YUNsYXNzID0gKGlzQ3VzdG9tQ29udGV4dCAmJiBjb250ZXh0LmphdmEpID8gJ0phdmFQYWNrYWdlJyA6IGdldENsYXNzT2YoY29udGV4dC5qYXZhKSxcbiAgICAgICAgcGhhbnRvbUNsYXNzID0gaXNDdXN0b21Db250ZXh0ID8gb2JqZWN0Q2xhc3MgOiAnUnVudGltZU9iamVjdCc7XG5cbiAgICAvKiogRGV0ZWN0IEphdmEgZW52aXJvbm1lbnRzLiAqL1xuICAgIHZhciBqYXZhID0gL1xcYkphdmEvLnRlc3QoamF2YUNsYXNzKSAmJiBjb250ZXh0LmphdmE7XG5cbiAgICAvKiogRGV0ZWN0IFJoaW5vLiAqL1xuICAgIHZhciByaGlubyA9IGphdmEgJiYgZ2V0Q2xhc3NPZihjb250ZXh0LmVudmlyb25tZW50KSA9PSBlbnZpcm9DbGFzcztcblxuICAgIC8qKiBBIGNoYXJhY3RlciB0byByZXByZXNlbnQgYWxwaGEuICovXG4gICAgdmFyIGFscGhhID0gamF2YSA/ICdhJyA6ICdcXHUwM2IxJztcblxuICAgIC8qKiBBIGNoYXJhY3RlciB0byByZXByZXNlbnQgYmV0YS4gKi9cbiAgICB2YXIgYmV0YSA9IGphdmEgPyAnYicgOiAnXFx1MDNiMic7XG5cbiAgICAvKiogQnJvd3NlciBkb2N1bWVudCBvYmplY3QuICovXG4gICAgdmFyIGRvYyA9IGNvbnRleHQuZG9jdW1lbnQgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgT3BlcmEgYnJvd3NlciAoUHJlc3RvLWJhc2VkKS5cbiAgICAgKiBodHRwOi8vd3d3Lmhvd3RvY3JlYXRlLmNvLnVrL29wZXJhU3R1ZmYvb3BlcmFPYmplY3QuaHRtbFxuICAgICAqIGh0dHA6Ly9kZXYub3BlcmEuY29tL2FydGljbGVzL3ZpZXcvb3BlcmEtbWluaS13ZWItY29udGVudC1hdXRob3JpbmctZ3VpZGVsaW5lcy8jb3BlcmFtaW5pXG4gICAgICovXG4gICAgdmFyIG9wZXJhID0gY29udGV4dC5vcGVyYW1pbmkgfHwgY29udGV4dC5vcGVyYTtcblxuICAgIC8qKiBPcGVyYSBgW1tDbGFzc11dYC4gKi9cbiAgICB2YXIgb3BlcmFDbGFzcyA9IHJlT3BlcmEudGVzdChvcGVyYUNsYXNzID0gKGlzQ3VzdG9tQ29udGV4dCAmJiBvcGVyYSkgPyBvcGVyYVsnW1tDbGFzc11dJ10gOiBnZXRDbGFzc09mKG9wZXJhKSlcbiAgICAgID8gb3BlcmFDbGFzc1xuICAgICAgOiAob3BlcmEgPSBudWxsKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgdXNlZCBvdmVyIHRoZSBzY3JpcHQncyBsaWZldGltZS4gKi9cbiAgICB2YXIgZGF0YTtcblxuICAgIC8qKiBUaGUgQ1BVIGFyY2hpdGVjdHVyZS4gKi9cbiAgICB2YXIgYXJjaCA9IHVhO1xuXG4gICAgLyoqIFBsYXRmb3JtIGRlc2NyaXB0aW9uIGFycmF5LiAqL1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IFtdO1xuXG4gICAgLyoqIFBsYXRmb3JtIGFscGhhL2JldGEgaW5kaWNhdG9yLiAqL1xuICAgIHZhciBwcmVyZWxlYXNlID0gbnVsbDtcblxuICAgIC8qKiBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCBlbnZpcm9ubWVudCBmZWF0dXJlcyBzaG91bGQgYmUgdXNlZCB0byByZXNvbHZlIHRoZSBwbGF0Zm9ybS4gKi9cbiAgICB2YXIgdXNlRmVhdHVyZXMgPSB1YSA9PSB1c2VyQWdlbnQ7XG5cbiAgICAvKiogVGhlIGJyb3dzZXIvZW52aXJvbm1lbnQgdmVyc2lvbi4gKi9cbiAgICB2YXIgdmVyc2lvbiA9IHVzZUZlYXR1cmVzICYmIG9wZXJhICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09ICdmdW5jdGlvbicgJiYgb3BlcmEudmVyc2lvbigpO1xuXG4gICAgLyoqIEEgZmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgT1MgZW5kcyB3aXRoIFwiLyBWZXJzaW9uXCIgKi9cbiAgICB2YXIgaXNTcGVjaWFsQ2FzZWRPUztcblxuICAgIC8qIERldGVjdGFibGUgbGF5b3V0IGVuZ2luZXMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXG4gICAgdmFyIGxheW91dCA9IGdldExheW91dChbXG4gICAgICB7ICdsYWJlbCc6ICdFZGdlSFRNTCcsICdwYXR0ZXJuJzogJ0VkZ2UnIH0sXG4gICAgICAnVHJpZGVudCcsXG4gICAgICB7ICdsYWJlbCc6ICdXZWJLaXQnLCAncGF0dGVybic6ICdBcHBsZVdlYktpdCcgfSxcbiAgICAgICdpQ2FiJyxcbiAgICAgICdQcmVzdG8nLFxuICAgICAgJ05ldEZyb250JyxcbiAgICAgICdUYXNtYW4nLFxuICAgICAgJ0tIVE1MJyxcbiAgICAgICdHZWNrbydcbiAgICBdKTtcblxuICAgIC8qIERldGVjdGFibGUgYnJvd3NlciBuYW1lcyAob3JkZXIgaXMgaW1wb3J0YW50KS4gKi9cbiAgICB2YXIgbmFtZSA9IGdldE5hbWUoW1xuICAgICAgJ0Fkb2JlIEFJUicsXG4gICAgICAnQXJvcmEnLFxuICAgICAgJ0F2YW50IEJyb3dzZXInLFxuICAgICAgJ0JyZWFjaCcsXG4gICAgICAnQ2FtaW5vJyxcbiAgICAgICdFbGVjdHJvbicsXG4gICAgICAnRXBpcGhhbnknLFxuICAgICAgJ0Zlbm5lYycsXG4gICAgICAnRmxvY2snLFxuICAgICAgJ0dhbGVvbicsXG4gICAgICAnR3JlZW5Ccm93c2VyJyxcbiAgICAgICdpQ2FiJyxcbiAgICAgICdJY2V3ZWFzZWwnLFxuICAgICAgJ0stTWVsZW9uJyxcbiAgICAgICdLb25xdWVyb3InLFxuICAgICAgJ0x1bmFzY2FwZScsXG4gICAgICAnTWF4dGhvbicsXG4gICAgICB7ICdsYWJlbCc6ICdNaWNyb3NvZnQgRWRnZScsICdwYXR0ZXJuJzogJ0VkZ2UnIH0sXG4gICAgICAnTWlkb3JpJyxcbiAgICAgICdOb29rIEJyb3dzZXInLFxuICAgICAgJ1BhbGVNb29uJyxcbiAgICAgICdQaGFudG9tSlMnLFxuICAgICAgJ1JhdmVuJyxcbiAgICAgICdSZWtvbnEnLFxuICAgICAgJ1JvY2tNZWx0JyxcbiAgICAgIHsgJ2xhYmVsJzogJ1NhbXN1bmcgSW50ZXJuZXQnLCAncGF0dGVybic6ICdTYW1zdW5nQnJvd3NlcicgfSxcbiAgICAgICdTZWFNb25rZXknLFxuICAgICAgeyAnbGFiZWwnOiAnU2lsaycsICdwYXR0ZXJuJzogJyg/OkNsb3VkOXxTaWxrLUFjY2VsZXJhdGVkKScgfSxcbiAgICAgICdTbGVpcG5pcicsXG4gICAgICAnU2xpbUJyb3dzZXInLFxuICAgICAgeyAnbGFiZWwnOiAnU1JXYXJlIElyb24nLCAncGF0dGVybic6ICdJcm9uJyB9LFxuICAgICAgJ1N1bnJpc2UnLFxuICAgICAgJ1N3aWZ0Zm94JyxcbiAgICAgICdXYXRlcmZveCcsXG4gICAgICAnV2ViUG9zaXRpdmUnLFxuICAgICAgJ09wZXJhIE1pbmknLFxuICAgICAgeyAnbGFiZWwnOiAnT3BlcmEgTWluaScsICdwYXR0ZXJuJzogJ09QaU9TJyB9LFxuICAgICAgJ09wZXJhJyxcbiAgICAgIHsgJ2xhYmVsJzogJ09wZXJhJywgJ3BhdHRlcm4nOiAnT1BSJyB9LFxuICAgICAgJ0Nocm9tZScsXG4gICAgICB7ICdsYWJlbCc6ICdDaHJvbWUgTW9iaWxlJywgJ3BhdHRlcm4nOiAnKD86Q3JpT1N8Q3JNbyknIH0sXG4gICAgICB7ICdsYWJlbCc6ICdGaXJlZm94JywgJ3BhdHRlcm4nOiAnKD86RmlyZWZveHxNaW5lZmllbGQpJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnRmlyZWZveCBmb3IgaU9TJywgJ3BhdHRlcm4nOiAnRnhpT1MnIH0sXG4gICAgICB7ICdsYWJlbCc6ICdJRScsICdwYXR0ZXJuJzogJ0lFTW9iaWxlJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnSUUnLCAncGF0dGVybic6ICdNU0lFJyB9LFxuICAgICAgJ1NhZmFyaSdcbiAgICBdKTtcblxuICAgIC8qIERldGVjdGFibGUgcHJvZHVjdHMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXG4gICAgdmFyIHByb2R1Y3QgPSBnZXRQcm9kdWN0KFtcbiAgICAgIHsgJ2xhYmVsJzogJ0JsYWNrQmVycnknLCAncGF0dGVybic6ICdCQjEwJyB9LFxuICAgICAgJ0JsYWNrQmVycnknLFxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFMnLCAncGF0dGVybic6ICdHVC1JOTAwMCcgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTMicsICdwYXR0ZXJuJzogJ0dULUk5MTAwJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFMzJywgJ3BhdHRlcm4nOiAnR1QtSTkzMDAnIH0sXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzQnLCAncGF0dGVybic6ICdHVC1JOTUwMCcgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTNScsICdwYXR0ZXJuJzogJ1NNLUc5MDAnIH0sXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzYnLCAncGF0dGVybic6ICdTTS1HOTIwJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFM2IEVkZ2UnLCAncGF0dGVybic6ICdTTS1HOTI1JyB9LFxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFM3JywgJ3BhdHRlcm4nOiAnU00tRzkzMCcgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTNyBFZGdlJywgJ3BhdHRlcm4nOiAnU00tRzkzNScgfSxcbiAgICAgICdHb29nbGUgVFYnLFxuICAgICAgJ0x1bWlhJyxcbiAgICAgICdpUGFkJyxcbiAgICAgICdpUG9kJyxcbiAgICAgICdpUGhvbmUnLFxuICAgICAgJ0tpbmRsZScsXG4gICAgICB7ICdsYWJlbCc6ICdLaW5kbGUgRmlyZScsICdwYXR0ZXJuJzogJyg/OkNsb3VkOXxTaWxrLUFjY2VsZXJhdGVkKScgfSxcbiAgICAgICdOZXh1cycsXG4gICAgICAnTm9vaycsXG4gICAgICAnUGxheUJvb2snLFxuICAgICAgJ1BsYXlTdGF0aW9uIFZpdGEnLFxuICAgICAgJ1BsYXlTdGF0aW9uJyxcbiAgICAgICdUb3VjaFBhZCcsXG4gICAgICAnVHJhbnNmb3JtZXInLFxuICAgICAgeyAnbGFiZWwnOiAnV2lpIFUnLCAncGF0dGVybic6ICdXaWlVJyB9LFxuICAgICAgJ1dpaScsXG4gICAgICAnWGJveCBPbmUnLFxuICAgICAgeyAnbGFiZWwnOiAnWGJveCAzNjAnLCAncGF0dGVybic6ICdYYm94JyB9LFxuICAgICAgJ1hvb20nXG4gICAgXSk7XG5cbiAgICAvKiBEZXRlY3RhYmxlIG1hbnVmYWN0dXJlcnMuICovXG4gICAgdmFyIG1hbnVmYWN0dXJlciA9IGdldE1hbnVmYWN0dXJlcih7XG4gICAgICAnQXBwbGUnOiB7ICdpUGFkJzogMSwgJ2lQaG9uZSc6IDEsICdpUG9kJzogMSB9LFxuICAgICAgJ0FyY2hvcyc6IHt9LFxuICAgICAgJ0FtYXpvbic6IHsgJ0tpbmRsZSc6IDEsICdLaW5kbGUgRmlyZSc6IDEgfSxcbiAgICAgICdBc3VzJzogeyAnVHJhbnNmb3JtZXInOiAxIH0sXG4gICAgICAnQmFybmVzICYgTm9ibGUnOiB7ICdOb29rJzogMSB9LFxuICAgICAgJ0JsYWNrQmVycnknOiB7ICdQbGF5Qm9vayc6IDEgfSxcbiAgICAgICdHb29nbGUnOiB7ICdHb29nbGUgVFYnOiAxLCAnTmV4dXMnOiAxIH0sXG4gICAgICAnSFAnOiB7ICdUb3VjaFBhZCc6IDEgfSxcbiAgICAgICdIVEMnOiB7fSxcbiAgICAgICdMRyc6IHt9LFxuICAgICAgJ01pY3Jvc29mdCc6IHsgJ1hib3gnOiAxLCAnWGJveCBPbmUnOiAxIH0sXG4gICAgICAnTW90b3JvbGEnOiB7ICdYb29tJzogMSB9LFxuICAgICAgJ05pbnRlbmRvJzogeyAnV2lpIFUnOiAxLCAgJ1dpaSc6IDEgfSxcbiAgICAgICdOb2tpYSc6IHsgJ0x1bWlhJzogMSB9LFxuICAgICAgJ1NhbXN1bmcnOiB7ICdHYWxheHkgUyc6IDEsICdHYWxheHkgUzInOiAxLCAnR2FsYXh5IFMzJzogMSwgJ0dhbGF4eSBTNCc6IDEgfSxcbiAgICAgICdTb255JzogeyAnUGxheVN0YXRpb24nOiAxLCAnUGxheVN0YXRpb24gVml0YSc6IDEgfVxuICAgIH0pO1xuXG4gICAgLyogRGV0ZWN0YWJsZSBvcGVyYXRpbmcgc3lzdGVtcyAob3JkZXIgaXMgaW1wb3J0YW50KS4gKi9cbiAgICB2YXIgb3MgPSBnZXRPUyhbXG4gICAgICAnV2luZG93cyBQaG9uZScsXG4gICAgICAnQW5kcm9pZCcsXG4gICAgICAnQ2VudE9TJyxcbiAgICAgIHsgJ2xhYmVsJzogJ0Nocm9tZSBPUycsICdwYXR0ZXJuJzogJ0NyT1MnIH0sXG4gICAgICAnRGViaWFuJyxcbiAgICAgICdGZWRvcmEnLFxuICAgICAgJ0ZyZWVCU0QnLFxuICAgICAgJ0dlbnRvbycsXG4gICAgICAnSGFpa3UnLFxuICAgICAgJ0t1YnVudHUnLFxuICAgICAgJ0xpbnV4IE1pbnQnLFxuICAgICAgJ09wZW5CU0QnLFxuICAgICAgJ1JlZCBIYXQnLFxuICAgICAgJ1N1U0UnLFxuICAgICAgJ1VidW50dScsXG4gICAgICAnWHVidW50dScsXG4gICAgICAnQ3lnd2luJyxcbiAgICAgICdTeW1iaWFuIE9TJyxcbiAgICAgICdocHdPUycsXG4gICAgICAnd2ViT1MgJyxcbiAgICAgICd3ZWJPUycsXG4gICAgICAnVGFibGV0IE9TJyxcbiAgICAgICdUaXplbicsXG4gICAgICAnTGludXgnLFxuICAgICAgJ01hYyBPUyBYJyxcbiAgICAgICdNYWNpbnRvc2gnLFxuICAgICAgJ01hYycsXG4gICAgICAnV2luZG93cyA5ODsnLFxuICAgICAgJ1dpbmRvd3MgJ1xuICAgIF0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogUGlja3MgdGhlIGxheW91dCBlbmdpbmUgZnJvbSBhbiBhcnJheSBvZiBndWVzc2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBndWVzc2VzIEFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgbGF5b3V0IGVuZ2luZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRMYXlvdXQoZ3Vlc3Nlcykge1xuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgUmVnRXhwKCdcXFxcYicgKyAoXG4gICAgICAgICAgZ3Vlc3MucGF0dGVybiB8fCBxdWFsaWZ5KGd1ZXNzKVxuICAgICAgICApICsgJ1xcXFxiJywgJ2knKS5leGVjKHVhKSAmJiAoZ3Vlc3MubGFiZWwgfHwgZ3Vlc3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlja3MgdGhlIG1hbnVmYWN0dXJlciBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gb2JqZWN0IG9mIGd1ZXNzZXMuXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgbWFudWZhY3R1cmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hbnVmYWN0dXJlcihndWVzc2VzKSB7XG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgICAvLyBMb29rdXAgdGhlIG1hbnVmYWN0dXJlciBieSBwcm9kdWN0IG9yIHNjYW4gdGhlIFVBIGZvciB0aGUgbWFudWZhY3R1cmVyLlxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IChcbiAgICAgICAgICB2YWx1ZVtwcm9kdWN0XSB8fFxuICAgICAgICAgIHZhbHVlWy9eW2Etel0rKD86ICtbYS16XStcXGIpKi9pLmV4ZWMocHJvZHVjdCldIHx8XG4gICAgICAgICAgUmVnRXhwKCdcXFxcYicgKyBxdWFsaWZ5KGtleSkgKyAnKD86XFxcXGJ8XFxcXHcqXFxcXGQpJywgJ2knKS5leGVjKHVhKVxuICAgICAgICApICYmIGtleTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpY2tzIHRoZSBicm93c2VyIG5hbWUgZnJvbSBhbiBhcnJheSBvZiBndWVzc2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBndWVzc2VzIEFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgYnJvd3NlciBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hbWUoZ3Vlc3Nlcykge1xuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgUmVnRXhwKCdcXFxcYicgKyAoXG4gICAgICAgICAgZ3Vlc3MucGF0dGVybiB8fCBxdWFsaWZ5KGd1ZXNzKVxuICAgICAgICApICsgJ1xcXFxiJywgJ2knKS5leGVjKHVhKSAmJiAoZ3Vlc3MubGFiZWwgfHwgZ3Vlc3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlja3MgdGhlIE9TIG5hbWUgZnJvbSBhbiBhcnJheSBvZiBndWVzc2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBndWVzc2VzIEFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgT1MgbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRPUyhndWVzc2VzKSB7XG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgZ3Vlc3MpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBndWVzcy5wYXR0ZXJuIHx8IHF1YWxpZnkoZ3Vlc3MpO1xuICAgICAgICBpZiAoIXJlc3VsdCAmJiAocmVzdWx0ID1cbiAgICAgICAgICAgICAgUmVnRXhwKCdcXFxcYicgKyBwYXR0ZXJuICsgJyg/Oi9bXFxcXGQuXSt8WyBcXFxcdy5dKiknLCAnaScpLmV4ZWModWEpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2xlYW51cE9TKHJlc3VsdCwgcGF0dGVybiwgZ3Vlc3MubGFiZWwgfHwgZ3Vlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQaWNrcyB0aGUgcHJvZHVjdCBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIHByb2R1Y3QgbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQcm9kdWN0KGd1ZXNzZXMpIHtcbiAgICAgIHJldHVybiByZWR1Y2UoZ3Vlc3NlcywgZnVuY3Rpb24ocmVzdWx0LCBndWVzcykge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcyk7XG4gICAgICAgIGlmICghcmVzdWx0ICYmIChyZXN1bHQgPVxuICAgICAgICAgICAgICBSZWdFeHAoJ1xcXFxiJyArIHBhdHRlcm4gKyAnICpcXFxcZCtbLlxcXFx3X10qJywgJ2knKS5leGVjKHVhKSB8fFxuICAgICAgICAgICAgICBSZWdFeHAoJ1xcXFxiJyArIHBhdHRlcm4gKyAnICpcXFxcdystW1xcXFx3XSonLCAnaScpLmV4ZWModWEpIHx8XG4gICAgICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcGF0dGVybiArICcoPzo7ICooPzpbYS16XStbXy1dKT9bYS16XStcXFxcZCt8W14gKCk7LV0qKScsICdpJykuZXhlYyh1YSlcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAvLyBTcGxpdCBieSBmb3J3YXJkIHNsYXNoIGFuZCBhcHBlbmQgcHJvZHVjdCB2ZXJzaW9uIGlmIG5lZWRlZC5cbiAgICAgICAgICBpZiAoKHJlc3VsdCA9IFN0cmluZygoZ3Vlc3MubGFiZWwgJiYgIVJlZ0V4cChwYXR0ZXJuLCAnaScpLnRlc3QoZ3Vlc3MubGFiZWwpKSA/IGd1ZXNzLmxhYmVsIDogcmVzdWx0KS5zcGxpdCgnLycpKVsxXSAmJiAhL1tcXGQuXSsvLnRlc3QocmVzdWx0WzBdKSkge1xuICAgICAgICAgICAgcmVzdWx0WzBdICs9ICcgJyArIHJlc3VsdFsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29ycmVjdCBjaGFyYWN0ZXIgY2FzZSBhbmQgY2xlYW51cCBzdHJpbmcuXG4gICAgICAgICAgZ3Vlc3MgPSBndWVzcy5sYWJlbCB8fCBndWVzcztcbiAgICAgICAgICByZXN1bHQgPSBmb3JtYXQocmVzdWx0WzBdXG4gICAgICAgICAgICAucmVwbGFjZShSZWdFeHAocGF0dGVybiwgJ2knKSwgZ3Vlc3MpXG4gICAgICAgICAgICAucmVwbGFjZShSZWdFeHAoJzsgKig/OicgKyBndWVzcyArICdbXy1dKT8nLCAnaScpLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZShSZWdFeHAoJygnICsgZ3Vlc3MgKyAnKVstXy5dPyhcXFxcdyknLCAnaScpLCAnJDEgJDInKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSB2ZXJzaW9uIHVzaW5nIGFuIGFycmF5IG9mIFVBIHBhdHRlcm5zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXR0ZXJucyBBbiBhcnJheSBvZiBVQSBwYXR0ZXJucy5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxzdHJpbmd9IFRoZSBkZXRlY3RlZCB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZlcnNpb24ocGF0dGVybnMpIHtcbiAgICAgIHJldHVybiByZWR1Y2UocGF0dGVybnMsIGZ1bmN0aW9uKHJlc3VsdCwgcGF0dGVybikge1xuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IChSZWdFeHAocGF0dGVybiArXG4gICAgICAgICAgJyg/Oi1bXFxcXGQuXSsvfCg/OiBmb3IgW1xcXFx3LV0rKT9bIC8tXSkoW1xcXFxkLl0rW14gKCk7L18tXSopJywgJ2knKS5leGVjKHVhKSB8fCAwKVsxXSB8fCBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgcGxhdGZvcm0uZGVzY3JpcHRpb25gIHdoZW4gdGhlIHBsYXRmb3JtIG9iamVjdCBpcyBjb2VyY2VkIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQG5hbWUgdG9TdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIGBwbGF0Zm9ybS5kZXNjcmlwdGlvbmAgaWYgYXZhaWxhYmxlLCBlbHNlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1N0cmluZ1BsYXRmb3JtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRpb24gfHwgJyc7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQ29udmVydCBsYXlvdXQgdG8gYW4gYXJyYXkgc28gd2UgY2FuIGFkZCBleHRyYSBkZXRhaWxzLlxuICAgIGxheW91dCAmJiAobGF5b3V0ID0gW2xheW91dF0pO1xuXG4gICAgLy8gRGV0ZWN0IHByb2R1Y3QgbmFtZXMgdGhhdCBjb250YWluIHRoZWlyIG1hbnVmYWN0dXJlcidzIG5hbWUuXG4gICAgaWYgKG1hbnVmYWN0dXJlciAmJiAhcHJvZHVjdCkge1xuICAgICAgcHJvZHVjdCA9IGdldFByb2R1Y3QoW21hbnVmYWN0dXJlcl0pO1xuICAgIH1cbiAgICAvLyBDbGVhbiB1cCBHb29nbGUgVFYuXG4gICAgaWYgKChkYXRhID0gL1xcYkdvb2dsZSBUVlxcYi8uZXhlYyhwcm9kdWN0KSkpIHtcbiAgICAgIHByb2R1Y3QgPSBkYXRhWzBdO1xuICAgIH1cbiAgICAvLyBEZXRlY3Qgc2ltdWxhdG9ycy5cbiAgICBpZiAoL1xcYlNpbXVsYXRvclxcYi9pLnRlc3QodWEpKSB7XG4gICAgICBwcm9kdWN0ID0gKHByb2R1Y3QgPyBwcm9kdWN0ICsgJyAnIDogJycpICsgJ1NpbXVsYXRvcic7XG4gICAgfVxuICAgIC8vIERldGVjdCBPcGVyYSBNaW5pIDgrIHJ1bm5pbmcgaW4gVHVyYm8vVW5jb21wcmVzc2VkIG1vZGUgb24gaU9TLlxuICAgIGlmIChuYW1lID09ICdPcGVyYSBNaW5pJyAmJiAvXFxiT1BpT1NcXGIvLnRlc3QodWEpKSB7XG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKCdydW5uaW5nIGluIFR1cmJvL1VuY29tcHJlc3NlZCBtb2RlJyk7XG4gICAgfVxuICAgIC8vIERldGVjdCBJRSBNb2JpbGUgMTEuXG4gICAgaWYgKG5hbWUgPT0gJ0lFJyAmJiAvXFxibGlrZSBpUGhvbmUgT1NcXGIvLnRlc3QodWEpKSB7XG4gICAgICBkYXRhID0gcGFyc2UodWEucmVwbGFjZSgvbGlrZSBpUGhvbmUgT1MvLCAnJykpO1xuICAgICAgbWFudWZhY3R1cmVyID0gZGF0YS5tYW51ZmFjdHVyZXI7XG4gICAgICBwcm9kdWN0ID0gZGF0YS5wcm9kdWN0O1xuICAgIH1cbiAgICAvLyBEZXRlY3QgaU9TLlxuICAgIGVsc2UgaWYgKC9eaVAvLnRlc3QocHJvZHVjdCkpIHtcbiAgICAgIG5hbWUgfHwgKG5hbWUgPSAnU2FmYXJpJyk7XG4gICAgICBvcyA9ICdpT1MnICsgKChkYXRhID0gLyBPUyAoW1xcZF9dKykvaS5leGVjKHVhKSlcbiAgICAgICAgPyAnICcgKyBkYXRhWzFdLnJlcGxhY2UoL18vZywgJy4nKVxuICAgICAgICA6ICcnKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IEt1YnVudHUuXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnS29ucXVlcm9yJyAmJiAhL2J1bnR1L2kudGVzdChvcykpIHtcbiAgICAgIG9zID0gJ0t1YnVudHUnO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgQW5kcm9pZCBicm93c2Vycy5cbiAgICBlbHNlIGlmICgobWFudWZhY3R1cmVyICYmIG1hbnVmYWN0dXJlciAhPSAnR29vZ2xlJyAmJlxuICAgICAgICAoKC9DaHJvbWUvLnRlc3QobmFtZSkgJiYgIS9cXGJNb2JpbGUgU2FmYXJpXFxiL2kudGVzdCh1YSkpIHx8IC9cXGJWaXRhXFxiLy50ZXN0KHByb2R1Y3QpKSkgfHxcbiAgICAgICAgKC9cXGJBbmRyb2lkXFxiLy50ZXN0KG9zKSAmJiAvXkNocm9tZS8udGVzdChuYW1lKSAmJiAvXFxiVmVyc2lvblxcLy9pLnRlc3QodWEpKSkge1xuICAgICAgbmFtZSA9ICdBbmRyb2lkIEJyb3dzZXInO1xuICAgICAgb3MgPSAvXFxiQW5kcm9pZFxcYi8udGVzdChvcykgPyBvcyA6ICdBbmRyb2lkJztcbiAgICB9XG4gICAgLy8gRGV0ZWN0IFNpbGsgZGVza3RvcC9hY2NlbGVyYXRlZCBtb2Rlcy5cbiAgICBlbHNlIGlmIChuYW1lID09ICdTaWxrJykge1xuICAgICAgaWYgKCEvXFxiTW9iaS9pLnRlc3QodWEpKSB7XG4gICAgICAgIG9zID0gJ0FuZHJvaWQnO1xuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdkZXNrdG9wIG1vZGUnKTtcbiAgICAgIH1cbiAgICAgIGlmICgvQWNjZWxlcmF0ZWQgKj0gKnRydWUvaS50ZXN0KHVhKSkge1xuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdhY2NlbGVyYXRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRlY3QgUGFsZU1vb24gaWRlbnRpZnlpbmcgYXMgRmlyZWZveC5cbiAgICBlbHNlIGlmIChuYW1lID09ICdQYWxlTW9vbicgJiYgKGRhdGEgPSAvXFxiRmlyZWZveFxcLyhbXFxkLl0rKVxcYi8uZXhlYyh1YSkpKSB7XG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKCdpZGVudGlmeWluZyBhcyBGaXJlZm94ICcgKyBkYXRhWzFdKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IEZpcmVmb3ggT1MgYW5kIHByb2R1Y3RzIHJ1bm5pbmcgRmlyZWZveC5cbiAgICBlbHNlIGlmIChuYW1lID09ICdGaXJlZm94JyAmJiAoZGF0YSA9IC9cXGIoTW9iaWxlfFRhYmxldHxUVilcXGIvaS5leGVjKHVhKSkpIHtcbiAgICAgIG9zIHx8IChvcyA9ICdGaXJlZm94IE9TJyk7XG4gICAgICBwcm9kdWN0IHx8IChwcm9kdWN0ID0gZGF0YVsxXSk7XG4gICAgfVxuICAgIC8vIERldGVjdCBmYWxzZSBwb3NpdGl2ZXMgZm9yIEZpcmVmb3gvU2FmYXJpLlxuICAgIGVsc2UgaWYgKCFuYW1lIHx8IChkYXRhID0gIS9cXGJNaW5lZmllbGRcXGIvaS50ZXN0KHVhKSAmJiAvXFxiKD86RmlyZWZveHxTYWZhcmkpXFxiLy5leGVjKG5hbWUpKSkge1xuICAgICAgLy8gRXNjYXBlIHRoZSBgL2AgZm9yIEZpcmVmb3ggMS5cbiAgICAgIGlmIChuYW1lICYmICFwcm9kdWN0ICYmIC9bXFwvLF18XlteKF0rP1xcKS8udGVzdCh1YS5zbGljZSh1YS5pbmRleE9mKGRhdGEgKyAnLycpICsgOCkpKSB7XG4gICAgICAgIC8vIENsZWFyIG5hbWUgb2YgZmFsc2UgcG9zaXRpdmVzLlxuICAgICAgICBuYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFJlYXNzaWduIGEgZ2VuZXJpYyBuYW1lLlxuICAgICAgaWYgKChkYXRhID0gcHJvZHVjdCB8fCBtYW51ZmFjdHVyZXIgfHwgb3MpICYmXG4gICAgICAgICAgKHByb2R1Y3QgfHwgbWFudWZhY3R1cmVyIHx8IC9cXGIoPzpBbmRyb2lkfFN5bWJpYW4gT1N8VGFibGV0IE9TfHdlYk9TKVxcYi8udGVzdChvcykpKSB7XG4gICAgICAgIG5hbWUgPSAvW2Etel0rKD86IEhhdCk/L2kuZXhlYygvXFxiQW5kcm9pZFxcYi8udGVzdChvcykgPyBvcyA6IGRhdGEpICsgJyBCcm93c2VyJztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIENocm9tZSB2ZXJzaW9uIHRvIGRlc2NyaXB0aW9uIGZvciBFbGVjdHJvbi5cbiAgICBlbHNlIGlmIChuYW1lID09ICdFbGVjdHJvbicgJiYgKGRhdGEgPSAoL1xcYkNocm9tZVxcLyhbXFxkLl0rKVxcYi8uZXhlYyh1YSkgfHwgMClbMV0pKSB7XG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKCdDaHJvbWl1bSAnICsgZGF0YSk7XG4gICAgfVxuICAgIC8vIERldGVjdCBub24tT3BlcmEgKFByZXN0by1iYXNlZCkgdmVyc2lvbnMgKG9yZGVyIGlzIGltcG9ydGFudCkuXG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICB2ZXJzaW9uID0gZ2V0VmVyc2lvbihbXG4gICAgICAgICcoPzpDbG91ZDl8Q3JpT1N8Q3JNb3xFZGdlfEZ4aU9TfElFTW9iaWxlfElyb258T3BlcmEgP01pbml8T1BpT1N8T1BSfFJhdmVufFNhbXN1bmdCcm93c2VyfFNpbGsoPyEvW1xcXFxkLl0rJCkpJyxcbiAgICAgICAgJ1ZlcnNpb24nLFxuICAgICAgICBxdWFsaWZ5KG5hbWUpLFxuICAgICAgICAnKD86RmlyZWZveHxNaW5lZmllbGR8TmV0RnJvbnQpJ1xuICAgICAgXSk7XG4gICAgfVxuICAgIC8vIERldGVjdCBzdHViYm9ybiBsYXlvdXQgZW5naW5lcy5cbiAgICBpZiAoKGRhdGEgPVxuICAgICAgICAgIGxheW91dCA9PSAnaUNhYicgJiYgcGFyc2VGbG9hdCh2ZXJzaW9uKSA+IDMgJiYgJ1dlYktpdCcgfHxcbiAgICAgICAgICAvXFxiT3BlcmFcXGIvLnRlc3QobmFtZSkgJiYgKC9cXGJPUFJcXGIvLnRlc3QodWEpID8gJ0JsaW5rJyA6ICdQcmVzdG8nKSB8fFxuICAgICAgICAgIC9cXGIoPzpNaWRvcml8Tm9va3xTYWZhcmkpXFxiL2kudGVzdCh1YSkgJiYgIS9eKD86VHJpZGVudHxFZGdlSFRNTCkkLy50ZXN0KGxheW91dCkgJiYgJ1dlYktpdCcgfHxcbiAgICAgICAgICAhbGF5b3V0ICYmIC9cXGJNU0lFXFxiL2kudGVzdCh1YSkgJiYgKG9zID09ICdNYWMgT1MnID8gJ1Rhc21hbicgOiAnVHJpZGVudCcpIHx8XG4gICAgICAgICAgbGF5b3V0ID09ICdXZWJLaXQnICYmIC9cXGJQbGF5U3RhdGlvblxcYig/ISBWaXRhXFxiKS9pLnRlc3QobmFtZSkgJiYgJ05ldEZyb250J1xuICAgICAgICApKSB7XG4gICAgICBsYXlvdXQgPSBbZGF0YV07XG4gICAgfVxuICAgIC8vIERldGVjdCBXaW5kb3dzIFBob25lIDcgZGVza3RvcCBtb2RlLlxuICAgIGlmIChuYW1lID09ICdJRScgJiYgKGRhdGEgPSAoLzsgKig/OlhCTFdQfFp1bmVXUCkoXFxkKykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcbiAgICAgIG5hbWUgKz0gJyBNb2JpbGUnO1xuICAgICAgb3MgPSAnV2luZG93cyBQaG9uZSAnICsgKC9cXCskLy50ZXN0KGRhdGEpID8gZGF0YSA6IGRhdGEgKyAnLngnKTtcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2Rlc2t0b3AgbW9kZScpO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgV2luZG93cyBQaG9uZSA4LnggZGVza3RvcCBtb2RlLlxuICAgIGVsc2UgaWYgKC9cXGJXUERlc2t0b3BcXGIvaS50ZXN0KHVhKSkge1xuICAgICAgbmFtZSA9ICdJRSBNb2JpbGUnO1xuICAgICAgb3MgPSAnV2luZG93cyBQaG9uZSA4LngnO1xuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XG4gICAgICB2ZXJzaW9uIHx8ICh2ZXJzaW9uID0gKC9cXGJydjooW1xcZC5dKykvLmV4ZWModWEpIHx8IDApWzFdKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IElFIDExIGlkZW50aWZ5aW5nIGFzIG90aGVyIGJyb3dzZXJzLlxuICAgIGVsc2UgaWYgKG5hbWUgIT0gJ0lFJyAmJiBsYXlvdXQgPT0gJ1RyaWRlbnQnICYmIChkYXRhID0gL1xcYnJ2OihbXFxkLl0rKS8uZXhlYyh1YSkpKSB7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdpZGVudGlmeWluZyBhcyAnICsgbmFtZSArICh2ZXJzaW9uID8gJyAnICsgdmVyc2lvbiA6ICcnKSk7XG4gICAgICB9XG4gICAgICBuYW1lID0gJ0lFJztcbiAgICAgIHZlcnNpb24gPSBkYXRhWzFdO1xuICAgIH1cbiAgICAvLyBMZXZlcmFnZSBlbnZpcm9ubWVudCBmZWF0dXJlcy5cbiAgICBpZiAodXNlRmVhdHVyZXMpIHtcbiAgICAgIC8vIERldGVjdCBzZXJ2ZXItc2lkZSBlbnZpcm9ubWVudHMuXG4gICAgICAvLyBSaGlubyBoYXMgYSBnbG9iYWwgZnVuY3Rpb24gd2hpbGUgb3RoZXJzIGhhdmUgYSBnbG9iYWwgb2JqZWN0LlxuICAgICAgaWYgKGlzSG9zdFR5cGUoY29udGV4dCwgJ2dsb2JhbCcpKSB7XG4gICAgICAgIGlmIChqYXZhKSB7XG4gICAgICAgICAgZGF0YSA9IGphdmEubGFuZy5TeXN0ZW07XG4gICAgICAgICAgYXJjaCA9IGRhdGEuZ2V0UHJvcGVydHkoJ29zLmFyY2gnKTtcbiAgICAgICAgICBvcyA9IG9zIHx8IGRhdGEuZ2V0UHJvcGVydHkoJ29zLm5hbWUnKSArICcgJyArIGRhdGEuZ2V0UHJvcGVydHkoJ29zLnZlcnNpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmhpbm8pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmVyc2lvbiA9IGNvbnRleHQucmVxdWlyZSgncmluZ28vZW5naW5lJykudmVyc2lvbi5qb2luKCcuJyk7XG4gICAgICAgICAgICBuYW1lID0gJ1JpbmdvSlMnO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgaWYgKChkYXRhID0gY29udGV4dC5zeXN0ZW0pICYmIGRhdGEuZ2xvYmFsLnN5c3RlbSA9PSBjb250ZXh0LnN5c3RlbSkge1xuICAgICAgICAgICAgICBuYW1lID0gJ05hcndoYWwnO1xuICAgICAgICAgICAgICBvcyB8fCAob3MgPSBkYXRhWzBdLm9zIHx8IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSAnUmhpbm8nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICB0eXBlb2YgY29udGV4dC5wcm9jZXNzID09ICdvYmplY3QnICYmICFjb250ZXh0LnByb2Nlc3MuYnJvd3NlciAmJlxuICAgICAgICAgIChkYXRhID0gY29udGV4dC5wcm9jZXNzKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEudmVyc2lvbnMgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS52ZXJzaW9ucy5lbGVjdHJvbiA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdOb2RlICcgKyBkYXRhLnZlcnNpb25zLm5vZGUpO1xuICAgICAgICAgICAgICBuYW1lID0gJ0VsZWN0cm9uJztcbiAgICAgICAgICAgICAgdmVyc2lvbiA9IGRhdGEudmVyc2lvbnMuZWxlY3Ryb247XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLnZlcnNpb25zLm53ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ0Nocm9taXVtICcgKyB2ZXJzaW9uLCAnTm9kZSAnICsgZGF0YS52ZXJzaW9ucy5ub2RlKTtcbiAgICAgICAgICAgICAgbmFtZSA9ICdOVy5qcyc7XG4gICAgICAgICAgICAgIHZlcnNpb24gPSBkYXRhLnZlcnNpb25zLm53O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSAnTm9kZS5qcyc7XG4gICAgICAgICAgICBhcmNoID0gZGF0YS5hcmNoO1xuICAgICAgICAgICAgb3MgPSBkYXRhLnBsYXRmb3JtO1xuICAgICAgICAgICAgdmVyc2lvbiA9IC9bXFxkLl0rLy5leGVjKGRhdGEudmVyc2lvbik7XG4gICAgICAgICAgICB2ZXJzaW9uID0gdmVyc2lvbiA/IHZlcnNpb25bMF0gOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IEFkb2JlIEFJUi5cbiAgICAgIGVsc2UgaWYgKGdldENsYXNzT2YoKGRhdGEgPSBjb250ZXh0LnJ1bnRpbWUpKSA9PSBhaXJSdW50aW1lQ2xhc3MpIHtcbiAgICAgICAgbmFtZSA9ICdBZG9iZSBBSVInO1xuICAgICAgICBvcyA9IGRhdGEuZmxhc2guc3lzdGVtLkNhcGFiaWxpdGllcy5vcztcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCBQaGFudG9tSlMuXG4gICAgICBlbHNlIGlmIChnZXRDbGFzc09mKChkYXRhID0gY29udGV4dC5waGFudG9tKSkgPT0gcGhhbnRvbUNsYXNzKSB7XG4gICAgICAgIG5hbWUgPSAnUGhhbnRvbUpTJztcbiAgICAgICAgdmVyc2lvbiA9IChkYXRhID0gZGF0YS52ZXJzaW9uIHx8IG51bGwpICYmIChkYXRhLm1ham9yICsgJy4nICsgZGF0YS5taW5vciArICcuJyArIGRhdGEucGF0Y2gpO1xuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IElFIGNvbXBhdGliaWxpdHkgbW9kZXMuXG4gICAgICBlbHNlIGlmICh0eXBlb2YgZG9jLmRvY3VtZW50TW9kZSA9PSAnbnVtYmVyJyAmJiAoZGF0YSA9IC9cXGJUcmlkZW50XFwvKFxcZCspL2kuZXhlYyh1YSkpKSB7XG4gICAgICAgIC8vIFdlJ3JlIGluIGNvbXBhdGliaWxpdHkgbW9kZSB3aGVuIHRoZSBUcmlkZW50IHZlcnNpb24gKyA0IGRvZXNuJ3RcbiAgICAgICAgLy8gZXF1YWwgdGhlIGRvY3VtZW50IG1vZGUuXG4gICAgICAgIHZlcnNpb24gPSBbdmVyc2lvbiwgZG9jLmRvY3VtZW50TW9kZV07XG4gICAgICAgIGlmICgoZGF0YSA9ICtkYXRhWzFdICsgNCkgIT0gdmVyc2lvblsxXSkge1xuICAgICAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ0lFICcgKyB2ZXJzaW9uWzFdICsgJyBtb2RlJyk7XG4gICAgICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gPSAnJyk7XG4gICAgICAgICAgdmVyc2lvblsxXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmVyc2lvbiA9IG5hbWUgPT0gJ0lFJyA/IFN0cmluZyh2ZXJzaW9uWzFdLnRvRml4ZWQoMSkpIDogdmVyc2lvblswXTtcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCBJRSAxMSBtYXNraW5nIGFzIG90aGVyIGJyb3dzZXJzLlxuICAgICAgZWxzZSBpZiAodHlwZW9mIGRvYy5kb2N1bWVudE1vZGUgPT0gJ251bWJlcicgJiYgL14oPzpDaHJvbWV8RmlyZWZveClcXGIvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZGVzY3JpcHRpb24ucHVzaCgnbWFza2luZyBhcyAnICsgbmFtZSArICcgJyArIHZlcnNpb24pO1xuICAgICAgICBuYW1lID0gJ0lFJztcbiAgICAgICAgdmVyc2lvbiA9ICcxMS4wJztcbiAgICAgICAgbGF5b3V0ID0gWydUcmlkZW50J107XG4gICAgICAgIG9zID0gJ1dpbmRvd3MnO1xuICAgICAgfVxuICAgICAgb3MgPSBvcyAmJiBmb3JtYXQob3MpO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgcHJlcmVsZWFzZSBwaGFzZXMuXG4gICAgaWYgKHZlcnNpb24gJiYgKGRhdGEgPVxuICAgICAgICAgIC8oPzpbYWJdfGRwfHByZXxbYWJdXFxkK3ByZSkoPzpcXGQrXFwrPyk/JC9pLmV4ZWModmVyc2lvbikgfHxcbiAgICAgICAgICAvKD86YWxwaGF8YmV0YSkoPzogP1xcZCk/L2kuZXhlYyh1YSArICc7JyArICh1c2VGZWF0dXJlcyAmJiBuYXYuYXBwTWlub3JWZXJzaW9uKSkgfHxcbiAgICAgICAgICAvXFxiTWluZWZpZWxkXFxiL2kudGVzdCh1YSkgJiYgJ2EnXG4gICAgICAgICkpIHtcbiAgICAgIHByZXJlbGVhc2UgPSAvYi9pLnRlc3QoZGF0YSkgPyAnYmV0YScgOiAnYWxwaGEnO1xuICAgICAgdmVyc2lvbiA9IHZlcnNpb24ucmVwbGFjZShSZWdFeHAoZGF0YSArICdcXFxcKz8kJyksICcnKSArXG4gICAgICAgIChwcmVyZWxlYXNlID09ICdiZXRhJyA/IGJldGEgOiBhbHBoYSkgKyAoL1xcZCtcXCs/Ly5leGVjKGRhdGEpIHx8ICcnKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IEZpcmVmb3ggTW9iaWxlLlxuICAgIGlmIChuYW1lID09ICdGZW5uZWMnIHx8IG5hbWUgPT0gJ0ZpcmVmb3gnICYmIC9cXGIoPzpBbmRyb2lkfEZpcmVmb3ggT1MpXFxiLy50ZXN0KG9zKSkge1xuICAgICAgbmFtZSA9ICdGaXJlZm94IE1vYmlsZSc7XG4gICAgfVxuICAgIC8vIE9ic2N1cmUgTWF4dGhvbidzIHVucmVsaWFibGUgdmVyc2lvbi5cbiAgICBlbHNlIGlmIChuYW1lID09ICdNYXh0aG9uJyAmJiB2ZXJzaW9uKSB7XG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi5yZXBsYWNlKC9cXC5bXFxkLl0rLywgJy54Jyk7XG4gICAgfVxuICAgIC8vIERldGVjdCBYYm94IDM2MCBhbmQgWGJveCBPbmUuXG4gICAgZWxzZSBpZiAoL1xcYlhib3hcXGIvaS50ZXN0KHByb2R1Y3QpKSB7XG4gICAgICBpZiAocHJvZHVjdCA9PSAnWGJveCAzNjAnKSB7XG4gICAgICAgIG9zID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9kdWN0ID09ICdYYm94IDM2MCcgJiYgL1xcYklFTW9iaWxlXFxiLy50ZXN0KHVhKSkge1xuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdtb2JpbGUgbW9kZScpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgbW9iaWxlIHBvc3RmaXguXG4gICAgZWxzZSBpZiAoKC9eKD86Q2hyb21lfElFfE9wZXJhKSQvLnRlc3QobmFtZSkgfHwgbmFtZSAmJiAhcHJvZHVjdCAmJiAhL0Jyb3dzZXJ8TW9iaS8udGVzdChuYW1lKSkgJiZcbiAgICAgICAgKG9zID09ICdXaW5kb3dzIENFJyB8fCAvTW9iaS9pLnRlc3QodWEpKSkge1xuICAgICAgbmFtZSArPSAnIE1vYmlsZSc7XG4gICAgfVxuICAgIC8vIERldGVjdCBJRSBwbGF0Zm9ybSBwcmV2aWV3LlxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ0lFJyAmJiB1c2VGZWF0dXJlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNvbnRleHQuZXh0ZXJuYWwgPT09IG51bGwpIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdwbGF0Zm9ybSBwcmV2aWV3Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdlbWJlZGRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRlY3QgQmxhY2tCZXJyeSBPUyB2ZXJzaW9uLlxuICAgIC8vIGh0dHA6Ly9kb2NzLmJsYWNrYmVycnkuY29tL2VuL2RldmVsb3BlcnMvZGVsaXZlcmFibGVzLzE4MTY5L0hUVFBfaGVhZGVyc19zZW50X2J5X0JCX0Jyb3dzZXJfMTIzNDkxMV8xMS5qc3BcbiAgICBlbHNlIGlmICgoL1xcYkJsYWNrQmVycnlcXGIvLnRlc3QocHJvZHVjdCkgfHwgL1xcYkJCMTBcXGIvLnRlc3QodWEpKSAmJiAoZGF0YSA9XG4gICAgICAgICAgKFJlZ0V4cChwcm9kdWN0LnJlcGxhY2UoLyArL2csICcgKicpICsgJy8oWy5cXFxcZF0rKScsICdpJykuZXhlYyh1YSkgfHwgMClbMV0gfHxcbiAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICkpIHtcbiAgICAgIGRhdGEgPSBbZGF0YSwgL0JCMTAvLnRlc3QodWEpXTtcbiAgICAgIG9zID0gKGRhdGFbMV0gPyAocHJvZHVjdCA9IG51bGwsIG1hbnVmYWN0dXJlciA9ICdCbGFja0JlcnJ5JykgOiAnRGV2aWNlIFNvZnR3YXJlJykgKyAnICcgKyBkYXRhWzBdO1xuICAgICAgdmVyc2lvbiA9IG51bGw7XG4gICAgfVxuICAgIC8vIERldGVjdCBPcGVyYSBpZGVudGlmeWluZy9tYXNraW5nIGl0c2VsZiBhcyBhbm90aGVyIGJyb3dzZXIuXG4gICAgLy8gaHR0cDovL3d3dy5vcGVyYS5jb20vc3VwcG9ydC9rYi92aWV3Lzg0My9cbiAgICBlbHNlIGlmICh0aGlzICE9IGZvck93biAmJiBwcm9kdWN0ICE9ICdXaWknICYmIChcbiAgICAgICAgICAodXNlRmVhdHVyZXMgJiYgb3BlcmEpIHx8XG4gICAgICAgICAgKC9PcGVyYS8udGVzdChuYW1lKSAmJiAvXFxiKD86TVNJRXxGaXJlZm94KVxcYi9pLnRlc3QodWEpKSB8fFxuICAgICAgICAgIChuYW1lID09ICdGaXJlZm94JyAmJiAvXFxiT1MgWCAoPzpcXGQrXFwuKXsyLH0vLnRlc3Qob3MpKSB8fFxuICAgICAgICAgIChuYW1lID09ICdJRScgJiYgKFxuICAgICAgICAgICAgKG9zICYmICEvXldpbi8udGVzdChvcykgJiYgdmVyc2lvbiA+IDUuNSkgfHxcbiAgICAgICAgICAgIC9cXGJXaW5kb3dzIFhQXFxiLy50ZXN0KG9zKSAmJiB2ZXJzaW9uID4gOCB8fFxuICAgICAgICAgICAgdmVyc2lvbiA9PSA4ICYmICEvXFxiVHJpZGVudFxcYi8udGVzdCh1YSlcbiAgICAgICAgICApKVxuICAgICAgICApICYmICFyZU9wZXJhLnRlc3QoKGRhdGEgPSBwYXJzZS5jYWxsKGZvck93biwgdWEucmVwbGFjZShyZU9wZXJhLCAnJykgKyAnOycpKSkgJiYgZGF0YS5uYW1lKSB7XG4gICAgICAvLyBXaGVuIFwiaWRlbnRpZnlpbmdcIiwgdGhlIFVBIGNvbnRhaW5zIGJvdGggT3BlcmEgYW5kIHRoZSBvdGhlciBicm93c2VyJ3MgbmFtZS5cbiAgICAgIGRhdGEgPSAnaW5nIGFzICcgKyBkYXRhLm5hbWUgKyAoKGRhdGEgPSBkYXRhLnZlcnNpb24pID8gJyAnICsgZGF0YSA6ICcnKTtcbiAgICAgIGlmIChyZU9wZXJhLnRlc3QobmFtZSkpIHtcbiAgICAgICAgaWYgKC9cXGJJRVxcYi8udGVzdChkYXRhKSAmJiBvcyA9PSAnTWFjIE9TJykge1xuICAgICAgICAgIG9zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gJ2lkZW50aWZ5JyArIGRhdGE7XG4gICAgICB9XG4gICAgICAvLyBXaGVuIFwibWFza2luZ1wiLCB0aGUgVUEgY29udGFpbnMgb25seSB0aGUgb3RoZXIgYnJvd3NlcidzIG5hbWUuXG4gICAgICBlbHNlIHtcbiAgICAgICAgZGF0YSA9ICdtYXNrJyArIGRhdGE7XG4gICAgICAgIGlmIChvcGVyYUNsYXNzKSB7XG4gICAgICAgICAgbmFtZSA9IGZvcm1hdChvcGVyYUNsYXNzLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMSAkMicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gJ09wZXJhJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoL1xcYklFXFxiLy50ZXN0KGRhdGEpKSB7XG4gICAgICAgICAgb3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXNlRmVhdHVyZXMpIHtcbiAgICAgICAgICB2ZXJzaW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGF5b3V0ID0gWydQcmVzdG8nXTtcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIC8vIERldGVjdCBXZWJLaXQgTmlnaHRseSBhbmQgYXBwcm94aW1hdGUgQ2hyb21lL1NhZmFyaSB2ZXJzaW9ucy5cbiAgICBpZiAoKGRhdGEgPSAoL1xcYkFwcGxlV2ViS2l0XFwvKFtcXGQuXStcXCs/KS9pLmV4ZWModWEpIHx8IDApWzFdKSkge1xuICAgICAgLy8gQ29ycmVjdCBidWlsZCBudW1iZXIgZm9yIG51bWVyaWMgY29tcGFyaXNvbi5cbiAgICAgIC8vIChlLmcuIFwiNTMyLjVcIiBiZWNvbWVzIFwiNTMyLjA1XCIpXG4gICAgICBkYXRhID0gW3BhcnNlRmxvYXQoZGF0YS5yZXBsYWNlKC9cXC4oXFxkKSQvLCAnLjAkMScpKSwgZGF0YV07XG4gICAgICAvLyBOaWdodGx5IGJ1aWxkcyBhcmUgcG9zdGZpeGVkIHdpdGggYSBcIitcIi5cbiAgICAgIGlmIChuYW1lID09ICdTYWZhcmknICYmIGRhdGFbMV0uc2xpY2UoLTEpID09ICcrJykge1xuICAgICAgICBuYW1lID0gJ1dlYktpdCBOaWdodGx5JztcbiAgICAgICAgcHJlcmVsZWFzZSA9ICdhbHBoYSc7XG4gICAgICAgIHZlcnNpb24gPSBkYXRhWzFdLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIGluY29ycmVjdCBicm93c2VyIHZlcnNpb25zLlxuICAgICAgZWxzZSBpZiAodmVyc2lvbiA9PSBkYXRhWzFdIHx8XG4gICAgICAgICAgdmVyc2lvbiA9PSAoZGF0YVsyXSA9ICgvXFxiU2FmYXJpXFwvKFtcXGQuXStcXCs/KS9pLmV4ZWModWEpIHx8IDApWzFdKSkge1xuICAgICAgICB2ZXJzaW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSB0aGUgZnVsbCBDaHJvbWUgdmVyc2lvbiB3aGVuIGF2YWlsYWJsZS5cbiAgICAgIGRhdGFbMV0gPSAoL1xcYkNocm9tZVxcLyhbXFxkLl0rKS9pLmV4ZWModWEpIHx8IDApWzFdO1xuICAgICAgLy8gRGV0ZWN0IEJsaW5rIGxheW91dCBlbmdpbmUuXG4gICAgICBpZiAoZGF0YVswXSA9PSA1MzcuMzYgJiYgZGF0YVsyXSA9PSA1MzcuMzYgJiYgcGFyc2VGbG9hdChkYXRhWzFdKSA+PSAyOCAmJiBsYXlvdXQgPT0gJ1dlYktpdCcpIHtcbiAgICAgICAgbGF5b3V0ID0gWydCbGluayddO1xuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IEphdmFTY3JpcHRDb3JlLlxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NzY4NDc0L2hvdy1jYW4taS1kZXRlY3Qtd2hpY2gtamF2YXNjcmlwdC1lbmdpbmUtdjgtb3ItanNjLWlzLXVzZWQtYXQtcnVudGltZS1pbi1hbmRyb2lcbiAgICAgIGlmICghdXNlRmVhdHVyZXMgfHwgKCFsaWtlQ2hyb21lICYmICFkYXRhWzFdKSkge1xuICAgICAgICBsYXlvdXQgJiYgKGxheW91dFsxXSA9ICdsaWtlIFNhZmFyaScpO1xuICAgICAgICBkYXRhID0gKGRhdGEgPSBkYXRhWzBdLCBkYXRhIDwgNDAwID8gMSA6IGRhdGEgPCA1MDAgPyAyIDogZGF0YSA8IDUyNiA/IDMgOiBkYXRhIDwgNTMzID8gNCA6IGRhdGEgPCA1MzQgPyAnNCsnIDogZGF0YSA8IDUzNSA/IDUgOiBkYXRhIDwgNTM3ID8gNiA6IGRhdGEgPCA1MzggPyA3IDogZGF0YSA8IDYwMSA/IDggOiAnOCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gPSAnbGlrZSBDaHJvbWUnKTtcbiAgICAgICAgZGF0YSA9IGRhdGFbMV0gfHwgKGRhdGEgPSBkYXRhWzBdLCBkYXRhIDwgNTMwID8gMSA6IGRhdGEgPCA1MzIgPyAyIDogZGF0YSA8IDUzMi4wNSA/IDMgOiBkYXRhIDwgNTMzID8gNCA6IGRhdGEgPCA1MzQuMDMgPyA1IDogZGF0YSA8IDUzNC4wNyA/IDYgOiBkYXRhIDwgNTM0LjEwID8gNyA6IGRhdGEgPCA1MzQuMTMgPyA4IDogZGF0YSA8IDUzNC4xNiA/IDkgOiBkYXRhIDwgNTM0LjI0ID8gMTAgOiBkYXRhIDwgNTM0LjMwID8gMTEgOiBkYXRhIDwgNTM1LjAxID8gMTIgOiBkYXRhIDwgNTM1LjAyID8gJzEzKycgOiBkYXRhIDwgNTM1LjA3ID8gMTUgOiBkYXRhIDwgNTM1LjExID8gMTYgOiBkYXRhIDwgNTM1LjE5ID8gMTcgOiBkYXRhIDwgNTM2LjA1ID8gMTggOiBkYXRhIDwgNTM2LjEwID8gMTkgOiBkYXRhIDwgNTM3LjAxID8gMjAgOiBkYXRhIDwgNTM3LjExID8gJzIxKycgOiBkYXRhIDwgNTM3LjEzID8gMjMgOiBkYXRhIDwgNTM3LjE4ID8gMjQgOiBkYXRhIDwgNTM3LjI0ID8gMjUgOiBkYXRhIDwgNTM3LjM2ID8gMjYgOiBsYXlvdXQgIT0gJ0JsaW5rJyA/ICcyNycgOiAnMjgnKTtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCB0aGUgcG9zdGZpeCBvZiBcIi54XCIgb3IgXCIrXCIgZm9yIGFwcHJveGltYXRlIHZlcnNpb25zLlxuICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gKz0gJyAnICsgKGRhdGEgKz0gdHlwZW9mIGRhdGEgPT0gJ251bWJlcicgPyAnLngnIDogL1suK10vLnRlc3QoZGF0YSkgPyAnJyA6ICcrJykpO1xuICAgICAgLy8gT2JzY3VyZSB2ZXJzaW9uIGZvciBzb21lIFNhZmFyaSAxLTIgcmVsZWFzZXMuXG4gICAgICBpZiAobmFtZSA9PSAnU2FmYXJpJyAmJiAoIXZlcnNpb24gfHwgcGFyc2VJbnQodmVyc2lvbikgPiA0NSkpIHtcbiAgICAgICAgdmVyc2lvbiA9IGRhdGE7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERldGVjdCBPcGVyYSBkZXNrdG9wIG1vZGVzLlxuICAgIGlmIChuYW1lID09ICdPcGVyYScgJiYgIChkYXRhID0gL1xcYnpib3Z8enZhdiQvLmV4ZWMob3MpKSkge1xuICAgICAgbmFtZSArPSAnICc7XG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdkZXNrdG9wIG1vZGUnKTtcbiAgICAgIGlmIChkYXRhID09ICd6dmF2Jykge1xuICAgICAgICBuYW1lICs9ICdNaW5pJztcbiAgICAgICAgdmVyc2lvbiA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lICs9ICdNb2JpbGUnO1xuICAgICAgfVxuICAgICAgb3MgPSBvcy5yZXBsYWNlKFJlZ0V4cCgnIConICsgZGF0YSArICckJyksICcnKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IENocm9tZSBkZXNrdG9wIG1vZGUuXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnU2FmYXJpJyAmJiAvXFxiQ2hyb21lXFxiLy5leGVjKGxheW91dCAmJiBsYXlvdXRbMV0pKSB7XG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdkZXNrdG9wIG1vZGUnKTtcbiAgICAgIG5hbWUgPSAnQ2hyb21lIE1vYmlsZSc7XG4gICAgICB2ZXJzaW9uID0gbnVsbDtcblxuICAgICAgaWYgKC9cXGJPUyBYXFxiLy50ZXN0KG9zKSkge1xuICAgICAgICBtYW51ZmFjdHVyZXIgPSAnQXBwbGUnO1xuICAgICAgICBvcyA9ICdpT1MgNC4zKyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFN0cmlwIGluY29ycmVjdCBPUyB2ZXJzaW9ucy5cbiAgICBpZiAodmVyc2lvbiAmJiB2ZXJzaW9uLmluZGV4T2YoKGRhdGEgPSAvW1xcZC5dKyQvLmV4ZWMob3MpKSkgPT0gMCAmJlxuICAgICAgICB1YS5pbmRleE9mKCcvJyArIGRhdGEgKyAnLScpID4gLTEpIHtcbiAgICAgIG9zID0gdHJpbShvcy5yZXBsYWNlKGRhdGEsICcnKSk7XG4gICAgfVxuICAgIC8vIEFkZCBsYXlvdXQgZW5naW5lLlxuICAgIGlmIChsYXlvdXQgJiYgIS9cXGIoPzpBdmFudHxOb29rKVxcYi8udGVzdChuYW1lKSAmJiAoXG4gICAgICAgIC9Ccm93c2VyfEx1bmFzY2FwZXxNYXh0aG9uLy50ZXN0KG5hbWUpIHx8XG4gICAgICAgIG5hbWUgIT0gJ1NhZmFyaScgJiYgL15pT1MvLnRlc3Qob3MpICYmIC9cXGJTYWZhcmlcXGIvLnRlc3QobGF5b3V0WzFdKSB8fFxuICAgICAgICAvXig/OkFkb2JlfEFyb3JhfEJyZWFjaHxNaWRvcml8T3BlcmF8UGhhbnRvbXxSZWtvbnF8Um9ja3xTYW1zdW5nIEludGVybmV0fFNsZWlwbmlyfFdlYikvLnRlc3QobmFtZSkgJiYgbGF5b3V0WzFdKSkge1xuICAgICAgLy8gRG9uJ3QgYWRkIGxheW91dCBkZXRhaWxzIHRvIGRlc2NyaXB0aW9uIGlmIHRoZXkgYXJlIGZhbHNleS5cbiAgICAgIChkYXRhID0gbGF5b3V0W2xheW91dC5sZW5ndGggLSAxXSkgJiYgZGVzY3JpcHRpb24ucHVzaChkYXRhKTtcbiAgICB9XG4gICAgLy8gQ29tYmluZSBjb250ZXh0dWFsIGluZm9ybWF0aW9uLlxuICAgIGlmIChkZXNjcmlwdGlvbi5sZW5ndGgpIHtcbiAgICAgIGRlc2NyaXB0aW9uID0gWycoJyArIGRlc2NyaXB0aW9uLmpvaW4oJzsgJykgKyAnKSddO1xuICAgIH1cbiAgICAvLyBBcHBlbmQgbWFudWZhY3R1cmVyIHRvIGRlc2NyaXB0aW9uLlxuICAgIGlmIChtYW51ZmFjdHVyZXIgJiYgcHJvZHVjdCAmJiBwcm9kdWN0LmluZGV4T2YobWFudWZhY3R1cmVyKSA8IDApIHtcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ29uICcgKyBtYW51ZmFjdHVyZXIpO1xuICAgIH1cbiAgICAvLyBBcHBlbmQgcHJvZHVjdCB0byBkZXNjcmlwdGlvbi5cbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaCgoL15vbiAvLnRlc3QoZGVzY3JpcHRpb25bZGVzY3JpcHRpb24ubGVuZ3RoIC0gMV0pID8gJycgOiAnb24gJykgKyBwcm9kdWN0KTtcbiAgICB9XG4gICAgLy8gUGFyc2UgdGhlIE9TIGludG8gYW4gb2JqZWN0LlxuICAgIGlmIChvcykge1xuICAgICAgZGF0YSA9IC8gKFtcXGQuK10rKSQvLmV4ZWMob3MpO1xuICAgICAgaXNTcGVjaWFsQ2FzZWRPUyA9IGRhdGEgJiYgb3MuY2hhckF0KG9zLmxlbmd0aCAtIGRhdGFbMF0ubGVuZ3RoIC0gMSkgPT0gJy8nO1xuICAgICAgb3MgPSB7XG4gICAgICAgICdhcmNoaXRlY3R1cmUnOiAzMixcbiAgICAgICAgJ2ZhbWlseSc6IChkYXRhICYmICFpc1NwZWNpYWxDYXNlZE9TKSA/IG9zLnJlcGxhY2UoZGF0YVswXSwgJycpIDogb3MsXG4gICAgICAgICd2ZXJzaW9uJzogZGF0YSA/IGRhdGFbMV0gOiBudWxsLFxuICAgICAgICAndG9TdHJpbmcnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mYW1pbHkgKyAoKHZlcnNpb24gJiYgIWlzU3BlY2lhbENhc2VkT1MpID8gJyAnICsgdmVyc2lvbiA6ICcnKSArICh0aGlzLmFyY2hpdGVjdHVyZSA9PSA2NCA/ICcgNjQtYml0JyA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQWRkIGJyb3dzZXIvT1MgYXJjaGl0ZWN0dXJlLlxuICAgIGlmICgoZGF0YSA9IC9cXGIoPzpBTUR8SUF8V2lufFdPV3x4ODZffHgpNjRcXGIvaS5leGVjKGFyY2gpKSAmJiAhL1xcYmk2ODZcXGIvaS50ZXN0KGFyY2gpKSB7XG4gICAgICBpZiAob3MpIHtcbiAgICAgICAgb3MuYXJjaGl0ZWN0dXJlID0gNjQ7XG4gICAgICAgIG9zLmZhbWlseSA9IG9zLmZhbWlseS5yZXBsYWNlKFJlZ0V4cCgnIConICsgZGF0YSksICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgICBuYW1lICYmICgvXFxiV09XNjRcXGIvaS50ZXN0KHVhKSB8fFxuICAgICAgICAgICh1c2VGZWF0dXJlcyAmJiAvXFx3KD86ODZ8MzIpJC8udGVzdChuYXYuY3B1Q2xhc3MgfHwgbmF2LnBsYXRmb3JtKSAmJiAhL1xcYldpbjY0OyB4NjRcXGIvaS50ZXN0KHVhKSkpXG4gICAgICApIHtcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnMzItYml0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENocm9tZSAzOSBhbmQgYWJvdmUgb24gT1MgWCBpcyBhbHdheXMgNjQtYml0LlxuICAgIGVsc2UgaWYgKFxuICAgICAgICBvcyAmJiAvXk9TIFgvLnRlc3Qob3MuZmFtaWx5KSAmJlxuICAgICAgICBuYW1lID09ICdDaHJvbWUnICYmIHBhcnNlRmxvYXQodmVyc2lvbikgPj0gMzlcbiAgICApIHtcbiAgICAgIG9zLmFyY2hpdGVjdHVyZSA9IDY0O1xuICAgIH1cblxuICAgIHVhIHx8ICh1YSA9IG51bGwpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBsYXRmb3JtIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYXRmb3JtXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHBsYXRmb3JtID0ge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGxhdGZvcm0gZGVzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHBsYXRmb3JtLmRlc2NyaXB0aW9uID0gdWE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYnJvd3NlcidzIGxheW91dCBlbmdpbmUuXG4gICAgICpcbiAgICAgKiBUaGUgbGlzdCBvZiBjb21tb24gbGF5b3V0IGVuZ2luZXMgaW5jbHVkZTpcbiAgICAgKiBcIkJsaW5rXCIsIFwiRWRnZUhUTUxcIiwgXCJHZWNrb1wiLCBcIlRyaWRlbnRcIiBhbmQgXCJXZWJLaXRcIlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5sYXlvdXQgPSBsYXlvdXQgJiYgbGF5b3V0WzBdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb2R1Y3QncyBtYW51ZmFjdHVyZXIuXG4gICAgICpcbiAgICAgKiBUaGUgbGlzdCBvZiBtYW51ZmFjdHVyZXJzIGluY2x1ZGU6XG4gICAgICogXCJBcHBsZVwiLCBcIkFyY2hvc1wiLCBcIkFtYXpvblwiLCBcIkFzdXNcIiwgXCJCYXJuZXMgJiBOb2JsZVwiLCBcIkJsYWNrQmVycnlcIixcbiAgICAgKiBcIkdvb2dsZVwiLCBcIkhQXCIsIFwiSFRDXCIsIFwiTEdcIiwgXCJNaWNyb3NvZnRcIiwgXCJNb3Rvcm9sYVwiLCBcIk5pbnRlbmRvXCIsXG4gICAgICogXCJOb2tpYVwiLCBcIlNhbXN1bmdcIiBhbmQgXCJTb255XCJcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXG4gICAgICovXG4gICAgcGxhdGZvcm0ubWFudWZhY3R1cmVyID0gbWFudWZhY3R1cmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGJyb3dzZXIvZW52aXJvbm1lbnQuXG4gICAgICpcbiAgICAgKiBUaGUgbGlzdCBvZiBjb21tb24gYnJvd3NlciBuYW1lcyBpbmNsdWRlOlxuICAgICAqIFwiQ2hyb21lXCIsIFwiRWxlY3Ryb25cIiwgXCJGaXJlZm94XCIsIFwiRmlyZWZveCBmb3IgaU9TXCIsIFwiSUVcIixcbiAgICAgKiBcIk1pY3Jvc29mdCBFZGdlXCIsIFwiUGhhbnRvbUpTXCIsIFwiU2FmYXJpXCIsIFwiU2VhTW9ua2V5XCIsIFwiU2lsa1wiLFxuICAgICAqIFwiT3BlcmEgTWluaVwiIGFuZCBcIk9wZXJhXCJcbiAgICAgKlxuICAgICAqIE1vYmlsZSB2ZXJzaW9ucyBvZiBzb21lIGJyb3dzZXJzIGhhdmUgXCJNb2JpbGVcIiBhcHBlbmRlZCB0byB0aGVpciBuYW1lOlxuICAgICAqIGVnLiBcIkNocm9tZSBNb2JpbGVcIiwgXCJGaXJlZm94IE1vYmlsZVwiLCBcIklFIE1vYmlsZVwiIGFuZCBcIk9wZXJhIE1vYmlsZVwiXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHBsYXRmb3JtLm5hbWUgPSBuYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFscGhhL2JldGEgcmVsZWFzZSBpbmRpY2F0b3IuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHBsYXRmb3JtLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb2R1Y3QgaG9zdGluZyB0aGUgYnJvd3Nlci5cbiAgICAgKlxuICAgICAqIFRoZSBsaXN0IG9mIGNvbW1vbiBwcm9kdWN0cyBpbmNsdWRlOlxuICAgICAqXG4gICAgICogXCJCbGFja0JlcnJ5XCIsIFwiR2FsYXh5IFM0XCIsIFwiTHVtaWFcIiwgXCJpUGFkXCIsIFwiaVBvZFwiLCBcImlQaG9uZVwiLCBcIktpbmRsZVwiLFxuICAgICAqIFwiS2luZGxlIEZpcmVcIiwgXCJOZXh1c1wiLCBcIk5vb2tcIiwgXCJQbGF5Qm9va1wiLCBcIlRvdWNoUGFkXCIgYW5kIFwiVHJhbnNmb3JtZXJcIlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5wcm9kdWN0ID0gcHJvZHVjdDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBicm93c2VyJ3MgdXNlciBhZ2VudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHBsYXRmb3JtLnVhID0gdWE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYnJvd3Nlci9lbnZpcm9ubWVudCB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS52ZXJzaW9uID0gbmFtZSAmJiB2ZXJzaW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIG9wZXJhdGluZyBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5vcyA9IG9zIHx8IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgQ1BVIGFyY2hpdGVjdHVyZSB0aGUgT1MgaXMgYnVpbHQgZm9yLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xuICAgICAgICogQHR5cGUgbnVtYmVyfG51bGxcbiAgICAgICAqL1xuICAgICAgJ2FyY2hpdGVjdHVyZSc6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGZhbWlseSBvZiB0aGUgT1MuXG4gICAgICAgKlxuICAgICAgICogQ29tbW9uIHZhbHVlcyBpbmNsdWRlOlxuICAgICAgICogXCJXaW5kb3dzXCIsIFwiV2luZG93cyBTZXJ2ZXIgMjAwOCBSMiAvIDdcIiwgXCJXaW5kb3dzIFNlcnZlciAyMDA4IC8gVmlzdGFcIixcbiAgICAgICAqIFwiV2luZG93cyBYUFwiLCBcIk9TIFhcIiwgXCJVYnVudHVcIiwgXCJEZWJpYW5cIiwgXCJGZWRvcmFcIiwgXCJSZWQgSGF0XCIsIFwiU3VTRVwiLFxuICAgICAgICogXCJBbmRyb2lkXCIsIFwiaU9TXCIgYW5kIFwiV2luZG93cyBQaG9uZVwiXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXG4gICAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAgICovXG4gICAgICAnZmFtaWx5JzogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgT1MuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXG4gICAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAgICovXG4gICAgICAndmVyc2lvbic6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgT1Mgc3RyaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xuICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIE9TIHN0cmluZy5cbiAgICAgICAqL1xuICAgICAgJ3RvU3RyaW5nJzogZnVuY3Rpb24oKSB7IHJldHVybiAnbnVsbCc7IH1cbiAgICB9O1xuXG4gICAgcGxhdGZvcm0ucGFyc2UgPSBwYXJzZTtcbiAgICBwbGF0Zm9ybS50b1N0cmluZyA9IHRvU3RyaW5nUGxhdGZvcm07XG5cbiAgICBpZiAocGxhdGZvcm0udmVyc2lvbikge1xuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCh2ZXJzaW9uKTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtLm5hbWUpIHtcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQobmFtZSk7XG4gICAgfVxuICAgIGlmIChvcyAmJiBuYW1lICYmICEob3MgPT0gU3RyaW5nKG9zKS5zcGxpdCgnICcpWzBdICYmIChvcyA9PSBuYW1lLnNwbGl0KCcgJylbMF0gfHwgcHJvZHVjdCkpKSB7XG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKHByb2R1Y3QgPyAnKCcgKyBvcyArICcpJyA6ICdvbiAnICsgb3MpO1xuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRpb24ubGVuZ3RoKSB7XG4gICAgICBwbGF0Zm9ybS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBsYXRmb3JtO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IHBsYXRmb3JtLlxuICB2YXIgcGxhdGZvcm0gPSBwYXJzZSgpO1xuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBwbGF0Zm9ybSBvbiB0aGUgZ2xvYmFsIG9iamVjdCB0byBwcmV2ZW50IGVycm9ycyB3aGVuIHBsYXRmb3JtIGlzXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIHJvb3QucGxhdGZvcm0gPSBwbGF0Zm9ybTtcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvIHBsYXRmb3JtIGNhbiBiZSBhbGlhc2VkIHRocm91Z2ggcGF0aCBtYXBwaW5nLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwbGF0Zm9ybTtcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0LlxuICBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBzdXBwb3J0LlxuICAgIGZvck93bihwbGF0Zm9ybSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgZnJlZUV4cG9ydHNba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290LnBsYXRmb3JtID0gcGxhdGZvcm07XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcblxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXCJyZWdlbmVyYXRvclJ1bnRpbWVcIikgPj0gMDtcblxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuXG5pZiAoaGFkUnVudGltZSkge1xuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XG59IGVsc2Uge1xuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxuICB0cnkge1xuICAgIGRlbGV0ZSBnLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiOyhmdW5jdGlvbiAoc2F4KSB7IC8vIHdyYXBwZXIgZm9yIG5vbi1ub2RlIGVudnNcbiAgc2F4LnBhcnNlciA9IGZ1bmN0aW9uIChzdHJpY3QsIG9wdCkgeyByZXR1cm4gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdCkgfVxuICBzYXguU0FYUGFyc2VyID0gU0FYUGFyc2VyXG4gIHNheC5TQVhTdHJlYW0gPSBTQVhTdHJlYW1cbiAgc2F4LmNyZWF0ZVN0cmVhbSA9IGNyZWF0ZVN0cmVhbVxuXG4gIC8vIFdoZW4gd2UgcGFzcyB0aGUgTUFYX0JVRkZFUl9MRU5HVEggcG9zaXRpb24sIHN0YXJ0IGNoZWNraW5nIGZvciBidWZmZXIgb3ZlcnJ1bnMuXG4gIC8vIFdoZW4gd2UgY2hlY2ssIHNjaGVkdWxlIHRoZSBuZXh0IGNoZWNrIGZvciBNQVhfQlVGRkVSX0xFTkdUSCAtIChtYXgoYnVmZmVyIGxlbmd0aHMpKSxcbiAgLy8gc2luY2UgdGhhdCdzIHRoZSBlYXJsaWVzdCB0aGF0IGEgYnVmZmVyIG92ZXJydW4gY291bGQgb2NjdXIuICBUaGlzIHdheSwgY2hlY2tzIGFyZVxuICAvLyBhcyByYXJlIGFzIHJlcXVpcmVkLCBidXQgYXMgb2Z0ZW4gYXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBuZXZlciBjcm9zc2luZyB0aGlzIGJvdW5kLlxuICAvLyBGdXJ0aGVybW9yZSwgYnVmZmVycyBhcmUgb25seSB0ZXN0ZWQgYXQgbW9zdCBvbmNlIHBlciB3cml0ZSgpLCBzbyBwYXNzaW5nIGEgdmVyeVxuICAvLyBsYXJnZSBzdHJpbmcgaW50byB3cml0ZSgpIG1pZ2h0IGhhdmUgdW5kZXNpcmFibGUgZWZmZWN0cywgYnV0IHRoaXMgaXMgbWFuYWdlYWJsZSBieVxuICAvLyB0aGUgY2FsbGVyLCBzbyBpdCBpcyBhc3N1bWVkIHRvIGJlIHNhZmUuICBUaHVzLCBhIGNhbGwgdG8gd3JpdGUoKSBtYXksIGluIHRoZSBleHRyZW1lXG4gIC8vIGVkZ2UgY2FzZSwgcmVzdWx0IGluIGNyZWF0aW5nIGF0IG1vc3Qgb25lIGNvbXBsZXRlIGNvcHkgb2YgdGhlIHN0cmluZyBwYXNzZWQgaW4uXG4gIC8vIFNldCB0byBJbmZpbml0eSB0byBoYXZlIHVubGltaXRlZCBidWZmZXJzLlxuICBzYXguTUFYX0JVRkZFUl9MRU5HVEggPSA2NCAqIDEwMjRcblxuICB2YXIgYnVmZmVycyA9IFtcbiAgICAnY29tbWVudCcsICdzZ21sRGVjbCcsICd0ZXh0Tm9kZScsICd0YWdOYW1lJywgJ2RvY3R5cGUnLFxuICAgICdwcm9jSW5zdE5hbWUnLCAncHJvY0luc3RCb2R5JywgJ2VudGl0eScsICdhdHRyaWJOYW1lJyxcbiAgICAnYXR0cmliVmFsdWUnLCAnY2RhdGEnLCAnc2NyaXB0J1xuICBdXG5cbiAgc2F4LkVWRU5UUyA9IFtcbiAgICAndGV4dCcsXG4gICAgJ3Byb2Nlc3NpbmdpbnN0cnVjdGlvbicsXG4gICAgJ3NnbWxkZWNsYXJhdGlvbicsXG4gICAgJ2RvY3R5cGUnLFxuICAgICdjb21tZW50JyxcbiAgICAnb3BlbnRhZ3N0YXJ0JyxcbiAgICAnYXR0cmlidXRlJyxcbiAgICAnb3BlbnRhZycsXG4gICAgJ2Nsb3NldGFnJyxcbiAgICAnb3BlbmNkYXRhJyxcbiAgICAnY2RhdGEnLFxuICAgICdjbG9zZWNkYXRhJyxcbiAgICAnZXJyb3InLFxuICAgICdlbmQnLFxuICAgICdyZWFkeScsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ29wZW5uYW1lc3BhY2UnLFxuICAgICdjbG9zZW5hbWVzcGFjZSdcbiAgXVxuXG4gIGZ1bmN0aW9uIFNBWFBhcnNlciAoc3RyaWN0LCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYUGFyc2VyKSkge1xuICAgICAgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpXG4gICAgfVxuXG4gICAgdmFyIHBhcnNlciA9IHRoaXNcbiAgICBjbGVhckJ1ZmZlcnMocGFyc2VyKVxuICAgIHBhcnNlci5xID0gcGFyc2VyLmMgPSAnJ1xuICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIXG4gICAgcGFyc2VyLm9wdCA9IG9wdCB8fCB7fVxuICAgIHBhcnNlci5vcHQubG93ZXJjYXNlID0gcGFyc2VyLm9wdC5sb3dlcmNhc2UgfHwgcGFyc2VyLm9wdC5sb3dlcmNhc2V0YWdzXG4gICAgcGFyc2VyLmxvb3NlQ2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlID8gJ3RvTG93ZXJDYXNlJyA6ICd0b1VwcGVyQ2FzZSdcbiAgICBwYXJzZXIudGFncyA9IFtdXG4gICAgcGFyc2VyLmNsb3NlZCA9IHBhcnNlci5jbG9zZWRSb290ID0gcGFyc2VyLnNhd1Jvb3QgPSBmYWxzZVxuICAgIHBhcnNlci50YWcgPSBwYXJzZXIuZXJyb3IgPSBudWxsXG4gICAgcGFyc2VyLnN0cmljdCA9ICEhc3RyaWN0XG4gICAgcGFyc2VyLm5vc2NyaXB0ID0gISEoc3RyaWN0IHx8IHBhcnNlci5vcHQubm9zY3JpcHQpXG4gICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTlxuICAgIHBhcnNlci5zdHJpY3RFbnRpdGllcyA9IHBhcnNlci5vcHQuc3RyaWN0RW50aXRpZXNcbiAgICBwYXJzZXIuRU5USVRJRVMgPSBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPyBPYmplY3QuY3JlYXRlKHNheC5YTUxfRU5USVRJRVMpIDogT2JqZWN0LmNyZWF0ZShzYXguRU5USVRJRVMpXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QgPSBbXVxuXG4gICAgLy8gbmFtZXNwYWNlcyBmb3JtIGEgcHJvdG90eXBlIGNoYWluLlxuICAgIC8vIGl0IGFsd2F5cyBwb2ludHMgYXQgdGhlIGN1cnJlbnQgdGFnLFxuICAgIC8vIHdoaWNoIHByb3RvcyB0byBpdHMgcGFyZW50IHRhZy5cbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgcGFyc2VyLm5zID0gT2JqZWN0LmNyZWF0ZShyb290TlMpXG4gICAgfVxuXG4gICAgLy8gbW9zdGx5IGp1c3QgZm9yIGVycm9yIHJlcG9ydGluZ1xuICAgIHBhcnNlci50cmFja1Bvc2l0aW9uID0gcGFyc2VyLm9wdC5wb3NpdGlvbiAhPT0gZmFsc2VcbiAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgIHBhcnNlci5wb3NpdGlvbiA9IHBhcnNlci5saW5lID0gcGFyc2VyLmNvbHVtbiA9IDBcbiAgICB9XG4gICAgZW1pdChwYXJzZXIsICdvbnJlYWR5JylcbiAgfVxuXG4gIGlmICghT2JqZWN0LmNyZWF0ZSkge1xuICAgIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAobykge1xuICAgICAgZnVuY3Rpb24gRiAoKSB7fVxuICAgICAgRi5wcm90b3R5cGUgPSBvXG4gICAgICB2YXIgbmV3ZiA9IG5ldyBGKClcbiAgICAgIHJldHVybiBuZXdmXG4gICAgfVxuICB9XG5cbiAgaWYgKCFPYmplY3Qua2V5cykge1xuICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBhID0gW11cbiAgICAgIGZvciAodmFyIGkgaW4gbykgaWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIGEucHVzaChpKVxuICAgICAgcmV0dXJuIGFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0J1ZmZlckxlbmd0aCAocGFyc2VyKSB7XG4gICAgdmFyIG1heEFsbG93ZWQgPSBNYXRoLm1heChzYXguTUFYX0JVRkZFUl9MRU5HVEgsIDEwKVxuICAgIHZhciBtYXhBY3R1YWwgPSAwXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGxlbiA9IHBhcnNlcltidWZmZXJzW2ldXS5sZW5ndGhcbiAgICAgIGlmIChsZW4gPiBtYXhBbGxvd2VkKSB7XG4gICAgICAgIC8vIFRleHQvY2RhdGEgbm9kZXMgY2FuIGdldCBiaWcsIGFuZCBzaW5jZSB0aGV5J3JlIGJ1ZmZlcmVkLFxuICAgICAgICAvLyB3ZSBjYW4gZ2V0IGhlcmUgdW5kZXIgbm9ybWFsIGNvbmRpdGlvbnMuXG4gICAgICAgIC8vIEF2b2lkIGlzc3VlcyBieSBlbWl0dGluZyB0aGUgdGV4dCBub2RlIG5vdyxcbiAgICAgICAgLy8gc28gYXQgbGVhc3QgaXQgd29uJ3QgZ2V0IGFueSBiaWdnZXIuXG4gICAgICAgIHN3aXRjaCAoYnVmZmVyc1tpXSkge1xuICAgICAgICAgIGNhc2UgJ3RleHROb2RlJzpcbiAgICAgICAgICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgY2FzZSAnY2RhdGEnOlxuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2NyaXB0JywgcGFyc2VyLnNjcmlwdClcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgPSAnJ1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcihwYXJzZXIsICdNYXggYnVmZmVyIGxlbmd0aCBleGNlZWRlZDogJyArIGJ1ZmZlcnNbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1heEFjdHVhbCA9IE1hdGgubWF4KG1heEFjdHVhbCwgbGVuKVxuICAgIH1cbiAgICAvLyBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgdGhlIGVhcmxpZXN0IHBvc3NpYmxlIGJ1ZmZlciBvdmVycnVuLlxuICAgIHZhciBtID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIIC0gbWF4QWN0dWFsXG4gICAgcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24gPSBtICsgcGFyc2VyLnBvc2l0aW9uXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckJ1ZmZlcnMgKHBhcnNlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcnNlcltidWZmZXJzW2ldXSA9ICcnXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hCdWZmZXJzIChwYXJzZXIpIHtcbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIGlmIChwYXJzZXIuY2RhdGEgIT09ICcnKSB7XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNkYXRhJywgcGFyc2VyLmNkYXRhKVxuICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICB9XG4gICAgaWYgKHBhcnNlci5zY3JpcHQgIT09ICcnKSB7XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICB9XG4gIH1cblxuICBTQVhQYXJzZXIucHJvdG90eXBlID0ge1xuICAgIGVuZDogZnVuY3Rpb24gKCkgeyBlbmQodGhpcykgfSxcbiAgICB3cml0ZTogd3JpdGUsXG4gICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7IHRoaXMuZXJyb3IgPSBudWxsOyByZXR1cm4gdGhpcyB9LFxuICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLndyaXRlKG51bGwpIH0sXG4gICAgZmx1c2g6IGZ1bmN0aW9uICgpIHsgZmx1c2hCdWZmZXJzKHRoaXMpIH1cbiAgfVxuXG4gIHZhciBTdHJlYW1cbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBTdHJlYW0gPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgdmFyIHN0cmVhbVdyYXBzID0gc2F4LkVWRU5UUy5maWx0ZXIoZnVuY3Rpb24gKGV2KSB7XG4gICAgcmV0dXJuIGV2ICE9PSAnZXJyb3InICYmIGV2ICE9PSAnZW5kJ1xuICB9KVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSAoc3RyaWN0LCBvcHQpIHtcbiAgICByZXR1cm4gbmV3IFNBWFN0cmVhbShzdHJpY3QsIG9wdClcbiAgfVxuXG4gIGZ1bmN0aW9uIFNBWFN0cmVhbSAoc3RyaWN0LCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYU3RyZWFtKSkge1xuICAgICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpXG4gICAgfVxuXG4gICAgU3RyZWFtLmFwcGx5KHRoaXMpXG5cbiAgICB0aGlzLl9wYXJzZXIgPSBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KVxuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlXG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWVcblxuICAgIHZhciBtZSA9IHRoaXNcblxuICAgIHRoaXMuX3BhcnNlci5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLmVtaXQoJ2VuZCcpXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyc2VyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIG1lLmVtaXQoJ2Vycm9yJywgZXIpXG5cbiAgICAgIC8vIGlmIGRpZG4ndCB0aHJvdywgdGhlbiBtZWFucyBlcnJvciB3YXMgaGFuZGxlZC5cbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBjbGVhciBlcnJvciwgc28gd2UgY2FuIHdyaXRlIGFnYWluLlxuICAgICAgbWUuX3BhcnNlci5lcnJvciA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuXG4gICAgc3RyZWFtV3JhcHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ29uJyArIGV2LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBtZS5fcGFyc2VyWydvbicgKyBldl1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgIGlmICghaCkge1xuICAgICAgICAgICAgbWUucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KVxuICAgICAgICAgICAgbWUuX3BhcnNlclsnb24nICsgZXZdID0gaFxuICAgICAgICAgICAgcmV0dXJuIGhcbiAgICAgICAgICB9XG4gICAgICAgICAgbWUub24oZXYsIGgpXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0cmVhbS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IFNBWFN0cmVhbVxuICAgIH1cbiAgfSlcblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcbiAgICAgICAgdmFyIFNEID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG4gICAgICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU0QoJ3V0ZjgnKVxuICAgICAgfVxuICAgICAgZGF0YSA9IHRoaXMuX2RlY29kZXIud3JpdGUoZGF0YSlcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJzZXIud3JpdGUoZGF0YS50b1N0cmluZygpKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgdGhpcy53cml0ZShjaHVuaylcbiAgICB9XG4gICAgdGhpcy5fcGFyc2VyLmVuZCgpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGhhbmRsZXIpIHtcbiAgICB2YXIgbWUgPSB0aGlzXG4gICAgaWYgKCFtZS5fcGFyc2VyWydvbicgKyBldl0gJiYgc3RyZWFtV3JhcHMuaW5kZXhPZihldikgIT09IC0xKSB7XG4gICAgICBtZS5fcGFyc2VyWydvbicgKyBldl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IFthcmd1bWVudHNbMF1dIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICBhcmdzLnNwbGljZSgwLCAwLCBldilcbiAgICAgICAgbWUuZW1pdC5hcHBseShtZSwgYXJncylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKG1lLCBldiwgaGFuZGxlcilcbiAgfVxuXG4gIC8vIHRoaXMgcmVhbGx5IG5lZWRzIHRvIGJlIHJlcGxhY2VkIHdpdGggY2hhcmFjdGVyIGNsYXNzZXMuXG4gIC8vIFhNTCBhbGxvd3MgYWxsIG1hbm5lciBvZiByaWRpY3Vsb3VzIG51bWJlcnMgYW5kIGRpZ2l0cy5cbiAgdmFyIENEQVRBID0gJ1tDREFUQVsnXG4gIHZhciBET0NUWVBFID0gJ0RPQ1RZUEUnXG4gIHZhciBYTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbiAgdmFyIFhNTE5TX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcbiAgdmFyIHJvb3ROUyA9IHsgeG1sOiBYTUxfTkFNRVNQQUNFLCB4bWxuczogWE1MTlNfTkFNRVNQQUNFIH1cblxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lU3RhcnRDaGFyXG4gIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gd29ya3Mgb24gc3RyaW5ncywgYSBzaW5nbGUgY2hhcmFjdGVyIGF0IGEgdGltZVxuICAvLyBhcyBzdWNoLCBpdCBjYW5ub3QgZXZlciBzdXBwb3J0IGFzdHJhbC1wbGFuZSBjaGFyYWN0ZXJzICgxMDAwMC1FRkZGRilcbiAgLy8gd2l0aG91dCBhIHNpZ25pZmljYW50IGJyZWFraW5nIGNoYW5nZSB0byBlaXRoZXIgdGhpcyAgcGFyc2VyLCBvciB0aGVcbiAgLy8gSmF2YVNjcmlwdCBsYW5ndWFnZS4gIEltcGxlbWVudGF0aW9uIG9mIGFuIGVtb2ppLWNhcGFibGUgeG1sIHBhcnNlclxuICAvLyBpcyBsZWZ0IGFzIGFuIGV4ZXJjaXNlIGZvciB0aGUgcmVhZGVyLlxuICB2YXIgbmFtZVN0YXJ0ID0gL1s6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF0vXG5cbiAgdmFyIG5hbWVCb2R5ID0gL1s6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDAuXFxkLV0vXG5cbiAgdmFyIGVudGl0eVN0YXJ0ID0gL1sjOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuICB2YXIgZW50aXR5Qm9keSA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MC5cXGQtXS9cblxuICBmdW5jdGlvbiBpc1doaXRlc3BhY2UgKGMpIHtcbiAgICByZXR1cm4gYyA9PT0gJyAnIHx8IGMgPT09ICdcXG4nIHx8IGMgPT09ICdcXHInIHx8IGMgPT09ICdcXHQnXG4gIH1cblxuICBmdW5jdGlvbiBpc1F1b3RlIChjKSB7XG4gICAgcmV0dXJuIGMgPT09ICdcIicgfHwgYyA9PT0gJ1xcJydcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXR0cmliRW5kIChjKSB7XG4gICAgcmV0dXJuIGMgPT09ICc+JyB8fCBpc1doaXRlc3BhY2UoYylcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTWF0Y2ggKHJlZ2V4LCBjKSB7XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QoYylcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdE1hdGNoIChyZWdleCwgYykge1xuICAgIHJldHVybiAhaXNNYXRjaChyZWdleCwgYylcbiAgfVxuXG4gIHZhciBTID0gMFxuICBzYXguU1RBVEUgPSB7XG4gICAgQkVHSU46IFMrKywgLy8gbGVhZGluZyBieXRlIG9yZGVyIG1hcmsgb3Igd2hpdGVzcGFjZVxuICAgIEJFR0lOX1dISVRFU1BBQ0U6IFMrKywgLy8gbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgVEVYVDogUysrLCAvLyBnZW5lcmFsIHN0dWZmXG4gICAgVEVYVF9FTlRJVFk6IFMrKywgLy8gJmFtcCBhbmQgc3VjaC5cbiAgICBPUEVOX1dBS0E6IFMrKywgLy8gPFxuICAgIFNHTUxfREVDTDogUysrLCAvLyA8IUJMQVJHXG4gICAgU0dNTF9ERUNMX1FVT1RFRDogUysrLCAvLyA8IUJMQVJHIGZvbyBcImJhclxuICAgIERPQ1RZUEU6IFMrKywgLy8gPCFET0NUWVBFXG4gICAgRE9DVFlQRV9RVU9URUQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXG4gICAgRE9DVFlQRV9EVEQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXCIgWyAuLi5cbiAgICBET0NUWVBFX0RURF9RVU9URUQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXCIgWyBcImZvb1xuICAgIENPTU1FTlRfU1RBUlRJTkc6IFMrKywgLy8gPCEtXG4gICAgQ09NTUVOVDogUysrLCAvLyA8IS0tXG4gICAgQ09NTUVOVF9FTkRJTkc6IFMrKywgLy8gPCEtLSBibGFoIC1cbiAgICBDT01NRU5UX0VOREVEOiBTKyssIC8vIDwhLS0gYmxhaCAtLVxuICAgIENEQVRBOiBTKyssIC8vIDwhW0NEQVRBWyBzb21ldGhpbmdcbiAgICBDREFUQV9FTkRJTkc6IFMrKywgLy8gXVxuICAgIENEQVRBX0VORElOR18yOiBTKyssIC8vIF1dXG4gICAgUFJPQ19JTlNUOiBTKyssIC8vIDw/aGlcbiAgICBQUk9DX0lOU1RfQk9EWTogUysrLCAvLyA8P2hpIHRoZXJlXG4gICAgUFJPQ19JTlNUX0VORElORzogUysrLCAvLyA8P2hpIFwidGhlcmVcIiA/XG4gICAgT1BFTl9UQUc6IFMrKywgLy8gPHN0cm9uZ1xuICAgIE9QRU5fVEFHX1NMQVNIOiBTKyssIC8vIDxzdHJvbmcgL1xuICAgIEFUVFJJQjogUysrLCAvLyA8YVxuICAgIEFUVFJJQl9OQU1FOiBTKyssIC8vIDxhIGZvb1xuICAgIEFUVFJJQl9OQU1FX1NBV19XSElURTogUysrLCAvLyA8YSBmb28gX1xuICAgIEFUVFJJQl9WQUxVRTogUysrLCAvLyA8YSBmb289XG4gICAgQVRUUklCX1ZBTFVFX1FVT1RFRDogUysrLCAvLyA8YSBmb289XCJiYXJcbiAgICBBVFRSSUJfVkFMVUVfQ0xPU0VEOiBTKyssIC8vIDxhIGZvbz1cImJhclwiXG4gICAgQVRUUklCX1ZBTFVFX1VOUVVPVEVEOiBTKyssIC8vIDxhIGZvbz1iYXJcbiAgICBBVFRSSUJfVkFMVUVfRU5USVRZX1E6IFMrKywgLy8gPGZvbyBiYXI9XCImcXVvdDtcIlxuICAgIEFUVFJJQl9WQUxVRV9FTlRJVFlfVTogUysrLCAvLyA8Zm9vIGJhcj0mcXVvdFxuICAgIENMT1NFX1RBRzogUysrLCAvLyA8L2FcbiAgICBDTE9TRV9UQUdfU0FXX1dISVRFOiBTKyssIC8vIDwvYSAgID5cbiAgICBTQ1JJUFQ6IFMrKywgLy8gPHNjcmlwdD4gLi4uXG4gICAgU0NSSVBUX0VORElORzogUysrIC8vIDxzY3JpcHQ+IC4uLiA8XG4gIH1cblxuICBzYXguWE1MX0VOVElUSUVTID0ge1xuICAgICdhbXAnOiAnJicsXG4gICAgJ2d0JzogJz4nLFxuICAgICdsdCc6ICc8JyxcbiAgICAncXVvdCc6ICdcIicsXG4gICAgJ2Fwb3MnOiBcIidcIlxuICB9XG5cbiAgc2F4LkVOVElUSUVTID0ge1xuICAgICdhbXAnOiAnJicsXG4gICAgJ2d0JzogJz4nLFxuICAgICdsdCc6ICc8JyxcbiAgICAncXVvdCc6ICdcIicsXG4gICAgJ2Fwb3MnOiBcIidcIixcbiAgICAnQUVsaWcnOiAxOTgsXG4gICAgJ0FhY3V0ZSc6IDE5MyxcbiAgICAnQWNpcmMnOiAxOTQsXG4gICAgJ0FncmF2ZSc6IDE5MixcbiAgICAnQXJpbmcnOiAxOTcsXG4gICAgJ0F0aWxkZSc6IDE5NSxcbiAgICAnQXVtbCc6IDE5NixcbiAgICAnQ2NlZGlsJzogMTk5LFxuICAgICdFVEgnOiAyMDgsXG4gICAgJ0VhY3V0ZSc6IDIwMSxcbiAgICAnRWNpcmMnOiAyMDIsXG4gICAgJ0VncmF2ZSc6IDIwMCxcbiAgICAnRXVtbCc6IDIwMyxcbiAgICAnSWFjdXRlJzogMjA1LFxuICAgICdJY2lyYyc6IDIwNixcbiAgICAnSWdyYXZlJzogMjA0LFxuICAgICdJdW1sJzogMjA3LFxuICAgICdOdGlsZGUnOiAyMDksXG4gICAgJ09hY3V0ZSc6IDIxMSxcbiAgICAnT2NpcmMnOiAyMTIsXG4gICAgJ09ncmF2ZSc6IDIxMCxcbiAgICAnT3NsYXNoJzogMjE2LFxuICAgICdPdGlsZGUnOiAyMTMsXG4gICAgJ091bWwnOiAyMTQsXG4gICAgJ1RIT1JOJzogMjIyLFxuICAgICdVYWN1dGUnOiAyMTgsXG4gICAgJ1VjaXJjJzogMjE5LFxuICAgICdVZ3JhdmUnOiAyMTcsXG4gICAgJ1V1bWwnOiAyMjAsXG4gICAgJ1lhY3V0ZSc6IDIyMSxcbiAgICAnYWFjdXRlJzogMjI1LFxuICAgICdhY2lyYyc6IDIyNixcbiAgICAnYWVsaWcnOiAyMzAsXG4gICAgJ2FncmF2ZSc6IDIyNCxcbiAgICAnYXJpbmcnOiAyMjksXG4gICAgJ2F0aWxkZSc6IDIyNyxcbiAgICAnYXVtbCc6IDIyOCxcbiAgICAnY2NlZGlsJzogMjMxLFxuICAgICdlYWN1dGUnOiAyMzMsXG4gICAgJ2VjaXJjJzogMjM0LFxuICAgICdlZ3JhdmUnOiAyMzIsXG4gICAgJ2V0aCc6IDI0MCxcbiAgICAnZXVtbCc6IDIzNSxcbiAgICAnaWFjdXRlJzogMjM3LFxuICAgICdpY2lyYyc6IDIzOCxcbiAgICAnaWdyYXZlJzogMjM2LFxuICAgICdpdW1sJzogMjM5LFxuICAgICdudGlsZGUnOiAyNDEsXG4gICAgJ29hY3V0ZSc6IDI0MyxcbiAgICAnb2NpcmMnOiAyNDQsXG4gICAgJ29ncmF2ZSc6IDI0MixcbiAgICAnb3NsYXNoJzogMjQ4LFxuICAgICdvdGlsZGUnOiAyNDUsXG4gICAgJ291bWwnOiAyNDYsXG4gICAgJ3N6bGlnJzogMjIzLFxuICAgICd0aG9ybic6IDI1NCxcbiAgICAndWFjdXRlJzogMjUwLFxuICAgICd1Y2lyYyc6IDI1MSxcbiAgICAndWdyYXZlJzogMjQ5LFxuICAgICd1dW1sJzogMjUyLFxuICAgICd5YWN1dGUnOiAyNTMsXG4gICAgJ3l1bWwnOiAyNTUsXG4gICAgJ2NvcHknOiAxNjksXG4gICAgJ3JlZyc6IDE3NCxcbiAgICAnbmJzcCc6IDE2MCxcbiAgICAnaWV4Y2wnOiAxNjEsXG4gICAgJ2NlbnQnOiAxNjIsXG4gICAgJ3BvdW5kJzogMTYzLFxuICAgICdjdXJyZW4nOiAxNjQsXG4gICAgJ3llbic6IDE2NSxcbiAgICAnYnJ2YmFyJzogMTY2LFxuICAgICdzZWN0JzogMTY3LFxuICAgICd1bWwnOiAxNjgsXG4gICAgJ29yZGYnOiAxNzAsXG4gICAgJ2xhcXVvJzogMTcxLFxuICAgICdub3QnOiAxNzIsXG4gICAgJ3NoeSc6IDE3MyxcbiAgICAnbWFjcic6IDE3NSxcbiAgICAnZGVnJzogMTc2LFxuICAgICdwbHVzbW4nOiAxNzcsXG4gICAgJ3N1cDEnOiAxODUsXG4gICAgJ3N1cDInOiAxNzgsXG4gICAgJ3N1cDMnOiAxNzksXG4gICAgJ2FjdXRlJzogMTgwLFxuICAgICdtaWNybyc6IDE4MSxcbiAgICAncGFyYSc6IDE4MixcbiAgICAnbWlkZG90JzogMTgzLFxuICAgICdjZWRpbCc6IDE4NCxcbiAgICAnb3JkbSc6IDE4NixcbiAgICAncmFxdW8nOiAxODcsXG4gICAgJ2ZyYWMxNCc6IDE4OCxcbiAgICAnZnJhYzEyJzogMTg5LFxuICAgICdmcmFjMzQnOiAxOTAsXG4gICAgJ2lxdWVzdCc6IDE5MSxcbiAgICAndGltZXMnOiAyMTUsXG4gICAgJ2RpdmlkZSc6IDI0NyxcbiAgICAnT0VsaWcnOiAzMzgsXG4gICAgJ29lbGlnJzogMzM5LFxuICAgICdTY2Fyb24nOiAzNTIsXG4gICAgJ3NjYXJvbic6IDM1MyxcbiAgICAnWXVtbCc6IDM3NixcbiAgICAnZm5vZic6IDQwMixcbiAgICAnY2lyYyc6IDcxMCxcbiAgICAndGlsZGUnOiA3MzIsXG4gICAgJ0FscGhhJzogOTEzLFxuICAgICdCZXRhJzogOTE0LFxuICAgICdHYW1tYSc6IDkxNSxcbiAgICAnRGVsdGEnOiA5MTYsXG4gICAgJ0Vwc2lsb24nOiA5MTcsXG4gICAgJ1pldGEnOiA5MTgsXG4gICAgJ0V0YSc6IDkxOSxcbiAgICAnVGhldGEnOiA5MjAsXG4gICAgJ0lvdGEnOiA5MjEsXG4gICAgJ0thcHBhJzogOTIyLFxuICAgICdMYW1iZGEnOiA5MjMsXG4gICAgJ011JzogOTI0LFxuICAgICdOdSc6IDkyNSxcbiAgICAnWGknOiA5MjYsXG4gICAgJ09taWNyb24nOiA5MjcsXG4gICAgJ1BpJzogOTI4LFxuICAgICdSaG8nOiA5MjksXG4gICAgJ1NpZ21hJzogOTMxLFxuICAgICdUYXUnOiA5MzIsXG4gICAgJ1Vwc2lsb24nOiA5MzMsXG4gICAgJ1BoaSc6IDkzNCxcbiAgICAnQ2hpJzogOTM1LFxuICAgICdQc2knOiA5MzYsXG4gICAgJ09tZWdhJzogOTM3LFxuICAgICdhbHBoYSc6IDk0NSxcbiAgICAnYmV0YSc6IDk0NixcbiAgICAnZ2FtbWEnOiA5NDcsXG4gICAgJ2RlbHRhJzogOTQ4LFxuICAgICdlcHNpbG9uJzogOTQ5LFxuICAgICd6ZXRhJzogOTUwLFxuICAgICdldGEnOiA5NTEsXG4gICAgJ3RoZXRhJzogOTUyLFxuICAgICdpb3RhJzogOTUzLFxuICAgICdrYXBwYSc6IDk1NCxcbiAgICAnbGFtYmRhJzogOTU1LFxuICAgICdtdSc6IDk1NixcbiAgICAnbnUnOiA5NTcsXG4gICAgJ3hpJzogOTU4LFxuICAgICdvbWljcm9uJzogOTU5LFxuICAgICdwaSc6IDk2MCxcbiAgICAncmhvJzogOTYxLFxuICAgICdzaWdtYWYnOiA5NjIsXG4gICAgJ3NpZ21hJzogOTYzLFxuICAgICd0YXUnOiA5NjQsXG4gICAgJ3Vwc2lsb24nOiA5NjUsXG4gICAgJ3BoaSc6IDk2NixcbiAgICAnY2hpJzogOTY3LFxuICAgICdwc2knOiA5NjgsXG4gICAgJ29tZWdhJzogOTY5LFxuICAgICd0aGV0YXN5bSc6IDk3NyxcbiAgICAndXBzaWgnOiA5NzgsXG4gICAgJ3Bpdic6IDk4MixcbiAgICAnZW5zcCc6IDgxOTQsXG4gICAgJ2Vtc3AnOiA4MTk1LFxuICAgICd0aGluc3AnOiA4MjAxLFxuICAgICd6d25qJzogODIwNCxcbiAgICAnendqJzogODIwNSxcbiAgICAnbHJtJzogODIwNixcbiAgICAncmxtJzogODIwNyxcbiAgICAnbmRhc2gnOiA4MjExLFxuICAgICdtZGFzaCc6IDgyMTIsXG4gICAgJ2xzcXVvJzogODIxNixcbiAgICAncnNxdW8nOiA4MjE3LFxuICAgICdzYnF1byc6IDgyMTgsXG4gICAgJ2xkcXVvJzogODIyMCxcbiAgICAncmRxdW8nOiA4MjIxLFxuICAgICdiZHF1byc6IDgyMjIsXG4gICAgJ2RhZ2dlcic6IDgyMjQsXG4gICAgJ0RhZ2dlcic6IDgyMjUsXG4gICAgJ2J1bGwnOiA4MjI2LFxuICAgICdoZWxsaXAnOiA4MjMwLFxuICAgICdwZXJtaWwnOiA4MjQwLFxuICAgICdwcmltZSc6IDgyNDIsXG4gICAgJ1ByaW1lJzogODI0MyxcbiAgICAnbHNhcXVvJzogODI0OSxcbiAgICAncnNhcXVvJzogODI1MCxcbiAgICAnb2xpbmUnOiA4MjU0LFxuICAgICdmcmFzbCc6IDgyNjAsXG4gICAgJ2V1cm8nOiA4MzY0LFxuICAgICdpbWFnZSc6IDg0NjUsXG4gICAgJ3dlaWVycCc6IDg0NzIsXG4gICAgJ3JlYWwnOiA4NDc2LFxuICAgICd0cmFkZSc6IDg0ODIsXG4gICAgJ2FsZWZzeW0nOiA4NTAxLFxuICAgICdsYXJyJzogODU5MixcbiAgICAndWFycic6IDg1OTMsXG4gICAgJ3JhcnInOiA4NTk0LFxuICAgICdkYXJyJzogODU5NSxcbiAgICAnaGFycic6IDg1OTYsXG4gICAgJ2NyYXJyJzogODYyOSxcbiAgICAnbEFycic6IDg2NTYsXG4gICAgJ3VBcnInOiA4NjU3LFxuICAgICdyQXJyJzogODY1OCxcbiAgICAnZEFycic6IDg2NTksXG4gICAgJ2hBcnInOiA4NjYwLFxuICAgICdmb3JhbGwnOiA4NzA0LFxuICAgICdwYXJ0JzogODcwNixcbiAgICAnZXhpc3QnOiA4NzA3LFxuICAgICdlbXB0eSc6IDg3MDksXG4gICAgJ25hYmxhJzogODcxMSxcbiAgICAnaXNpbic6IDg3MTIsXG4gICAgJ25vdGluJzogODcxMyxcbiAgICAnbmknOiA4NzE1LFxuICAgICdwcm9kJzogODcxOSxcbiAgICAnc3VtJzogODcyMSxcbiAgICAnbWludXMnOiA4NzIyLFxuICAgICdsb3dhc3QnOiA4NzI3LFxuICAgICdyYWRpYyc6IDg3MzAsXG4gICAgJ3Byb3AnOiA4NzMzLFxuICAgICdpbmZpbic6IDg3MzQsXG4gICAgJ2FuZyc6IDg3MzYsXG4gICAgJ2FuZCc6IDg3NDMsXG4gICAgJ29yJzogODc0NCxcbiAgICAnY2FwJzogODc0NSxcbiAgICAnY3VwJzogODc0NixcbiAgICAnaW50JzogODc0NyxcbiAgICAndGhlcmU0JzogODc1NixcbiAgICAnc2ltJzogODc2NCxcbiAgICAnY29uZyc6IDg3NzMsXG4gICAgJ2FzeW1wJzogODc3NixcbiAgICAnbmUnOiA4ODAwLFxuICAgICdlcXVpdic6IDg4MDEsXG4gICAgJ2xlJzogODgwNCxcbiAgICAnZ2UnOiA4ODA1LFxuICAgICdzdWInOiA4ODM0LFxuICAgICdzdXAnOiA4ODM1LFxuICAgICduc3ViJzogODgzNixcbiAgICAnc3ViZSc6IDg4MzgsXG4gICAgJ3N1cGUnOiA4ODM5LFxuICAgICdvcGx1cyc6IDg4NTMsXG4gICAgJ290aW1lcyc6IDg4NTUsXG4gICAgJ3BlcnAnOiA4ODY5LFxuICAgICdzZG90JzogODkwMSxcbiAgICAnbGNlaWwnOiA4OTY4LFxuICAgICdyY2VpbCc6IDg5NjksXG4gICAgJ2xmbG9vcic6IDg5NzAsXG4gICAgJ3JmbG9vcic6IDg5NzEsXG4gICAgJ2xhbmcnOiA5MDAxLFxuICAgICdyYW5nJzogOTAwMixcbiAgICAnbG96JzogOTY3NCxcbiAgICAnc3BhZGVzJzogOTgyNCxcbiAgICAnY2x1YnMnOiA5ODI3LFxuICAgICdoZWFydHMnOiA5ODI5LFxuICAgICdkaWFtcyc6IDk4MzBcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNheC5FTlRJVElFUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGUgPSBzYXguRU5USVRJRVNba2V5XVxuICAgIHZhciBzID0gdHlwZW9mIGUgPT09ICdudW1iZXInID8gU3RyaW5nLmZyb21DaGFyQ29kZShlKSA6IGVcbiAgICBzYXguRU5USVRJRVNba2V5XSA9IHNcbiAgfSlcblxuICBmb3IgKHZhciBzIGluIHNheC5TVEFURSkge1xuICAgIHNheC5TVEFURVtzYXguU1RBVEVbc11dID0gc1xuICB9XG5cbiAgLy8gc2hvcnRoYW5kXG4gIFMgPSBzYXguU1RBVEVcblxuICBmdW5jdGlvbiBlbWl0IChwYXJzZXIsIGV2ZW50LCBkYXRhKSB7XG4gICAgcGFyc2VyW2V2ZW50XSAmJiBwYXJzZXJbZXZlbnRdKGRhdGEpXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0Tm9kZSAocGFyc2VyLCBub2RlVHlwZSwgZGF0YSkge1xuICAgIGlmIChwYXJzZXIudGV4dE5vZGUpIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgZW1pdChwYXJzZXIsIG5vZGVUeXBlLCBkYXRhKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VUZXh0IChwYXJzZXIpIHtcbiAgICBwYXJzZXIudGV4dE5vZGUgPSB0ZXh0b3B0cyhwYXJzZXIub3B0LCBwYXJzZXIudGV4dE5vZGUpXG4gICAgaWYgKHBhcnNlci50ZXh0Tm9kZSkgZW1pdChwYXJzZXIsICdvbnRleHQnLCBwYXJzZXIudGV4dE5vZGUpXG4gICAgcGFyc2VyLnRleHROb2RlID0gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRvcHRzIChvcHQsIHRleHQpIHtcbiAgICBpZiAob3B0LnRyaW0pIHRleHQgPSB0ZXh0LnRyaW0oKVxuICAgIGlmIChvcHQubm9ybWFsaXplKSB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHMrL2csICcgJylcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IgKHBhcnNlciwgZXIpIHtcbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgZXIgKz0gJ1xcbkxpbmU6ICcgKyBwYXJzZXIubGluZSArXG4gICAgICAgICdcXG5Db2x1bW46ICcgKyBwYXJzZXIuY29sdW1uICtcbiAgICAgICAgJ1xcbkNoYXI6ICcgKyBwYXJzZXIuY1xuICAgIH1cbiAgICBlciA9IG5ldyBFcnJvcihlcilcbiAgICBwYXJzZXIuZXJyb3IgPSBlclxuICAgIGVtaXQocGFyc2VyLCAnb25lcnJvcicsIGVyKVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZCAocGFyc2VyKSB7XG4gICAgaWYgKHBhcnNlci5zYXdSb290ICYmICFwYXJzZXIuY2xvc2VkUm9vdCkgc3RyaWN0RmFpbChwYXJzZXIsICdVbmNsb3NlZCByb290IHRhZycpXG4gICAgaWYgKChwYXJzZXIuc3RhdGUgIT09IFMuQkVHSU4pICYmXG4gICAgICAocGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOX1dISVRFU1BBQ0UpICYmXG4gICAgICAocGFyc2VyLnN0YXRlICE9PSBTLlRFWFQpKSB7XG4gICAgICBlcnJvcihwYXJzZXIsICdVbmV4cGVjdGVkIGVuZCcpXG4gICAgfVxuICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgcGFyc2VyLmMgPSAnJ1xuICAgIHBhcnNlci5jbG9zZWQgPSB0cnVlXG4gICAgZW1pdChwYXJzZXIsICdvbmVuZCcpXG4gICAgU0FYUGFyc2VyLmNhbGwocGFyc2VyLCBwYXJzZXIuc3RyaWN0LCBwYXJzZXIub3B0KVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmljdEZhaWwgKHBhcnNlciwgbWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgcGFyc2VyICE9PSAnb2JqZWN0JyB8fCAhKHBhcnNlciBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGNhbGwgdG8gc3RyaWN0RmFpbCcpXG4gICAgfVxuICAgIGlmIChwYXJzZXIuc3RyaWN0KSB7XG4gICAgICBlcnJvcihwYXJzZXIsIG1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmV3VGFnIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLnRhZ05hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICB2YXIgdGFnID0gcGFyc2VyLnRhZyA9IHsgbmFtZTogcGFyc2VyLnRhZ05hbWUsIGF0dHJpYnV0ZXM6IHt9IH1cblxuICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlbiBpZiB0YWcgY29udGFpbHMgYW4geG1sbnM9XCJmb29cIiBvciB4bWxuczpmb289XCJiYXJcIlxuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICB0YWcubnMgPSBwYXJlbnQubnNcbiAgICB9XG4gICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3BlbnRhZ3N0YXJ0JywgdGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gcW5hbWUgKG5hbWUsIGF0dHJpYnV0ZSkge1xuICAgIHZhciBpID0gbmFtZS5pbmRleE9mKCc6JylcbiAgICB2YXIgcXVhbE5hbWUgPSBpIDwgMCA/IFsgJycsIG5hbWUgXSA6IG5hbWUuc3BsaXQoJzonKVxuICAgIHZhciBwcmVmaXggPSBxdWFsTmFtZVswXVxuICAgIHZhciBsb2NhbCA9IHF1YWxOYW1lWzFdXG5cbiAgICAvLyA8eCBcInhtbG5zXCI9XCJodHRwOi8vZm9vXCI+XG4gICAgaWYgKGF0dHJpYnV0ZSAmJiBuYW1lID09PSAneG1sbnMnKSB7XG4gICAgICBwcmVmaXggPSAneG1sbnMnXG4gICAgICBsb2NhbCA9ICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcHJlZml4OiBwcmVmaXgsIGxvY2FsOiBsb2NhbCB9XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyaWIgKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLnN0cmljdCkge1xuICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5hdHRyaWJMaXN0LmluZGV4T2YocGFyc2VyLmF0dHJpYk5hbWUpICE9PSAtMSB8fFxuICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHBhcnNlci5hdHRyaWJOYW1lKSkge1xuICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHZhciBxbiA9IHFuYW1lKHBhcnNlci5hdHRyaWJOYW1lLCB0cnVlKVxuICAgICAgdmFyIHByZWZpeCA9IHFuLnByZWZpeFxuICAgICAgdmFyIGxvY2FsID0gcW4ubG9jYWxcblxuICAgICAgaWYgKHByZWZpeCA9PT0gJ3htbG5zJykge1xuICAgICAgICAvLyBuYW1lc3BhY2UgYmluZGluZyBhdHRyaWJ1dGUuIHB1c2ggdGhlIGJpbmRpbmcgaW50byBzY29wZVxuICAgICAgICBpZiAobG9jYWwgPT09ICd4bWwnICYmIHBhcnNlci5hdHRyaWJWYWx1ZSAhPT0gWE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgJ3htbDogcHJlZml4IG11c3QgYmUgYm91bmQgdG8gJyArIFhNTF9OQU1FU1BBQ0UgKyAnXFxuJyArXG4gICAgICAgICAgICAnQWN0dWFsOiAnICsgcGFyc2VyLmF0dHJpYlZhbHVlKVxuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsID09PSAneG1sbnMnICYmIHBhcnNlci5hdHRyaWJWYWx1ZSAhPT0gWE1MTlNfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAneG1sbnM6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvICcgKyBYTUxOU19OQU1FU1BBQ0UgKyAnXFxuJyArXG4gICAgICAgICAgICAnQWN0dWFsOiAnICsgcGFyc2VyLmF0dHJpYlZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnXG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgICAgICAgIGlmICh0YWcubnMgPT09IHBhcmVudC5ucykge1xuICAgICAgICAgICAgdGFnLm5zID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQubnMpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhZy5uc1tsb2NhbF0gPSBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkZWZlciBvbmF0dHJpYnV0ZSBldmVudHMgdW50aWwgYWxsIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIHNlZW5cbiAgICAgIC8vIHNvIGFueSBuZXcgYmluZGluZ3MgY2FuIHRha2UgZWZmZWN0LiBwcmVzZXJ2ZSBhdHRyaWJ1dGUgb3JkZXJcbiAgICAgIC8vIHNvIGRlZmVycmVkIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBpbiBkb2N1bWVudCBvcmRlclxuICAgICAgcGFyc2VyLmF0dHJpYkxpc3QucHVzaChbcGFyc2VyLmF0dHJpYk5hbWUsIHBhcnNlci5hdHRyaWJWYWx1ZV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIG5vbi14bWxucyBtb2RlLCB3ZSBjYW4gZW1pdCB0aGUgZXZlbnQgcmlnaHQgYXdheVxuICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCB7XG4gICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICB2YWx1ZTogcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW5UYWcgKHBhcnNlciwgc2VsZkNsb3NpbmcpIHtcbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgLy8gZW1pdCBuYW1lc3BhY2UgYmluZGluZyBldmVudHNcbiAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnXG5cbiAgICAgIC8vIGFkZCBuYW1lc3BhY2UgaW5mbyB0byB0YWdcbiAgICAgIHZhciBxbiA9IHFuYW1lKHBhcnNlci50YWdOYW1lKVxuICAgICAgdGFnLnByZWZpeCA9IHFuLnByZWZpeFxuICAgICAgdGFnLmxvY2FsID0gcW4ubG9jYWxcbiAgICAgIHRhZy51cmkgPSB0YWcubnNbcW4ucHJlZml4XSB8fCAnJ1xuXG4gICAgICBpZiAodGFnLnByZWZpeCAmJiAhdGFnLnVyaSkge1xuICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuYm91bmQgbmFtZXNwYWNlIHByZWZpeDogJyArXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGFyc2VyLnRhZ05hbWUpKVxuICAgICAgICB0YWcudXJpID0gcW4ucHJlZml4XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgIGlmICh0YWcubnMgJiYgcGFyZW50Lm5zICE9PSB0YWcubnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGFnLm5zKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVubmFtZXNwYWNlJywge1xuICAgICAgICAgICAgcHJlZml4OiBwLFxuICAgICAgICAgICAgdXJpOiB0YWcubnNbcF1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgZGVmZXJyZWQgb25hdHRyaWJ1dGUgZXZlbnRzXG4gICAgICAvLyBOb3RlOiBkbyBub3QgYXBwbHkgZGVmYXVsdCBucyB0byBhdHRyaWJ1dGVzOlxuICAgICAgLy8gICBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLW5hbWVzLyNkZWZhdWx0aW5nXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbnYgPSBwYXJzZXIuYXR0cmliTGlzdFtpXVxuICAgICAgICB2YXIgbmFtZSA9IG52WzBdXG4gICAgICAgIHZhciB2YWx1ZSA9IG52WzFdXG4gICAgICAgIHZhciBxdWFsTmFtZSA9IHFuYW1lKG5hbWUsIHRydWUpXG4gICAgICAgIHZhciBwcmVmaXggPSBxdWFsTmFtZS5wcmVmaXhcbiAgICAgICAgdmFyIGxvY2FsID0gcXVhbE5hbWUubG9jYWxcbiAgICAgICAgdmFyIHVyaSA9IHByZWZpeCA9PT0gJycgPyAnJyA6ICh0YWcubnNbcHJlZml4XSB8fCAnJylcbiAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgbG9jYWw6IGxvY2FsLFxuICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSdzIGFueSBhdHRyaWJ1dGVzIHdpdGggYW4gdW5kZWZpbmVkIG5hbWVzcGFjZSxcbiAgICAgICAgLy8gdGhlbiBmYWlsIG9uIHRoZW0gbm93LlxuICAgICAgICBpZiAocHJlZml4ICYmIHByZWZpeCAhPT0gJ3htbG5zJyAmJiAhdXJpKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6ICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocHJlZml4KSlcbiAgICAgICAgICBhLnVyaSA9IHByZWZpeFxuICAgICAgICB9XG4gICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1tuYW1lXSA9IGFcbiAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCBhKVxuICAgICAgfVxuICAgICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIH1cblxuICAgIHBhcnNlci50YWcuaXNTZWxmQ2xvc2luZyA9ICEhc2VsZkNsb3NpbmdcblxuICAgIC8vIHByb2Nlc3MgdGhlIHRhZ1xuICAgIHBhcnNlci5zYXdSb290ID0gdHJ1ZVxuICAgIHBhcnNlci50YWdzLnB1c2gocGFyc2VyLnRhZylcbiAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW50YWcnLCBwYXJzZXIudGFnKVxuICAgIGlmICghc2VsZkNsb3NpbmcpIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgPHNjcmlwdD4gaW4gbm9uLXN0cmljdCBtb2RlLlxuICAgICAgaWYgKCFwYXJzZXIubm9zY3JpcHQgJiYgcGFyc2VyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgfVxuICAgICAgcGFyc2VyLnRhZyA9IG51bGxcbiAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICB9XG4gICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlVGFnIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1dlaXJkIGVtcHR5IGNsb3NlIHRhZy4nKVxuICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8Lz4nXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICBpZiAocGFyc2VyLnRhZ05hbWUgIT09ICdzY3JpcHQnKSB7XG4gICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lICsgJz4nXG4gICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICB9XG5cbiAgICAvLyBmaXJzdCBtYWtlIHN1cmUgdGhhdCB0aGUgY2xvc2luZyB0YWcgYWN0dWFsbHkgZXhpc3RzLlxuICAgIC8vIDxhPjxiPjwvYz48L2I+PC9hPiB3aWxsIGNsb3NlIGV2ZXJ5dGhpbmcsIG90aGVyd2lzZS5cbiAgICB2YXIgdCA9IHBhcnNlci50YWdzLmxlbmd0aFxuICAgIHZhciB0YWdOYW1lID0gcGFyc2VyLnRhZ05hbWVcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgIHRhZ05hbWUgPSB0YWdOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB9XG4gICAgdmFyIGNsb3NlVG8gPSB0YWdOYW1lXG4gICAgd2hpbGUgKHQtLSkge1xuICAgICAgdmFyIGNsb3NlID0gcGFyc2VyLnRhZ3NbdF1cbiAgICAgIGlmIChjbG9zZS5uYW1lICE9PSBjbG9zZVRvKSB7XG4gICAgICAgIC8vIGZhaWwgdGhlIGZpcnN0IHRpbWUgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmV4cGVjdGVkIGNsb3NlIHRhZycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRpZG4ndCBmaW5kIGl0LiAgd2UgYWxyZWFkeSBmYWlsZWQgZm9yIHN0cmljdCwgc28ganVzdCBhYm9ydC5cbiAgICBpZiAodCA8IDApIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5tYXRjaGVkIGNsb3NpbmcgdGFnOiAnICsgcGFyc2VyLnRhZ05hbWUpXG4gICAgICBwYXJzZXIudGV4dE5vZGUgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lICsgJz4nXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBwYXJzZXIudGFnTmFtZSA9IHRhZ05hbWVcbiAgICB2YXIgcyA9IHBhcnNlci50YWdzLmxlbmd0aFxuICAgIHdoaWxlIChzLS0gPiB0KSB7XG4gICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZyA9IHBhcnNlci50YWdzLnBvcCgpXG4gICAgICBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWcubmFtZVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZXRhZycsIHBhcnNlci50YWdOYW1lKVxuXG4gICAgICB2YXIgeCA9IHt9XG4gICAgICBmb3IgKHZhciBpIGluIHRhZy5ucykge1xuICAgICAgICB4W2ldID0gdGFnLm5zW2ldXG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgIGlmIChwYXJzZXIub3B0LnhtbG5zICYmIHRhZy5ucyAhPT0gcGFyZW50Lm5zKSB7XG4gICAgICAgIC8vIHJlbW92ZSBuYW1lc3BhY2UgYmluZGluZ3MgaW50cm9kdWNlZCBieSB0YWdcbiAgICAgICAgT2JqZWN0LmtleXModGFnLm5zKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgdmFyIG4gPSB0YWcubnNbcF1cbiAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNsb3NlbmFtZXNwYWNlJywgeyBwcmVmaXg6IHAsIHVyaTogbiB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodCA9PT0gMCkgcGFyc2VyLmNsb3NlZFJvb3QgPSB0cnVlXG4gICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZSA9ICcnXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbnRpdHkgKHBhcnNlcikge1xuICAgIHZhciBlbnRpdHkgPSBwYXJzZXIuZW50aXR5XG4gICAgdmFyIGVudGl0eUxDID0gZW50aXR5LnRvTG93ZXJDYXNlKClcbiAgICB2YXIgbnVtXG4gICAgdmFyIG51bVN0ciA9ICcnXG5cbiAgICBpZiAocGFyc2VyLkVOVElUSUVTW2VudGl0eV0pIHtcbiAgICAgIHJldHVybiBwYXJzZXIuRU5USVRJRVNbZW50aXR5XVxuICAgIH1cbiAgICBpZiAocGFyc2VyLkVOVElUSUVTW2VudGl0eUxDXSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ11cbiAgICB9XG4gICAgZW50aXR5ID0gZW50aXR5TENcbiAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICBpZiAoZW50aXR5LmNoYXJBdCgxKSA9PT0gJ3gnKSB7XG4gICAgICAgIGVudGl0eSA9IGVudGl0eS5zbGljZSgyKVxuICAgICAgICBudW0gPSBwYXJzZUludChlbnRpdHksIDE2KVxuICAgICAgICBudW1TdHIgPSBudW0udG9TdHJpbmcoMTYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMSlcbiAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LCAxMClcbiAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDEwKVxuICAgICAgfVxuICAgIH1cbiAgICBlbnRpdHkgPSBlbnRpdHkucmVwbGFjZSgvXjArLywgJycpXG4gICAgaWYgKGlzTmFOKG51bSkgfHwgbnVtU3RyLnRvTG93ZXJDYXNlKCkgIT09IGVudGl0eSkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBlbnRpdHknKVxuICAgICAgcmV0dXJuICcmJyArIHBhcnNlci5lbnRpdHkgKyAnOydcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQobnVtKVxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5XaGl0ZVNwYWNlIChwYXJzZXIsIGMpIHtcbiAgICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fV0FLQVxuICAgICAgcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIucG9zaXRpb25cbiAgICB9IGVsc2UgaWYgKCFpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgIC8vIGhhdmUgdG8gcHJvY2VzcyB0aGlzIGFzIGEgdGV4dCBub2RlLlxuICAgICAgLy8gd2VpcmQsIGJ1dCBoYXBwZW5zLlxuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdOb24td2hpdGVzcGFjZSBiZWZvcmUgZmlyc3QgdGFnLicpXG4gICAgICBwYXJzZXIudGV4dE5vZGUgPSBjXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGFyQXQgKGNodW5rLCBpKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnXG4gICAgaWYgKGkgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGNodW5rLmNoYXJBdChpKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZSAoY2h1bmspIHtcbiAgICB2YXIgcGFyc2VyID0gdGhpc1xuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLmVycm9yXG4gICAgfVxuICAgIGlmIChwYXJzZXIuY2xvc2VkKSB7XG4gICAgICByZXR1cm4gZXJyb3IocGFyc2VyLFxuICAgICAgICAnQ2Fubm90IHdyaXRlIGFmdGVyIGNsb3NlLiBBc3NpZ24gYW4gb25yZWFkeSBoYW5kbGVyLicpXG4gICAgfVxuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVuZChwYXJzZXIpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdvYmplY3QnKSB7XG4gICAgICBjaHVuayA9IGNodW5rLnRvU3RyaW5nKClcbiAgICB9XG4gICAgdmFyIGkgPSAwXG4gICAgdmFyIGMgPSAnJ1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjID0gY2hhckF0KGNodW5rLCBpKyspXG4gICAgICBwYXJzZXIuYyA9IGNcblxuICAgICAgaWYgKCFjKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICBwYXJzZXIucG9zaXRpb24rK1xuICAgICAgICBpZiAoYyA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBwYXJzZXIubGluZSsrXG4gICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZXIuY29sdW1uKytcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHBhcnNlci5zdGF0ZSkge1xuICAgICAgICBjYXNlIFMuQkVHSU46XG4gICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTl9XSElURVNQQUNFXG4gICAgICAgICAgaWYgKGMgPT09ICdcXHVGRUZGJykge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYmVnaW5XaGl0ZVNwYWNlKHBhcnNlciwgYylcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5CRUdJTl9XSElURVNQQUNFOlxuICAgICAgICAgIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuVEVYVDpcbiAgICAgICAgICBpZiAocGFyc2VyLnNhd1Jvb3QgJiYgIXBhcnNlci5jbG9zZWRSb290KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRpID0gaSAtIDFcbiAgICAgICAgICAgIHdoaWxlIChjICYmIGMgIT09ICc8JyAmJiBjICE9PSAnJicpIHtcbiAgICAgICAgICAgICAgYyA9IGNoYXJBdChjaHVuaywgaSsrKVxuICAgICAgICAgICAgICBpZiAoYyAmJiBwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5wb3NpdGlvbisrXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIubGluZSsrXG4gICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uID0gMFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uKytcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBjaHVuay5zdWJzdHJpbmcoc3RhcnRpLCBpIC0gMSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGMgPT09ICc8JyAmJiAhKHBhcnNlci5zYXdSb290ICYmIHBhcnNlci5jbG9zZWRSb290ICYmICFwYXJzZXIuc3RyaWN0KSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0FcbiAgICAgICAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpICYmICghcGFyc2VyLnNhd1Jvb3QgfHwgcGFyc2VyLmNsb3NlZFJvb3QpKSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVGV4dCBkYXRhIG91dHNpZGUgb2Ygcm9vdCBub2RlLicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVF9FTlRJVFlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNDUklQVDpcbiAgICAgICAgICAvLyBvbmx5IG5vbi1zdHJpY3RcbiAgICAgICAgICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNDUklQVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPCcgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1dBS0E6XG4gICAgICAgICAgLy8gZWl0aGVyIGEgLywgPywgISwgb3IgdGV4dCBpcyBjb21pbmcgbmV4dC5cbiAgICAgICAgICBpZiAoYyA9PT0gJyEnKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTFxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgaXQuLi5cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBjXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUXG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lID0gcGFyc2VyLnByb2NJbnN0Qm9keSA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5lbmNvZGVkIDwnKVxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2FzIHNvbWUgd2hpdGVzcGFjZSwgdGhlbiBhZGQgdGhhdCBpbi5cbiAgICAgICAgICAgIGlmIChwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiArIDEgPCBwYXJzZXIucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IHBhcnNlci5wb3NpdGlvbiAtIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uXG4gICAgICAgICAgICAgIGMgPSBuZXcgQXJyYXkocGFkKS5qb2luKCcgJykgKyBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gJzwnICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNHTUxfREVDTDpcbiAgICAgICAgICBpZiAoKHBhcnNlci5zZ21sRGVjbCArIGMpLnRvVXBwZXJDYXNlKCkgPT09IENEQVRBKSB7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW5jZGF0YScpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlci5zZ21sRGVjbCArIGMgPT09ICctLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBET0NUWVBFKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVcbiAgICAgICAgICAgIGlmIChwYXJzZXIuZG9jdHlwZSB8fCBwYXJzZXIuc2F3Um9vdCkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlcixcbiAgICAgICAgICAgICAgICAnSW5hcHByb3ByaWF0ZWx5IGxvY2F0ZWQgZG9jdHlwZSBkZWNsYXJhdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNnbWxkZWNsYXJhdGlvbicsIHBhcnNlci5zZ21sRGVjbClcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMX1FVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0dNTF9ERUNMX1FVT1RFRDpcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMXG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uZG9jdHlwZScsIHBhcnNlci5kb2N0eXBlKVxuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSB0cnVlIC8vIGp1c3QgcmVtZW1iZXIgdGhhdCB3ZSBzYXcgaXQuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICAgIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9RVU9URURcbiAgICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEVfUVVPVEVEOlxuICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfRFREX1FVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEVfRFREX1FVT1RFRDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfRFREXG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNPTU1FTlQ6XG4gICAgICAgICAgaWYgKGMgPT09ICctJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UX0VORElOR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNPTU1FTlRfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRFRFxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSB0ZXh0b3B0cyhwYXJzZXIub3B0LCBwYXJzZXIuY29tbWVudClcbiAgICAgICAgICAgIGlmIChwYXJzZXIuY29tbWVudCkge1xuICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNvbW1lbnQnLCBwYXJzZXIuY29tbWVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gJydcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gJy0nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNPTU1FTlRfRU5ERUQ6XG4gICAgICAgICAgaWYgKGMgIT09ICc+Jykge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdNYWxmb3JtZWQgY29tbWVudCcpXG4gICAgICAgICAgICAvLyBhbGxvdyA8IS0tIGJsYWggLS0gYmxvbyAtLT4gaW4gbm9uLXN0cmljdCBtb2RlLFxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgYSBjb21tZW50IG9mIFwiIGJsYWggLS0gYmxvbyBcIlxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gJy0tJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0RBVEE6XG4gICAgICAgICAgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQV9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0RBVEFfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFfRU5ESU5HXzJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0RBVEFfRU5ESU5HXzI6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgaWYgKHBhcnNlci5jZGF0YSkge1xuICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNkYXRhJywgcGFyc2VyLmNkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZWNkYXRhJylcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gJ11dJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUOlxuICAgICAgICAgIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0VORElOR1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1RfQk9EWTpcbiAgICAgICAgICBpZiAoIXBhcnNlci5wcm9jSW5zdEJvZHkgJiYgaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24nLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5wcm9jSW5zdE5hbWUsXG4gICAgICAgICAgICAgIGJvZHk6IHBhcnNlci5wcm9jSW5zdEJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lID0gcGFyc2VyLnByb2NJbnN0Qm9keSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSAnPycgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLk9QRU5fVEFHOlxuICAgICAgICAgIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdUYWcocGFyc2VyKVxuICAgICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBpbiB0YWcgbmFtZScpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9UQUdfU0xBU0g6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIsIHRydWUpXG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnRm9yd2FyZC1zbGFzaCBpbiBvcGVuaW5nIHRhZyBub3QgZm9sbG93ZWQgYnkgPicpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUI6XG4gICAgICAgICAgLy8gaGF2ZW4ndCByZWFkIHRoZSBhdHRyaWJ1dGUgbmFtZSB5ZXQuXG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0F0dHJpYnV0ZSB3aXRob3V0IHZhbHVlJylcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IHBhcnNlci5hdHRyaWJOYW1lXG4gICAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVfU0FXX1dISVRFXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRV9TQVdfV0hJVEU6XG4gICAgICAgICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdBdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbcGFyc2VyLmF0dHJpYk5hbWVdID0gJydcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmF0dHJpYnV0ZScsIHtcbiAgICAgICAgICAgICAgbmFtZTogcGFyc2VyLmF0dHJpYk5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gJydcbiAgICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFOlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1FVT1RFRFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfUVVPVEVEOlxuICAgICAgICAgIGlmIChjICE9PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0NMT1NFRFxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9DTE9TRUQ6XG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdObyB3aGl0ZXNwYWNlIGJldHdlZW4gYXR0cmlidXRlcycpXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRDpcbiAgICAgICAgICBpZiAoIWlzQXR0cmliRW5kKGMpKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgKz0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmliKHBhcnNlcilcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHOlxuICAgICAgICAgIGlmICghcGFyc2VyLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm90TWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIGNcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnLicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWVcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHX1NBV19XSElURVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DTE9TRV9UQUdfU0FXX1dISVRFOlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlcnMgaW4gY2xvc2luZyB0YWcnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5URVhUX0VOVElUWTpcbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVTpcbiAgICAgICAgICB2YXIgcmV0dXJuU3RhdGVcbiAgICAgICAgICB2YXIgYnVmZmVyXG4gICAgICAgICAgc3dpdGNoIChwYXJzZXIuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgUy5URVhUX0VOVElUWTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ3RleHROb2RlJ1xuICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9ROlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1FVT1RFRFxuICAgICAgICAgICAgICBidWZmZXIgPSAnYXR0cmliVmFsdWUnXG4gICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5BVFRSSUJfVkFMVUVfVU5RVU9URURcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ2F0dHJpYlZhbHVlJ1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjID09PSAnOycpIHtcbiAgICAgICAgICAgIHBhcnNlcltidWZmZXJdICs9IHBhcnNlRW50aXR5KHBhcnNlcilcbiAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gcmV0dXJuU3RhdGVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gocGFyc2VyLmVudGl0eS5sZW5ndGggPyBlbnRpdHlCb2R5IDogZW50aXR5U3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBpbiBlbnRpdHkgbmFtZScpXG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSAnJicgKyBwYXJzZXIuZW50aXR5ICsgY1xuICAgICAgICAgICAgcGFyc2VyLmVudGl0eSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSByZXR1cm5TdGF0ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VyLCAnVW5rbm93biBzdGF0ZTogJyArIHBhcnNlci5zdGF0ZSlcbiAgICAgIH1cbiAgICB9IC8vIHdoaWxlXG5cbiAgICBpZiAocGFyc2VyLnBvc2l0aW9uID49IHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uKSB7XG4gICAgICBjaGVja0J1ZmZlckxlbmd0aChwYXJzZXIpXG4gICAgfVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIC8qISBodHRwOi8vbXRocy5iZS9mcm9tY29kZXBvaW50IHYwLjEuMCBieSBAbWF0aGlhcyAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIVN0cmluZy5mcm9tQ29kZVBvaW50KSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yXG4gICAgICB2YXIgZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIE1BWF9TSVpFID0gMHg0MDAwXG4gICAgICAgIHZhciBjb2RlVW5pdHMgPSBbXVxuICAgICAgICB2YXIgaGlnaFN1cnJvZ2F0ZVxuICAgICAgICB2YXIgbG93U3Vycm9nYXRlXG4gICAgICAgIHZhciBpbmRleCA9IC0xXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgICAgICAgIGNvZGVQb2ludCA8IDAgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICBjb2RlUG9pbnQgPiAweDEwRkZGRiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGZsb29yKGNvZGVQb2ludCkgIT09IGNvZGVQb2ludCAvLyBub3QgYW4gaW50ZWdlclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCBjb2RlIHBvaW50OiAnICsgY29kZVBvaW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4RkZGRikgeyAvLyBCTVAgY29kZSBwb2ludFxuICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goY29kZVBvaW50KVxuICAgICAgICAgIH0gZWxzZSB7IC8vIEFzdHJhbCBjb2RlIHBvaW50OyBzcGxpdCBpbiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgICAgICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgICAgICAgIGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIDB4RDgwMFxuICAgICAgICAgICAgbG93U3Vycm9nYXRlID0gKGNvZGVQb2ludCAlIDB4NDAwKSArIDB4REMwMFxuICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZXggKyAxID09PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVVbml0cylcbiAgICAgICAgICAgIGNvZGVVbml0cy5sZW5ndGggPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcsICdmcm9tQ29kZVBvaW50Jywge1xuICAgICAgICAgIHZhbHVlOiBmcm9tQ29kZVBvaW50LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgU3RyaW5nLmZyb21Db2RlUG9pbnQgPSBmcm9tQ29kZVBvaW50XG4gICAgICB9XG4gICAgfSgpKVxuICB9XG59KSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNheCA9IHt9IDogZXhwb3J0cylcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwidmFyIENsaWVudFJlcXVlc3QgPSByZXF1aXJlKCcuL2xpYi9yZXF1ZXN0JylcbnZhciByZXNwb25zZSA9IHJlcXVpcmUoJy4vbGliL3Jlc3BvbnNlJylcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgc3RhdHVzQ29kZXMgPSByZXF1aXJlKCdidWlsdGluLXN0YXR1cy1jb2RlcycpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcblxudmFyIGh0dHAgPSBleHBvcnRzXG5cbmh0dHAucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRzLCBjYikge1xuXHRpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKVxuXHRcdG9wdHMgPSB1cmwucGFyc2Uob3B0cylcblx0ZWxzZVxuXHRcdG9wdHMgPSBleHRlbmQob3B0cylcblxuXHQvLyBOb3JtYWxseSwgdGhlIHBhZ2UgaXMgbG9hZGVkIGZyb20gaHR0cCBvciBodHRwcywgc28gbm90IHNwZWNpZnlpbmcgYSBwcm90b2NvbFxuXHQvLyB3aWxsIHJlc3VsdCBpbiBhICh2YWxpZCkgcHJvdG9jb2wtcmVsYXRpdmUgdXJsLiBIb3dldmVyLCB0aGlzIHdvbid0IHdvcmsgaWZcblx0Ly8gdGhlIHByb3RvY29sIGlzIHNvbWV0aGluZyBlbHNlLCBsaWtlICdmaWxlOidcblx0dmFyIGRlZmF1bHRQcm90b2NvbCA9IGdsb2JhbC5sb2NhdGlvbi5wcm90b2NvbC5zZWFyY2goL15odHRwcz86JC8pID09PSAtMSA/ICdodHRwOicgOiAnJ1xuXG5cdHZhciBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2wgfHwgZGVmYXVsdFByb3RvY29sXG5cdHZhciBob3N0ID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3Rcblx0dmFyIHBvcnQgPSBvcHRzLnBvcnRcblx0dmFyIHBhdGggPSBvcHRzLnBhdGggfHwgJy8nXG5cblx0Ly8gTmVjZXNzYXJ5IGZvciBJUHY2IGFkZHJlc3Nlc1xuXHRpZiAoaG9zdCAmJiBob3N0LmluZGV4T2YoJzonKSAhPT0gLTEpXG5cdFx0aG9zdCA9ICdbJyArIGhvc3QgKyAnXSdcblxuXHQvLyBUaGlzIG1heSBiZSBhIHJlbGF0aXZlIHVybC4gVGhlIGJyb3dzZXIgc2hvdWxkIGFsd2F5cyBiZSBhYmxlIHRvIGludGVycHJldCBpdCBjb3JyZWN0bHkuXG5cdG9wdHMudXJsID0gKGhvc3QgPyAocHJvdG9jb2wgKyAnLy8nICsgaG9zdCkgOiAnJykgKyAocG9ydCA/ICc6JyArIHBvcnQgOiAnJykgKyBwYXRoXG5cdG9wdHMubWV0aG9kID0gKG9wdHMubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpXG5cdG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fVxuXG5cdC8vIEFsc28gdmFsaWQgb3B0cy5hdXRoLCBvcHRzLm1vZGVcblxuXHR2YXIgcmVxID0gbmV3IENsaWVudFJlcXVlc3Qob3B0cylcblx0aWYgKGNiKVxuXHRcdHJlcS5vbigncmVzcG9uc2UnLCBjYilcblx0cmV0dXJuIHJlcVxufVxuXG5odHRwLmdldCA9IGZ1bmN0aW9uIGdldCAob3B0cywgY2IpIHtcblx0dmFyIHJlcSA9IGh0dHAucmVxdWVzdChvcHRzLCBjYilcblx0cmVxLmVuZCgpXG5cdHJldHVybiByZXFcbn1cblxuaHR0cC5DbGllbnRSZXF1ZXN0ID0gQ2xpZW50UmVxdWVzdFxuaHR0cC5JbmNvbWluZ01lc3NhZ2UgPSByZXNwb25zZS5JbmNvbWluZ01lc3NhZ2VcblxuaHR0cC5BZ2VudCA9IGZ1bmN0aW9uICgpIHt9XG5odHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNFxuXG5odHRwLmdsb2JhbEFnZW50ID0gbmV3IGh0dHAuQWdlbnQoKVxuXG5odHRwLlNUQVRVU19DT0RFUyA9IHN0YXR1c0NvZGVzXG5cbmh0dHAuTUVUSE9EUyA9IFtcblx0J0NIRUNLT1VUJyxcblx0J0NPTk5FQ1QnLFxuXHQnQ09QWScsXG5cdCdERUxFVEUnLFxuXHQnR0VUJyxcblx0J0hFQUQnLFxuXHQnTE9DSycsXG5cdCdNLVNFQVJDSCcsXG5cdCdNRVJHRScsXG5cdCdNS0FDVElWSVRZJyxcblx0J01LQ09MJyxcblx0J01PVkUnLFxuXHQnTk9USUZZJyxcblx0J09QVElPTlMnLFxuXHQnUEFUQ0gnLFxuXHQnUE9TVCcsXG5cdCdQUk9QRklORCcsXG5cdCdQUk9QUEFUQ0gnLFxuXHQnUFVSR0UnLFxuXHQnUFVUJyxcblx0J1JFUE9SVCcsXG5cdCdTRUFSQ0gnLFxuXHQnU1VCU0NSSUJFJyxcblx0J1RSQUNFJyxcblx0J1VOTE9DSycsXG5cdCdVTlNVQlNDUklCRSdcbl0iLCJleHBvcnRzLmZldGNoID0gaXNGdW5jdGlvbihnbG9iYWwuZmV0Y2gpICYmIGlzRnVuY3Rpb24oZ2xvYmFsLlJlYWRhYmxlU3RyZWFtKVxuXG5leHBvcnRzLndyaXRhYmxlU3RyZWFtID0gaXNGdW5jdGlvbihnbG9iYWwuV3JpdGFibGVTdHJlYW0pXG5cbmV4cG9ydHMuYWJvcnRDb250cm9sbGVyID0gaXNGdW5jdGlvbihnbG9iYWwuQWJvcnRDb250cm9sbGVyKVxuXG5leHBvcnRzLmJsb2JDb25zdHJ1Y3RvciA9IGZhbHNlXG50cnkge1xuXHRuZXcgQmxvYihbbmV3IEFycmF5QnVmZmVyKDEpXSlcblx0ZXhwb3J0cy5ibG9iQ29uc3RydWN0b3IgPSB0cnVlXG59IGNhdGNoIChlKSB7fVxuXG4vLyBUaGUgeGhyIHJlcXVlc3QgdG8gZXhhbXBsZS5jb20gbWF5IHZpb2xhdGUgc29tZSByZXN0cmljdGl2ZSBDU1AgY29uZmlndXJhdGlvbnMsXG4vLyBzbyBpZiB3ZSdyZSBydW5uaW5nIGluIGEgYnJvd3NlciB0aGF0IHN1cHBvcnRzIGBmZXRjaGAsIGF2b2lkIGNhbGxpbmcgZ2V0WEhSKClcbi8vIGFuZCBhc3N1bWUgc3VwcG9ydCBmb3IgY2VydGFpbiBmZWF0dXJlcyBiZWxvdy5cbnZhciB4aHJcbmZ1bmN0aW9uIGdldFhIUiAoKSB7XG5cdC8vIENhY2hlIHRoZSB4aHIgdmFsdWVcblx0aWYgKHhociAhPT0gdW5kZWZpbmVkKSByZXR1cm4geGhyXG5cblx0aWYgKGdsb2JhbC5YTUxIdHRwUmVxdWVzdCkge1xuXHRcdHhociA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKVxuXHRcdC8vIElmIFhEb21haW5SZXF1ZXN0IGlzIGF2YWlsYWJsZSAoaWUgb25seSwgd2hlcmUgeGhyIG1pZ2h0IG5vdCB3b3JrXG5cdFx0Ly8gY3Jvc3MgZG9tYWluKSwgdXNlIHRoZSBwYWdlIGxvY2F0aW9uLiBPdGhlcndpc2UgdXNlIGV4YW1wbGUuY29tXG5cdFx0Ly8gTm90ZTogdGhpcyBkb2Vzbid0IGFjdHVhbGx5IG1ha2UgYW4gaHR0cCByZXF1ZXN0LlxuXHRcdHRyeSB7XG5cdFx0XHR4aHIub3BlbignR0VUJywgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ID8gJy8nIDogJ2h0dHBzOi8vZXhhbXBsZS5jb20nKVxuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0eGhyID0gbnVsbFxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBTZXJ2aWNlIHdvcmtlcnMgZG9uJ3QgaGF2ZSBYSFJcblx0XHR4aHIgPSBudWxsXG5cdH1cblx0cmV0dXJuIHhoclxufVxuXG5mdW5jdGlvbiBjaGVja1R5cGVTdXBwb3J0ICh0eXBlKSB7XG5cdHZhciB4aHIgPSBnZXRYSFIoKVxuXHRpZiAoIXhocikgcmV0dXJuIGZhbHNlXG5cdHRyeSB7XG5cdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHR5cGVcblx0XHRyZXR1cm4geGhyLnJlc3BvbnNlVHlwZSA9PT0gdHlwZVxuXHR9IGNhdGNoIChlKSB7fVxuXHRyZXR1cm4gZmFsc2Vcbn1cblxuLy8gRm9yIHNvbWUgc3RyYW5nZSByZWFzb24sIFNhZmFyaSA3LjAgcmVwb3J0cyB0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnb2JqZWN0Jy5cbi8vIFNhZmFyaSA3LjEgYXBwZWFycyB0byBoYXZlIGZpeGVkIHRoaXMgYnVnLlxudmFyIGhhdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnXG52YXIgaGF2ZVNsaWNlID0gaGF2ZUFycmF5QnVmZmVyICYmIGlzRnVuY3Rpb24oZ2xvYmFsLkFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSlcblxuLy8gSWYgZmV0Y2ggaXMgc3VwcG9ydGVkLCB0aGVuIGFycmF5YnVmZmVyIHdpbGwgYmUgc3VwcG9ydGVkIHRvby4gU2tpcCBjYWxsaW5nXG4vLyBjaGVja1R5cGVTdXBwb3J0KCksIHNpbmNlIHRoYXQgY2FsbHMgZ2V0WEhSKCkuXG5leHBvcnRzLmFycmF5YnVmZmVyID0gZXhwb3J0cy5mZXRjaCB8fCAoaGF2ZUFycmF5QnVmZmVyICYmIGNoZWNrVHlwZVN1cHBvcnQoJ2FycmF5YnVmZmVyJykpXG5cbi8vIFRoZXNlIG5leHQgdHdvIHRlc3RzIHVuYXZvaWRhYmx5IHNob3cgd2FybmluZ3MgaW4gQ2hyb21lLiBTaW5jZSBmZXRjaCB3aWxsIGFsd2F5c1xuLy8gYmUgdXNlZCBpZiBpdCdzIGF2YWlsYWJsZSwganVzdCByZXR1cm4gZmFsc2UgZm9yIHRoZXNlIHRvIGF2b2lkIHRoZSB3YXJuaW5ncy5cbmV4cG9ydHMubXNzdHJlYW0gPSAhZXhwb3J0cy5mZXRjaCAmJiBoYXZlU2xpY2UgJiYgY2hlY2tUeXBlU3VwcG9ydCgnbXMtc3RyZWFtJylcbmV4cG9ydHMubW96Y2h1bmtlZGFycmF5YnVmZmVyID0gIWV4cG9ydHMuZmV0Y2ggJiYgaGF2ZUFycmF5QnVmZmVyICYmXG5cdGNoZWNrVHlwZVN1cHBvcnQoJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJylcblxuLy8gSWYgZmV0Y2ggaXMgc3VwcG9ydGVkLCB0aGVuIG92ZXJyaWRlTWltZVR5cGUgd2lsbCBiZSBzdXBwb3J0ZWQgdG9vLiBTa2lwIGNhbGxpbmdcbi8vIGdldFhIUigpLlxuZXhwb3J0cy5vdmVycmlkZU1pbWVUeXBlID0gZXhwb3J0cy5mZXRjaCB8fCAoZ2V0WEhSKCkgPyBpc0Z1bmN0aW9uKGdldFhIUigpLm92ZXJyaWRlTWltZVR5cGUpIDogZmFsc2UpXG5cbmV4cG9ydHMudmJBcnJheSA9IGlzRnVuY3Rpb24oZ2xvYmFsLlZCQXJyYXkpXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbn1cblxueGhyID0gbnVsbCAvLyBIZWxwIGdjXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgcmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIHRvQXJyYXlCdWZmZXIgPSByZXF1aXJlKCd0by1hcnJheWJ1ZmZlcicpXG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSByZXNwb25zZS5JbmNvbWluZ01lc3NhZ2VcbnZhciByU3RhdGVzID0gcmVzcG9uc2UucmVhZHlTdGF0ZXNcblxuZnVuY3Rpb24gZGVjaWRlTW9kZSAocHJlZmVyQmluYXJ5LCB1c2VGZXRjaCkge1xuXHRpZiAoY2FwYWJpbGl0eS5mZXRjaCAmJiB1c2VGZXRjaCkge1xuXHRcdHJldHVybiAnZmV0Y2gnXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5tb3pjaHVua2VkYXJyYXlidWZmZXIpIHtcblx0XHRyZXR1cm4gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubXNzdHJlYW0pIHtcblx0XHRyZXR1cm4gJ21zLXN0cmVhbSdcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5LmFycmF5YnVmZmVyICYmIHByZWZlckJpbmFyeSkge1xuXHRcdHJldHVybiAnYXJyYXlidWZmZXInXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS52YkFycmF5ICYmIHByZWZlckJpbmFyeSkge1xuXHRcdHJldHVybiAndGV4dDp2YmFycmF5J1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAndGV4dCdcblx0fVxufVxuXG52YXIgQ2xpZW50UmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHN0cmVhbS5Xcml0YWJsZS5jYWxsKHNlbGYpXG5cblx0c2VsZi5fb3B0cyA9IG9wdHNcblx0c2VsZi5fYm9keSA9IFtdXG5cdHNlbGYuX2hlYWRlcnMgPSB7fVxuXHRpZiAob3B0cy5hdXRoKVxuXHRcdHNlbGYuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBuZXcgQnVmZmVyKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpKVxuXHRPYmplY3Qua2V5cyhvcHRzLmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRzZWxmLnNldEhlYWRlcihuYW1lLCBvcHRzLmhlYWRlcnNbbmFtZV0pXG5cdH0pXG5cblx0dmFyIHByZWZlckJpbmFyeVxuXHR2YXIgdXNlRmV0Y2ggPSB0cnVlXG5cdGlmIChvcHRzLm1vZGUgPT09ICdkaXNhYmxlLWZldGNoJyB8fCAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzICYmICFjYXBhYmlsaXR5LmFib3J0Q29udHJvbGxlcikpIHtcblx0XHQvLyBJZiB0aGUgdXNlIG9mIFhIUiBzaG91bGQgYmUgcHJlZmVycmVkLiBOb3QgdHlwaWNhbGx5IG5lZWRlZC5cblx0XHR1c2VGZXRjaCA9IGZhbHNlXG5cdFx0cHJlZmVyQmluYXJ5ID0gdHJ1ZVxuXHR9IGVsc2UgaWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kXG5cdFx0Ly8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0XG5cdFx0cHJlZmVyQmluYXJ5ID0gZmFsc2Vcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdhbGxvdy13cm9uZy1jb250ZW50LXR5cGUnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyXG5cdFx0cHJlZmVyQmluYXJ5ID0gIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZVxuXHR9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7XG5cdFx0Ly8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWRcblx0XHRwcmVmZXJCaW5hcnkgPSB0cnVlXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBvcHRzLm1vZGUnKVxuXHR9XG5cdHNlbGYuX21vZGUgPSBkZWNpZGVNb2RlKHByZWZlckJpbmFyeSwgdXNlRmV0Y2gpXG5cdHNlbGYuX2ZldGNoVGltZXIgPSBudWxsXG5cblx0c2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuXHRcdHNlbGYuX29uRmluaXNoKClcblx0fSlcbn1cblxuaW5oZXJpdHMoQ2xpZW50UmVxdWVzdCwgc3RyZWFtLldyaXRhYmxlKVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHZhciBsb3dlck5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblx0Ly8gVGhpcyBjaGVjayBpcyBub3QgbmVjZXNzYXJ5LCBidXQgaXQgcHJldmVudHMgd2FybmluZ3MgZnJvbSBicm93c2VycyBhYm91dCBzZXR0aW5nIHVuc2FmZVxuXHQvLyBoZWFkZXJzLiBUbyBiZSBob25lc3QgSSdtIG5vdCBlbnRpcmVseSBzdXJlIGhpZGluZyB0aGVzZSB3YXJuaW5ncyBpcyBhIGdvb2QgdGhpbmcsIGJ1dFxuXHQvLyBodHRwLWJyb3dzZXJpZnkgZGlkIGl0LCBzbyBJIHdpbGwgdG9vLlxuXHRpZiAodW5zYWZlSGVhZGVycy5pbmRleE9mKGxvd2VyTmFtZSkgIT09IC0xKVxuXHRcdHJldHVyblxuXG5cdHNlbGYuX2hlYWRlcnNbbG93ZXJOYW1lXSA9IHtcblx0XHRuYW1lOiBuYW1lLFxuXHRcdHZhbHVlOiB2YWx1ZVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBoZWFkZXIgPSB0aGlzLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV1cblx0aWYgKGhlYWRlcilcblx0XHRyZXR1cm4gaGVhZGVyLnZhbHVlXG5cdHJldHVybiBudWxsXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRkZWxldGUgc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblx0dmFyIG9wdHMgPSBzZWxmLl9vcHRzXG5cblx0dmFyIGhlYWRlcnNPYmogPSBzZWxmLl9oZWFkZXJzXG5cdHZhciBib2R5ID0gbnVsbFxuXHRpZiAob3B0cy5tZXRob2QgIT09ICdHRVQnICYmIG9wdHMubWV0aG9kICE9PSAnSEVBRCcpIHtcblx0XHRpZiAoY2FwYWJpbGl0eS5hcnJheWJ1ZmZlcikge1xuXHRcdFx0Ym9keSA9IHRvQXJyYXlCdWZmZXIoQnVmZmVyLmNvbmNhdChzZWxmLl9ib2R5KSlcblx0XHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkuYmxvYkNvbnN0cnVjdG9yKSB7XG5cdFx0XHRib2R5ID0gbmV3IGdsb2JhbC5CbG9iKHNlbGYuX2JvZHkubWFwKGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdFx0cmV0dXJuIHRvQXJyYXlCdWZmZXIoYnVmZmVyKVxuXHRcdFx0fSksIHtcblx0XHRcdFx0dHlwZTogKGhlYWRlcnNPYmpbJ2NvbnRlbnQtdHlwZSddIHx8IHt9KS52YWx1ZSB8fCAnJ1xuXHRcdFx0fSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZ2V0IHV0Zjggc3RyaW5nXG5cdFx0XHRib2R5ID0gQnVmZmVyLmNvbmNhdChzZWxmLl9ib2R5KS50b1N0cmluZygpXG5cdFx0fVxuXHR9XG5cblx0Ly8gY3JlYXRlIGZsYXR0ZW5lZCBsaXN0IG9mIGhlYWRlcnNcblx0dmFyIGhlYWRlcnNMaXN0ID0gW11cblx0T2JqZWN0LmtleXMoaGVhZGVyc09iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5TmFtZSkge1xuXHRcdHZhciBuYW1lID0gaGVhZGVyc09ialtrZXlOYW1lXS5uYW1lXG5cdFx0dmFyIHZhbHVlID0gaGVhZGVyc09ialtrZXlOYW1lXS52YWx1ZVxuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0dmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodikge1xuXHRcdFx0XHRoZWFkZXJzTGlzdC5wdXNoKFtuYW1lLCB2XSlcblx0XHRcdH0pXG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlYWRlcnNMaXN0LnB1c2goW25hbWUsIHZhbHVlXSlcblx0XHR9XG5cdH0pXG5cblx0aWYgKHNlbGYuX21vZGUgPT09ICdmZXRjaCcpIHtcblx0XHR2YXIgc2lnbmFsID0gbnVsbFxuXHRcdHZhciBmZXRjaFRpbWVyID0gbnVsbFxuXHRcdGlmIChjYXBhYmlsaXR5LmFib3J0Q29udHJvbGxlcikge1xuXHRcdFx0dmFyIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblx0XHRcdHNpZ25hbCA9IGNvbnRyb2xsZXIuc2lnbmFsXG5cdFx0XHRzZWxmLl9mZXRjaEFib3J0Q29udHJvbGxlciA9IGNvbnRyb2xsZXJcblxuXHRcdFx0aWYgKCdyZXF1ZXN0VGltZW91dCcgaW4gb3B0cyAmJiBvcHRzLnJlcXVlc3RUaW1lb3V0ICE9PSAwKSB7XG5cdFx0XHRcdHNlbGYuX2ZldGNoVGltZXIgPSBnbG9iYWwuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0c2VsZi5lbWl0KCdyZXF1ZXN0VGltZW91dCcpXG5cdFx0XHRcdFx0aWYgKHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyKVxuXHRcdFx0XHRcdFx0c2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuXHRcdFx0XHR9LCBvcHRzLnJlcXVlc3RUaW1lb3V0KVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdsb2JhbC5mZXRjaChzZWxmLl9vcHRzLnVybCwge1xuXHRcdFx0bWV0aG9kOiBzZWxmLl9vcHRzLm1ldGhvZCxcblx0XHRcdGhlYWRlcnM6IGhlYWRlcnNMaXN0LFxuXHRcdFx0Ym9keTogYm9keSB8fCB1bmRlZmluZWQsXG5cdFx0XHRtb2RlOiAnY29ycycsXG5cdFx0XHRjcmVkZW50aWFsczogb3B0cy53aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnc2FtZS1vcmlnaW4nLFxuXHRcdFx0c2lnbmFsOiBzaWduYWxcblx0XHR9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHRcdFx0c2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cdFx0XHRzZWxmLl9jb25uZWN0KClcblx0XHR9LCBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRnbG9iYWwuY2xlYXJUaW1lb3V0KHNlbGYuX2ZldGNoVGltZXIpXG5cdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIHJlYXNvbilcblx0XHR9KVxuXHR9IGVsc2Uge1xuXHRcdHZhciB4aHIgPSBzZWxmLl94aHIgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KClcblx0XHR0cnkge1xuXHRcdFx0eGhyLm9wZW4oc2VsZi5fb3B0cy5tZXRob2QsIHNlbGYuX29wdHMudXJsLCB0cnVlKVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHR9KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0Ly8gQ2FuJ3Qgc2V0IHJlc3BvbnNlVHlwZSBvbiByZWFsbHkgb2xkIGJyb3dzZXJzXG5cdFx0aWYgKCdyZXNwb25zZVR5cGUnIGluIHhocilcblx0XHRcdHhoci5yZXNwb25zZVR5cGUgPSBzZWxmLl9tb2RlLnNwbGl0KCc6JylbMF1cblxuXHRcdGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpXG5cdFx0XHR4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRzLndpdGhDcmVkZW50aWFsc1xuXG5cdFx0aWYgKHNlbGYuX21vZGUgPT09ICd0ZXh0JyAmJiAnb3ZlcnJpZGVNaW1lVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKVxuXG5cdFx0aWYgKCdyZXF1ZXN0VGltZW91dCcgaW4gb3B0cykge1xuXHRcdFx0eGhyLnRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0XG5cdFx0XHR4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ3JlcXVlc3RUaW1lb3V0Jylcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoZWFkZXJzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuXHRcdH0pXG5cblx0XHRzZWxmLl9yZXNwb25zZSA9IG51bGxcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuTE9BRElORzpcblx0XHRcdFx0Y2FzZSByU3RhdGVzLkRPTkU6XG5cdFx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gTmVjZXNzYXJ5IGZvciBzdHJlYW1pbmcgaW4gRmlyZWZveCwgc2luY2UgeGhyLnJlc3BvbnNlIGlzIE9OTFkgZGVmaW5lZFxuXHRcdC8vIGluIG9ucHJvZ3Jlc3MsIG5vdCBpbiBvbnJlYWR5c3RhdGVjaGFuZ2Ugd2l0aCB4aHIucmVhZHlTdGF0ZSA9IDNcblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJykge1xuXHRcdFx0eGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuX29uWEhSUHJvZ3Jlc3MoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdYSFIgZXJyb3InKSlcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0eGhyLnNlbmQoYm9keSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB4aHIuc3RhdHVzIGlzIHJlYWRhYmxlIGFuZCBub24temVybywgaW5kaWNhdGluZyBubyBlcnJvci5cbiAqIEV2ZW4gdGhvdWdoIHRoZSBzcGVjIHNheXMgaXQgc2hvdWxkIGJlIGF2YWlsYWJsZSBpbiByZWFkeVN0YXRlIDMsXG4gKiBhY2Nlc3NpbmcgaXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpbiBJRThcbiAqL1xuZnVuY3Rpb24gc3RhdHVzVmFsaWQgKHhocikge1xuXHR0cnkge1xuXHRcdHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzXG5cdFx0cmV0dXJuIChzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzICE9PSAwKVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmICghc3RhdHVzVmFsaWQoc2VsZi5feGhyKSB8fCBzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0aWYgKCFzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9jb25uZWN0KClcblxuXHRzZWxmLl9yZXNwb25zZS5fb25YSFJQcm9ncmVzcygpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdHJldHVyblxuXG5cdHNlbGYuX3Jlc3BvbnNlID0gbmV3IEluY29taW5nTWVzc2FnZShzZWxmLl94aHIsIHNlbGYuX2ZldGNoUmVzcG9uc2UsIHNlbGYuX21vZGUsIHNlbGYuX2ZldGNoVGltZXIpXG5cdHNlbGYuX3Jlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuXHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdH0pXG5cblx0c2VsZi5lbWl0KCdyZXNwb25zZScsIHNlbGYuX3Jlc3BvbnNlKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRzZWxmLl9ib2R5LnB1c2goY2h1bmspXG5cdGNiKClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c2VsZi5fZGVzdHJveWVkID0gdHJ1ZVxuXHRnbG9iYWwuY2xlYXJUaW1lb3V0KHNlbGYuX2ZldGNoVGltZXIpXG5cdGlmIChzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9yZXNwb25zZS5fZGVzdHJveWVkID0gdHJ1ZVxuXHRpZiAoc2VsZi5feGhyKVxuXHRcdHNlbGYuX3hoci5hYm9ydCgpXG5cdGVsc2UgaWYgKHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyKVxuXHRcdHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyLmFib3J0KClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2IgPSBkYXRhXG5cdFx0ZGF0YSA9IHVuZGVmaW5lZFxuXHR9XG5cblx0c3RyZWFtLldyaXRhYmxlLnByb3RvdHlwZS5lbmQuY2FsbChzZWxmLCBkYXRhLCBlbmNvZGluZywgY2IpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmZsdXNoSGVhZGVycyA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldE5vRGVsYXkgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0U29ja2V0S2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge31cblxuLy8gVGFrZW4gZnJvbSBodHRwOi8vd3d3LnczLm9yZy9UUi9YTUxIdHRwUmVxdWVzdC8jdGhlLXNldHJlcXVlc3RoZWFkZXIlMjglMjktbWV0aG9kXG52YXIgdW5zYWZlSGVhZGVycyA9IFtcblx0J2FjY2VwdC1jaGFyc2V0Jyxcblx0J2FjY2VwdC1lbmNvZGluZycsXG5cdCdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnLFxuXHQnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnLFxuXHQnY29ubmVjdGlvbicsXG5cdCdjb250ZW50LWxlbmd0aCcsXG5cdCdjb29raWUnLFxuXHQnY29va2llMicsXG5cdCdkYXRlJyxcblx0J2RudCcsXG5cdCdleHBlY3QnLFxuXHQnaG9zdCcsXG5cdCdrZWVwLWFsaXZlJyxcblx0J29yaWdpbicsXG5cdCdyZWZlcmVyJyxcblx0J3RlJyxcblx0J3RyYWlsZXInLFxuXHQndHJhbnNmZXItZW5jb2RpbmcnLFxuXHQndXBncmFkZScsXG5cdCd1c2VyLWFnZW50Jyxcblx0J3ZpYSdcbl1cbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG52YXIgclN0YXRlcyA9IGV4cG9ydHMucmVhZHlTdGF0ZXMgPSB7XG5cdFVOU0VOVDogMCxcblx0T1BFTkVEOiAxLFxuXHRIRUFERVJTX1JFQ0VJVkVEOiAyLFxuXHRMT0FESU5HOiAzLFxuXHRET05FOiA0XG59XG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSBleHBvcnRzLkluY29taW5nTWVzc2FnZSA9IGZ1bmN0aW9uICh4aHIsIHJlc3BvbnNlLCBtb2RlLCBmZXRjaFRpbWVyKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzdHJlYW0uUmVhZGFibGUuY2FsbChzZWxmKVxuXG5cdHNlbGYuX21vZGUgPSBtb2RlXG5cdHNlbGYuaGVhZGVycyA9IHt9XG5cdHNlbGYucmF3SGVhZGVycyA9IFtdXG5cdHNlbGYudHJhaWxlcnMgPSB7fVxuXHRzZWxmLnJhd1RyYWlsZXJzID0gW11cblxuXHQvLyBGYWtlIHRoZSAnY2xvc2UnIGV2ZW50LCBidXQgb25seSBvbmNlICdlbmQnIGZpcmVzXG5cdHNlbGYub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUaGUgbmV4dFRpY2sgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgdGhlICdyZXF1ZXN0JyBtb2R1bGUgZnJvbSBjYXVzaW5nIGFuIGluZmluaXRlIGxvb3Bcblx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdHNlbGYuZW1pdCgnY2xvc2UnKVxuXHRcdH0pXG5cdH0pXG5cblx0aWYgKG1vZGUgPT09ICdmZXRjaCcpIHtcblx0XHRzZWxmLl9mZXRjaFJlc3BvbnNlID0gcmVzcG9uc2VcblxuXHRcdHNlbGYudXJsID0gcmVzcG9uc2UudXJsXG5cdFx0c2VsZi5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzXG5cdFx0c2VsZi5zdGF0dXNNZXNzYWdlID0gcmVzcG9uc2Uuc3RhdHVzVGV4dFxuXHRcdFxuXHRcdHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyLCBrZXkpe1xuXHRcdFx0c2VsZi5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlclxuXHRcdFx0c2VsZi5yYXdIZWFkZXJzLnB1c2goa2V5LCBoZWFkZXIpXG5cdFx0fSlcblxuXHRcdGlmIChjYXBhYmlsaXR5LndyaXRhYmxlU3RyZWFtKSB7XG5cdFx0XHR2YXIgd3JpdGFibGUgPSBuZXcgV3JpdGFibGVTdHJlYW0oe1xuXHRcdFx0XHR3cml0ZTogZnVuY3Rpb24gKGNodW5rKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KClcblx0XHRcdFx0XHRcdH0gZWxzZSBpZihzZWxmLnB1c2gobmV3IEJ1ZmZlcihjaHVuaykpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5fcmVzdW1lRmV0Y2ggPSByZXNvbHZlXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSxcblx0XHRcdFx0Y2xvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRnbG9iYWwuY2xlYXJUaW1lb3V0KGZldGNoVGltZXIpXG5cdFx0XHRcdFx0aWYgKCFzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdFx0fSxcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJlc3BvbnNlLmJvZHkucGlwZVRvKHdyaXRhYmxlKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdFx0Z2xvYmFsLmNsZWFyVGltZW91dChmZXRjaFRpbWVyKVxuXHRcdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0fSlcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9IGNhdGNoIChlKSB7fSAvLyBwaXBlVG8gbWV0aG9kIGlzbid0IGRlZmluZWQuIENhbid0IGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGZlYXR1cmUgdGVzdCB0aGlzXG5cdFx0fVxuXHRcdC8vIGZhbGxiYWNrIGZvciB3aGVuIHdyaXRhYmxlU3RyZWFtIG9yIHBpcGVUbyBhcmVuJ3QgYXZhaWxhYmxlXG5cdFx0dmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKClcblx0XHRmdW5jdGlvbiByZWFkICgpIHtcblx0XHRcdHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdGlmIChyZXN1bHQuZG9uZSkge1xuXHRcdFx0XHRcdGdsb2JhbC5jbGVhclRpbWVvdXQoZmV0Y2hUaW1lcilcblx0XHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihyZXN1bHQudmFsdWUpKVxuXHRcdFx0XHRyZWFkKClcblx0XHRcdH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0Z2xvYmFsLmNsZWFyVGltZW91dChmZXRjaFRpbWVyKVxuXHRcdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0cmVhZCgpXG5cdH0gZWxzZSB7XG5cdFx0c2VsZi5feGhyID0geGhyXG5cdFx0c2VsZi5fcG9zID0gMFxuXG5cdFx0c2VsZi51cmwgPSB4aHIucmVzcG9uc2VVUkxcblx0XHRzZWxmLnN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzXG5cdFx0c2VsZi5zdGF0dXNNZXNzYWdlID0geGhyLnN0YXR1c1RleHRcblx0XHR2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pXG5cdFx0aGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRcdHZhciBtYXRjaGVzID0gaGVhZGVyLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pXG5cdFx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0XHR2YXIga2V5ID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuXHRcdFx0XHRcdGlmIChzZWxmLmhlYWRlcnNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSA9IFtdXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldLnB1c2gobWF0Y2hlc1syXSlcblx0XHRcdFx0fSBlbHNlIGlmIChzZWxmLmhlYWRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0gKz0gJywgJyArIG1hdGNoZXNbMl1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSA9IG1hdGNoZXNbMl1cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnJhd0hlYWRlcnMucHVzaChtYXRjaGVzWzFdLCBtYXRjaGVzWzJdKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRzZWxmLl9jaGFyc2V0ID0gJ3gtdXNlci1kZWZpbmVkJ1xuXHRcdGlmICghY2FwYWJpbGl0eS5vdmVycmlkZU1pbWVUeXBlKSB7XG5cdFx0XHR2YXIgbWltZVR5cGUgPSBzZWxmLnJhd0hlYWRlcnNbJ21pbWUtdHlwZSddXG5cdFx0XHRpZiAobWltZVR5cGUpIHtcblx0XHRcdFx0dmFyIGNoYXJzZXRNYXRjaCA9IG1pbWVUeXBlLm1hdGNoKC87XFxzKmNoYXJzZXQ9KFteO10pKDt8JCkvKVxuXHRcdFx0XHRpZiAoY2hhcnNldE1hdGNoKSB7XG5cdFx0XHRcdFx0c2VsZi5fY2hhcnNldCA9IGNoYXJzZXRNYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghc2VsZi5fY2hhcnNldClcblx0XHRcdFx0c2VsZi5fY2hhcnNldCA9ICd1dGYtOCcgLy8gYmVzdCBndWVzc1xuXHRcdH1cblx0fVxufVxuXG5pbmhlcml0cyhJbmNvbWluZ01lc3NhZ2UsIHN0cmVhbS5SZWFkYWJsZSlcblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHJlc29sdmUgPSBzZWxmLl9yZXN1bWVGZXRjaFxuXHRpZiAocmVzb2x2ZSkge1xuXHRcdHNlbGYuX3Jlc3VtZUZldGNoID0gbnVsbFxuXHRcdHJlc29sdmUoKVxuXHR9XG59XG5cbkluY29taW5nTWVzc2FnZS5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHZhciB4aHIgPSBzZWxmLl94aHJcblxuXHR2YXIgcmVzcG9uc2UgPSBudWxsXG5cdHN3aXRjaCAoc2VsZi5fbW9kZSkge1xuXHRcdGNhc2UgJ3RleHQ6dmJhcnJheSc6IC8vIEZvciBJRTlcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gclN0YXRlcy5ET05FKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gVGhpcyBmYWlscyBpbiBJRThcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgZ2xvYmFsLlZCQXJyYXkoeGhyLnJlc3BvbnNlQm9keSkudG9BcnJheSgpXG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdFx0aWYgKHJlc3BvbnNlICE9PSBudWxsKSB7XG5cdFx0XHRcdHNlbGYucHVzaChuZXcgQnVmZmVyKHJlc3BvbnNlKSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHRcdC8vIEZhbGxzIHRocm91Z2ggaW4gSUU4XHRcblx0XHRjYXNlICd0ZXh0Jzpcblx0XHRcdHRyeSB7IC8vIFRoaXMgd2lsbCBmYWlsIHdoZW4gcmVhZHlTdGF0ZSA9IDMgaW4gSUU5LiBTd2l0Y2ggbW9kZSBhbmQgd2FpdCBmb3IgcmVhZHlTdGF0ZSA9IDRcblx0XHRcdFx0cmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUZXh0XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHNlbGYuX21vZGUgPSAndGV4dDp2YmFycmF5J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJlc3BvbnNlLmxlbmd0aCA+IHNlbGYuX3Bvcykge1xuXHRcdFx0XHR2YXIgbmV3RGF0YSA9IHJlc3BvbnNlLnN1YnN0cihzZWxmLl9wb3MpXG5cdFx0XHRcdGlmIChzZWxmLl9jaGFyc2V0ID09PSAneC11c2VyLWRlZmluZWQnKSB7XG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIobmV3RGF0YS5sZW5ndGgpXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEYXRhLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdFx0YnVmZmVyW2ldID0gbmV3RGF0YS5jaGFyQ29kZUF0KGkpICYgMHhmZlxuXG5cdFx0XHRcdFx0c2VsZi5wdXNoKGJ1ZmZlcilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobmV3RGF0YSwgc2VsZi5fY2hhcnNldClcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLl9wb3MgPSByZXNwb25zZS5sZW5ndGhcblx0XHRcdH1cblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnYXJyYXlidWZmZXInOlxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkRPTkUgfHwgIXhoci5yZXNwb25zZSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcic6IC8vIHRha2Ugd2hvbGVcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORyB8fCAhcmVzcG9uc2UpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdtcy1zdHJlYW0nOlxuXHRcdFx0cmVzcG9uc2UgPSB4aHIucmVzcG9uc2Vcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gclN0YXRlcy5MT0FESU5HKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBnbG9iYWwuTVNTdHJlYW1SZWFkZXIoKVxuXHRcdFx0cmVhZGVyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChyZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGggPiBzZWxmLl9wb3MpIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0LnNsaWNlKHNlbGYuX3BvcykpKSlcblx0XHRcdFx0XHRzZWxmLl9wb3MgPSByZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGhcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHR9XG5cdFx0XHQvLyByZWFkZXIub25lcnJvciA9ID8/PyAvLyBUT0RPOiB0aGlzXG5cdFx0XHRyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIocmVzcG9uc2UpXG5cdFx0XHRicmVha1xuXHR9XG5cblx0Ly8gVGhlIG1zLXN0cmVhbSBjYXNlIGhhbmRsZXMgZW5kIHNlcGFyYXRlbHkgaW4gcmVhZGVyLm9ubG9hZCgpXG5cdGlmIChzZWxmLl94aHIucmVhZHlTdGF0ZSA9PT0gclN0YXRlcy5ET05FICYmIHNlbGYuX21vZGUgIT09ICdtcy1zdHJlYW0nKSB7XG5cdFx0c2VsZi5wdXNoKG51bGwpXG5cdH1cbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYnVmKSB7XG5cdC8vIElmIHRoZSBidWZmZXIgaXMgYmFja2VkIGJ5IGEgVWludDhBcnJheSwgYSBmYXN0ZXIgdmVyc2lvbiB3aWxsIHdvcmtcblx0aWYgKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0XHQvLyBJZiB0aGUgYnVmZmVyIGlzbid0IGEgc3ViYXJyYXksIHJldHVybiB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlclxuXHRcdGlmIChidWYuYnl0ZU9mZnNldCA9PT0gMCAmJiBidWYuYnl0ZUxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gYnVmLmJ1ZmZlclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGJ1Zi5idWZmZXIuc2xpY2UgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIGdldCBhIHByb3BlciBjb3B5XG5cdFx0XHRyZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aClcblx0XHR9XG5cdH1cblxuXHRpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcblx0XHQvLyBUaGlzIGlzIHRoZSBzbG93IHZlcnNpb24gdGhhdCB3aWxsIHdvcmsgd2l0aCBhbnkgQnVmZmVyXG5cdFx0Ly8gaW1wbGVtZW50YXRpb24gKGV2ZW4gaW4gb2xkIGJyb3dzZXJzKVxuXHRcdHZhciBhcnJheUNvcHkgPSBuZXcgVWludDhBcnJheShidWYubGVuZ3RoKVxuXHRcdHZhciBsZW4gPSBidWYubGVuZ3RoXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJyYXlDb3B5W2ldID0gYnVmW2ldXG5cdFx0fVxuXHRcdHJldHVybiBhcnJheUNvcHkuYnVmZmVyXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcblx0fVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIGV4cG9ydHMuc3RyaXBCT00gPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoc3RyWzBdID09PSAnXFx1RkVGRicpIHtcbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgYnVpbGRlciwgZGVmYXVsdHMsIGVzY2FwZUNEQVRBLCByZXF1aXJlc0NEQVRBLCB3cmFwQ0RBVEEsXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGJ1aWxkZXIgPSByZXF1aXJlKCd4bWxidWlsZGVyJyk7XG5cbiAgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJykuZGVmYXVsdHM7XG5cbiAgcmVxdWlyZXNDREFUQSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIiAmJiAoZW50cnkuaW5kZXhPZignJicpID49IDAgfHwgZW50cnkuaW5kZXhPZignPicpID49IDAgfHwgZW50cnkuaW5kZXhPZignPCcpID49IDApO1xuICB9O1xuXG4gIHdyYXBDREFUQSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgcmV0dXJuIFwiPCFbQ0RBVEFbXCIgKyAoZXNjYXBlQ0RBVEEoZW50cnkpKSArIFwiXV0+XCI7XG4gIH07XG5cbiAgZXNjYXBlQ0RBVEEgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5yZXBsYWNlKCddXT4nLCAnXV1dXT48IVtDREFUQVs+Jyk7XG4gIH07XG5cbiAgZXhwb3J0cy5CdWlsZGVyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEJ1aWxkZXIob3B0cykge1xuICAgICAgdmFyIGtleSwgcmVmLCB2YWx1ZTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgcmVmID0gZGVmYXVsdHNbXCIwLjJcIl07XG4gICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoa2V5IGluIG9wdHMpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwob3B0cywga2V5KSkgY29udGludWU7XG4gICAgICAgIHZhbHVlID0gb3B0c1trZXldO1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIEJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkT2JqZWN0ID0gZnVuY3Rpb24ocm9vdE9iaikge1xuICAgICAgdmFyIGF0dHJrZXksIGNoYXJrZXksIHJlbmRlciwgcm9vdEVsZW1lbnQsIHJvb3ROYW1lO1xuICAgICAgYXR0cmtleSA9IHRoaXMub3B0aW9ucy5hdHRya2V5O1xuICAgICAgY2hhcmtleSA9IHRoaXMub3B0aW9ucy5jaGFya2V5O1xuICAgICAgaWYgKChPYmplY3Qua2V5cyhyb290T2JqKS5sZW5ndGggPT09IDEpICYmICh0aGlzLm9wdGlvbnMucm9vdE5hbWUgPT09IGRlZmF1bHRzWycwLjInXS5yb290TmFtZSkpIHtcbiAgICAgICAgcm9vdE5hbWUgPSBPYmplY3Qua2V5cyhyb290T2JqKVswXTtcbiAgICAgICAgcm9vdE9iaiA9IHJvb3RPYmpbcm9vdE5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdE5hbWUgPSB0aGlzLm9wdGlvbnMucm9vdE5hbWU7XG4gICAgICB9XG4gICAgICByZW5kZXIgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIG9iaikge1xuICAgICAgICAgIHZhciBhdHRyLCBjaGlsZCwgZW50cnksIGluZGV4LCBrZXksIHZhbHVlO1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2RhdGEgJiYgcmVxdWlyZXNDREFUQShvYmopKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmF3KHdyYXBDREFUQShvYmopKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQudHh0KG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGZvciAoaW5kZXggaW4gb2JqKSB7XG4gICAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKG9iaiwgaW5kZXgpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2hpbGQgPSBvYmpbaW5kZXhdO1xuICAgICAgICAgICAgICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgICAgICAgICAgICAgIGVudHJ5ID0gY2hpbGRba2V5XTtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gcmVuZGVyKGVsZW1lbnQuZWxlKGtleSksIGVudHJ5KS51cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChvYmosIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjaGlsZCA9IG9ialtrZXldO1xuICAgICAgICAgICAgICBpZiAoa2V5ID09PSBhdHRya2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgZm9yIChhdHRyIGluIGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2hpbGRbYXR0cl07XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmF0dChhdHRyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gY2hhcmtleSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNkYXRhICYmIHJlcXVpcmVzQ0RBVEEoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5yYXcod3JhcENEQVRBKGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnR4dChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpbmRleCBpbiBjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwoY2hpbGQsIGluZGV4KSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBlbnRyeSA9IGNoaWxkW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNkYXRhICYmIHJlcXVpcmVzQ0RBVEEoZW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuZWxlKGtleSkucmF3KHdyYXBDREFUQShlbnRyeSkpLnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuZWxlKGtleSwgZW50cnkpLnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSByZW5kZXIoZWxlbWVudC5lbGUoa2V5KSwgZW50cnkpLnVwKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSByZW5kZXIoZWxlbWVudC5lbGUoa2V5KSwgY2hpbGQpLnVwKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgJiYgX3RoaXMub3B0aW9ucy5jZGF0YSAmJiByZXF1aXJlc0NEQVRBKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuZWxlKGtleSkucmF3KHdyYXBDREFUQShjaGlsZCkpLnVwKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gJyc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5lbGUoa2V5LCBjaGlsZC50b1N0cmluZygpKS51cCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgcm9vdEVsZW1lbnQgPSBidWlsZGVyLmNyZWF0ZShyb290TmFtZSwgdGhpcy5vcHRpb25zLnhtbGRlYywgdGhpcy5vcHRpb25zLmRvY3R5cGUsIHtcbiAgICAgICAgaGVhZGxlc3M6IHRoaXMub3B0aW9ucy5oZWFkbGVzcyxcbiAgICAgICAgYWxsb3dTdXJyb2dhdGVDaGFyczogdGhpcy5vcHRpb25zLmFsbG93U3Vycm9nYXRlQ2hhcnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlbmRlcihyb290RWxlbWVudCwgcm9vdE9iaikuZW5kKHRoaXMub3B0aW9ucy5yZW5kZXJPcHRzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEJ1aWxkZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIGV4cG9ydHMuZGVmYXVsdHMgPSB7XG4gICAgXCIwLjFcIjoge1xuICAgICAgZXhwbGljaXRDaGFya2V5OiBmYWxzZSxcbiAgICAgIHRyaW06IHRydWUsXG4gICAgICBub3JtYWxpemU6IHRydWUsXG4gICAgICBub3JtYWxpemVUYWdzOiBmYWxzZSxcbiAgICAgIGF0dHJrZXk6IFwiQFwiLFxuICAgICAgY2hhcmtleTogXCIjXCIsXG4gICAgICBleHBsaWNpdEFycmF5OiBmYWxzZSxcbiAgICAgIGlnbm9yZUF0dHJzOiBmYWxzZSxcbiAgICAgIG1lcmdlQXR0cnM6IGZhbHNlLFxuICAgICAgZXhwbGljaXRSb290OiBmYWxzZSxcbiAgICAgIHZhbGlkYXRvcjogbnVsbCxcbiAgICAgIHhtbG5zOiBmYWxzZSxcbiAgICAgIGV4cGxpY2l0Q2hpbGRyZW46IGZhbHNlLFxuICAgICAgY2hpbGRrZXk6ICdAQCcsXG4gICAgICBjaGFyc0FzQ2hpbGRyZW46IGZhbHNlLFxuICAgICAgaW5jbHVkZVdoaXRlQ2hhcnM6IGZhbHNlLFxuICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgYXR0ck5hbWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgYXR0clZhbHVlUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIHRhZ05hbWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgdmFsdWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgZW1wdHlUYWc6ICcnXG4gICAgfSxcbiAgICBcIjAuMlwiOiB7XG4gICAgICBleHBsaWNpdENoYXJrZXk6IGZhbHNlLFxuICAgICAgdHJpbTogZmFsc2UsXG4gICAgICBub3JtYWxpemU6IGZhbHNlLFxuICAgICAgbm9ybWFsaXplVGFnczogZmFsc2UsXG4gICAgICBhdHRya2V5OiBcIiRcIixcbiAgICAgIGNoYXJrZXk6IFwiX1wiLFxuICAgICAgZXhwbGljaXRBcnJheTogdHJ1ZSxcbiAgICAgIGlnbm9yZUF0dHJzOiBmYWxzZSxcbiAgICAgIG1lcmdlQXR0cnM6IGZhbHNlLFxuICAgICAgZXhwbGljaXRSb290OiB0cnVlLFxuICAgICAgdmFsaWRhdG9yOiBudWxsLFxuICAgICAgeG1sbnM6IGZhbHNlLFxuICAgICAgZXhwbGljaXRDaGlsZHJlbjogZmFsc2UsXG4gICAgICBwcmVzZXJ2ZUNoaWxkcmVuT3JkZXI6IGZhbHNlLFxuICAgICAgY2hpbGRrZXk6ICckJCcsXG4gICAgICBjaGFyc0FzQ2hpbGRyZW46IGZhbHNlLFxuICAgICAgaW5jbHVkZVdoaXRlQ2hhcnM6IGZhbHNlLFxuICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgYXR0ck5hbWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgYXR0clZhbHVlUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIHRhZ05hbWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgdmFsdWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgcm9vdE5hbWU6ICdyb290JyxcbiAgICAgIHhtbGRlYzoge1xuICAgICAgICAndmVyc2lvbic6ICcxLjAnLFxuICAgICAgICAnZW5jb2RpbmcnOiAnVVRGLTgnLFxuICAgICAgICAnc3RhbmRhbG9uZSc6IHRydWVcbiAgICAgIH0sXG4gICAgICBkb2N0eXBlOiBudWxsLFxuICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAncHJldHR5JzogdHJ1ZSxcbiAgICAgICAgJ2luZGVudCc6ICcgICcsXG4gICAgICAgICduZXdsaW5lJzogJ1xcbidcbiAgICAgIH0sXG4gICAgICBoZWFkbGVzczogZmFsc2UsXG4gICAgICBjaHVua1NpemU6IDEwMDAwLFxuICAgICAgZW1wdHlUYWc6ICcnLFxuICAgICAgY2RhdGE6IGZhbHNlXG4gICAgfVxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBib20sIGRlZmF1bHRzLCBldmVudHMsIGlzRW1wdHksIHByb2Nlc3NJdGVtLCBwcm9jZXNzb3JzLCBzYXgsIHNldEltbWVkaWF0ZSxcbiAgICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIHNheCA9IHJlcXVpcmUoJ3NheCcpO1xuXG4gIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG4gIGJvbSA9IHJlcXVpcmUoJy4vYm9tJyk7XG5cbiAgcHJvY2Vzc29ycyA9IHJlcXVpcmUoJy4vcHJvY2Vzc29ycycpO1xuXG4gIHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ3RpbWVycycpLnNldEltbWVkaWF0ZTtcblxuICBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKS5kZWZhdWx0cztcblxuICBpc0VtcHR5ID0gZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmICh0aGluZyAhPSBudWxsKSAmJiBPYmplY3Qua2V5cyh0aGluZykubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIHByb2Nlc3NJdGVtID0gZnVuY3Rpb24ocHJvY2Vzc29ycywgaXRlbSwga2V5KSB7XG4gICAgdmFyIGksIGxlbiwgcHJvY2VzcztcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm9jZXNzb3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBwcm9jZXNzID0gcHJvY2Vzc29yc1tpXTtcbiAgICAgIGl0ZW0gPSBwcm9jZXNzKGl0ZW0sIGtleSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9O1xuXG4gIGV4cG9ydHMuUGFyc2VyID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUGFyc2VyLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFBhcnNlcihvcHRzKSB7XG4gICAgICB0aGlzLnBhcnNlU3RyaW5nID0gYmluZCh0aGlzLnBhcnNlU3RyaW5nLCB0aGlzKTtcbiAgICAgIHRoaXMucmVzZXQgPSBiaW5kKHRoaXMucmVzZXQsIHRoaXMpO1xuICAgICAgdGhpcy5hc3NpZ25PclB1c2ggPSBiaW5kKHRoaXMuYXNzaWduT3JQdXNoLCB0aGlzKTtcbiAgICAgIHRoaXMucHJvY2Vzc0FzeW5jID0gYmluZCh0aGlzLnByb2Nlc3NBc3luYywgdGhpcyk7XG4gICAgICB2YXIga2V5LCByZWYsIHZhbHVlO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGV4cG9ydHMuUGFyc2VyKSkge1xuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuUGFyc2VyKG9wdHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICByZWYgPSBkZWZhdWx0c1tcIjAuMlwiXTtcbiAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YWx1ZSA9IHJlZltrZXldO1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgZm9yIChrZXkgaW4gb3B0cykge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChvcHRzLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFsdWUgPSBvcHRzW2tleV07XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnhtbG5zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy54bWxuc2tleSA9IHRoaXMub3B0aW9ucy5hdHRya2V5ICsgXCJuc1wiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub3JtYWxpemVUYWdzKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnRhZ05hbWVQcm9jZXNzb3JzKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnRhZ05hbWVQcm9jZXNzb3JzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLnRhZ05hbWVQcm9jZXNzb3JzLnVuc2hpZnQocHJvY2Vzc29ycy5ub3JtYWxpemUpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIFBhcnNlci5wcm90b3R5cGUucHJvY2Vzc0FzeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2h1bmssIGVycjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnJlbWFpbmluZy5sZW5ndGggPD0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZSkge1xuICAgICAgICAgIGNodW5rID0gdGhpcy5yZW1haW5pbmc7XG4gICAgICAgICAgdGhpcy5yZW1haW5pbmcgPSAnJztcbiAgICAgICAgICB0aGlzLnNheFBhcnNlciA9IHRoaXMuc2F4UGFyc2VyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zYXhQYXJzZXIuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVuayA9IHRoaXMucmVtYWluaW5nLnN1YnN0cigwLCB0aGlzLm9wdGlvbnMuY2h1bmtTaXplKTtcbiAgICAgICAgICB0aGlzLnJlbWFpbmluZyA9IHRoaXMucmVtYWluaW5nLnN1YnN0cih0aGlzLm9wdGlvbnMuY2h1bmtTaXplLCB0aGlzLnJlbWFpbmluZy5sZW5ndGgpO1xuICAgICAgICAgIHRoaXMuc2F4UGFyc2VyID0gdGhpcy5zYXhQYXJzZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUodGhpcy5wcm9jZXNzQXN5bmMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgZXJyID0gZXJyb3IxO1xuICAgICAgICBpZiAoIXRoaXMuc2F4UGFyc2VyLmVyclRocm93bikge1xuICAgICAgICAgIHRoaXMuc2F4UGFyc2VyLmVyclRocm93biA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUuYXNzaWduT3JQdXNoID0gZnVuY3Rpb24ob2JqLCBrZXksIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAoIShrZXkgaW4gb2JqKSkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5leHBsaWNpdEFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIG9ialtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG9ialtrZXldID0gW25ld1ZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEob2JqW2tleV0gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IFtvYmpba2V5XV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ialtrZXldLnB1c2gobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXR0cmtleSwgY2hhcmtleSwgb250ZXh0LCBzdGFjaztcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLnNheFBhcnNlciA9IHNheC5wYXJzZXIodGhpcy5vcHRpb25zLnN0cmljdCwge1xuICAgICAgICB0cmltOiBmYWxzZSxcbiAgICAgICAgbm9ybWFsaXplOiBmYWxzZSxcbiAgICAgICAgeG1sbnM6IHRoaXMub3B0aW9ucy54bWxuc1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNheFBhcnNlci5lcnJUaHJvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuc2F4UGFyc2VyLm9uZXJyb3IgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgX3RoaXMuc2F4UGFyc2VyLnJlc3VtZSgpO1xuICAgICAgICAgIGlmICghX3RoaXMuc2F4UGFyc2VyLmVyclRocm93bikge1xuICAgICAgICAgICAgX3RoaXMuc2F4UGFyc2VyLmVyclRocm93biA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHRoaXMuc2F4UGFyc2VyLm9uZW5kID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIV90aGlzLnNheFBhcnNlci5lbmRlZCkge1xuICAgICAgICAgICAgX3RoaXMuc2F4UGFyc2VyLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KFwiZW5kXCIsIF90aGlzLnJlc3VsdE9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLnNheFBhcnNlci5lbmRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5FWFBMSUNJVF9DSEFSS0VZID0gdGhpcy5vcHRpb25zLmV4cGxpY2l0Q2hhcmtleTtcbiAgICAgIHRoaXMucmVzdWx0T2JqZWN0ID0gbnVsbDtcbiAgICAgIHN0YWNrID0gW107XG4gICAgICBhdHRya2V5ID0gdGhpcy5vcHRpb25zLmF0dHJrZXk7XG4gICAgICBjaGFya2V5ID0gdGhpcy5vcHRpb25zLmNoYXJrZXk7XG4gICAgICB0aGlzLnNheFBhcnNlci5vbm9wZW50YWcgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICB2YXIga2V5LCBuZXdWYWx1ZSwgb2JqLCBwcm9jZXNzZWRLZXksIHJlZjtcbiAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgICBvYmpbY2hhcmtleV0gPSBcIlwiO1xuICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5pZ25vcmVBdHRycykge1xuICAgICAgICAgICAgcmVmID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgICAgIGlmICghKGF0dHJrZXkgaW4gb2JqKSAmJiAhX3RoaXMub3B0aW9ucy5tZXJnZUF0dHJzKSB7XG4gICAgICAgICAgICAgICAgb2JqW2F0dHJrZXldID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV3VmFsdWUgPSBfdGhpcy5vcHRpb25zLmF0dHJWYWx1ZVByb2Nlc3NvcnMgPyBwcm9jZXNzSXRlbShfdGhpcy5vcHRpb25zLmF0dHJWYWx1ZVByb2Nlc3NvcnMsIG5vZGUuYXR0cmlidXRlc1trZXldLCBrZXkpIDogbm9kZS5hdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgIHByb2Nlc3NlZEtleSA9IF90aGlzLm9wdGlvbnMuYXR0ck5hbWVQcm9jZXNzb3JzID8gcHJvY2Vzc0l0ZW0oX3RoaXMub3B0aW9ucy5hdHRyTmFtZVByb2Nlc3NvcnMsIGtleSkgOiBrZXk7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLm1lcmdlQXR0cnMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hc3NpZ25PclB1c2gob2JqLCBwcm9jZXNzZWRLZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpbYXR0cmtleV1bcHJvY2Vzc2VkS2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ialtcIiNuYW1lXCJdID0gX3RoaXMub3B0aW9ucy50YWdOYW1lUHJvY2Vzc29ycyA/IHByb2Nlc3NJdGVtKF90aGlzLm9wdGlvbnMudGFnTmFtZVByb2Nlc3NvcnMsIG5vZGUubmFtZSkgOiBub2RlLm5hbWU7XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMueG1sbnMpIHtcbiAgICAgICAgICAgIG9ialtfdGhpcy5vcHRpb25zLnhtbG5za2V5XSA9IHtcbiAgICAgICAgICAgICAgdXJpOiBub2RlLnVyaSxcbiAgICAgICAgICAgICAgbG9jYWw6IG5vZGUubG9jYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdGFjay5wdXNoKG9iaik7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHRoaXMuc2F4UGFyc2VyLm9uY2xvc2V0YWcgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBjZGF0YSwgZW1wdHlTdHIsIGtleSwgbm9kZSwgbm9kZU5hbWUsIG9iaiwgb2JqQ2xvbmUsIG9sZCwgcywgeHBhdGg7XG4gICAgICAgICAgb2JqID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgbm9kZU5hbWUgPSBvYmpbXCIjbmFtZVwiXTtcbiAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuZXhwbGljaXRDaGlsZHJlbiB8fCAhX3RoaXMub3B0aW9ucy5wcmVzZXJ2ZUNoaWxkcmVuT3JkZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbXCIjbmFtZVwiXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iai5jZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2RhdGEgPSBvYmouY2RhdGE7XG4gICAgICAgICAgICBkZWxldGUgb2JqLmNkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKG9ialtjaGFya2V5XS5tYXRjaCgvXlxccyokLykgJiYgIWNkYXRhKSB7XG4gICAgICAgICAgICBlbXB0eVN0ciA9IG9ialtjaGFya2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbY2hhcmtleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnRyaW0pIHtcbiAgICAgICAgICAgICAgb2JqW2NoYXJrZXldID0gb2JqW2NoYXJrZXldLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICBvYmpbY2hhcmtleV0gPSBvYmpbY2hhcmtleV0ucmVwbGFjZSgvXFxzezIsfS9nLCBcIiBcIikudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2NoYXJrZXldID0gX3RoaXMub3B0aW9ucy52YWx1ZVByb2Nlc3NvcnMgPyBwcm9jZXNzSXRlbShfdGhpcy5vcHRpb25zLnZhbHVlUHJvY2Vzc29ycywgb2JqW2NoYXJrZXldLCBub2RlTmFtZSkgOiBvYmpbY2hhcmtleV07XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDEgJiYgY2hhcmtleSBpbiBvYmogJiYgIV90aGlzLkVYUExJQ0lUX0NIQVJLRVkpIHtcbiAgICAgICAgICAgICAgb2JqID0gb2JqW2NoYXJrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNFbXB0eShvYmopKSB7XG4gICAgICAgICAgICBvYmogPSBfdGhpcy5vcHRpb25zLmVtcHR5VGFnICE9PSAnJyA/IF90aGlzLm9wdGlvbnMuZW1wdHlUYWcgOiBlbXB0eVN0cjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMudmFsaWRhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIHhwYXRoID0gXCIvXCIgKyAoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgaSwgbGVuLCByZXN1bHRzO1xuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0YWNrLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlW1wiI25hbWVcIl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKSkuY29uY2F0KG5vZGVOYW1lKS5qb2luKFwiL1wiKTtcbiAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGVycjtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqID0gX3RoaXMub3B0aW9ucy52YWxpZGF0b3IoeHBhdGgsIHMgJiYgc1tub2RlTmFtZV0sIG9iaik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgICAgICAgIGVyciA9IGVycm9yMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmV4cGxpY2l0Q2hpbGRyZW4gJiYgIV90aGlzLm9wdGlvbnMubWVyZ2VBdHRycyAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnByZXNlcnZlQ2hpbGRyZW5PcmRlcikge1xuICAgICAgICAgICAgICBub2RlID0ge307XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmF0dHJrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtfdGhpcy5vcHRpb25zLmF0dHJrZXldID0gb2JqW190aGlzLm9wdGlvbnMuYXR0cmtleV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialtfdGhpcy5vcHRpb25zLmF0dHJrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5jaGFyc0FzQ2hpbGRyZW4gJiYgX3RoaXMub3B0aW9ucy5jaGFya2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIG5vZGVbX3RoaXMub3B0aW9ucy5jaGFya2V5XSA9IG9ialtfdGhpcy5vcHRpb25zLmNoYXJrZXldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbX3RoaXMub3B0aW9ucy5jaGFya2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtfdGhpcy5vcHRpb25zLmNoaWxka2V5XSA9IG9iajtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvYmogPSBub2RlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzKSB7XG4gICAgICAgICAgICAgIHNbX3RoaXMub3B0aW9ucy5jaGlsZGtleV0gPSBzW190aGlzLm9wdGlvbnMuY2hpbGRrZXldIHx8IFtdO1xuICAgICAgICAgICAgICBvYmpDbG9uZSA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChvYmosIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIG9iakNsb25lW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzW190aGlzLm9wdGlvbnMuY2hpbGRrZXldLnB1c2gob2JqQ2xvbmUpO1xuICAgICAgICAgICAgICBkZWxldGUgb2JqW1wiI25hbWVcIl07XG4gICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMSAmJiBjaGFya2V5IGluIG9iaiAmJiAhX3RoaXMuRVhQTElDSVRfQ0hBUktFWSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9ialtjaGFya2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFzc2lnbk9yUHVzaChzLCBub2RlTmFtZSwgb2JqKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZXhwbGljaXRSb290KSB7XG4gICAgICAgICAgICAgIG9sZCA9IG9iajtcbiAgICAgICAgICAgICAgb2JqID0ge307XG4gICAgICAgICAgICAgIG9ialtub2RlTmFtZV0gPSBvbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZXN1bHRPYmplY3QgPSBvYmo7XG4gICAgICAgICAgICBfdGhpcy5zYXhQYXJzZXIuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoXCJlbmRcIiwgX3RoaXMucmVzdWx0T2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIG9udGV4dCA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgIHZhciBjaGFyQ2hpbGQsIHM7XG4gICAgICAgICAgcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICBzW2NoYXJrZXldICs9IHRleHQ7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5leHBsaWNpdENoaWxkcmVuICYmIF90aGlzLm9wdGlvbnMucHJlc2VydmVDaGlsZHJlbk9yZGVyICYmIF90aGlzLm9wdGlvbnMuY2hhcnNBc0NoaWxkcmVuICYmIChfdGhpcy5vcHRpb25zLmluY2x1ZGVXaGl0ZUNoYXJzIHx8IHRleHQucmVwbGFjZSgvXFxcXG4vZywgJycpLnRyaW0oKSAhPT0gJycpKSB7XG4gICAgICAgICAgICAgIHNbX3RoaXMub3B0aW9ucy5jaGlsZGtleV0gPSBzW190aGlzLm9wdGlvbnMuY2hpbGRrZXldIHx8IFtdO1xuICAgICAgICAgICAgICBjaGFyQ2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgJyNuYW1lJzogJ19fdGV4dF9fJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjaGFyQ2hpbGRbY2hhcmtleV0gPSB0ZXh0O1xuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICBjaGFyQ2hpbGRbY2hhcmtleV0gPSBjaGFyQ2hpbGRbY2hhcmtleV0ucmVwbGFjZSgvXFxzezIsfS9nLCBcIiBcIikudHJpbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNbX3RoaXMub3B0aW9ucy5jaGlsZGtleV0ucHVzaChjaGFyQ2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLnNheFBhcnNlci5vbnRleHQgPSBvbnRleHQ7XG4gICAgICByZXR1cm4gdGhpcy5zYXhQYXJzZXIub25jZGF0YSA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgIHZhciBzO1xuICAgICAgICAgIHMgPSBvbnRleHQodGV4dCk7XG4gICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzLmNkYXRhID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgY2IpIHtcbiAgICAgIHZhciBlcnI7XG4gICAgICBpZiAoKGNiICE9IG51bGwpICYmIHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub24oXCJlbmRcIiwgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCByZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBzdHIgPSBzdHIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHN0ci50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIsIG51bGwpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGJvbS5zdHJpcEJPTShzdHIpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFzeW5jKSB7XG4gICAgICAgICAgdGhpcy5yZW1haW5pbmcgPSBzdHI7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKHRoaXMucHJvY2Vzc0FzeW5jKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zYXhQYXJzZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyLndyaXRlKHN0cikuY2xvc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICBlcnIgPSBlcnJvcjE7XG4gICAgICAgIGlmICghKHRoaXMuc2F4UGFyc2VyLmVyclRocm93biB8fCB0aGlzLnNheFBhcnNlci5lbmRlZCkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zYXhQYXJzZXIuZXJyVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNheFBhcnNlci5lbmRlZCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUGFyc2VyO1xuXG4gIH0pKGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG4gIGV4cG9ydHMucGFyc2VTdHJpbmcgPSBmdW5jdGlvbihzdHIsIGEsIGIpIHtcbiAgICB2YXIgY2IsIG9wdGlvbnMsIHBhcnNlcjtcbiAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IgPSBiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0gYTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gYTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcGFyc2VyID0gbmV3IGV4cG9ydHMuUGFyc2VyKG9wdGlvbnMpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2VTdHJpbmcoc3RyLCBjYik7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIHByZWZpeE1hdGNoO1xuXG4gIHByZWZpeE1hdGNoID0gbmV3IFJlZ0V4cCgvKD8heG1sbnMpXi4qOi8pO1xuXG4gIGV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xuICB9O1xuXG4gIGV4cG9ydHMuZmlyc3RDaGFyTG93ZXJDYXNlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgfTtcblxuICBleHBvcnRzLnN0cmlwUHJlZml4ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHByZWZpeE1hdGNoLCAnJyk7XG4gIH07XG5cbiAgZXhwb3J0cy5wYXJzZU51bWJlcnMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIWlzTmFOKHN0cikpIHtcbiAgICAgIHN0ciA9IHN0ciAlIDEgPT09IDAgPyBwYXJzZUludChzdHIsIDEwKSA6IHBhcnNlRmxvYXQoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBleHBvcnRzLnBhcnNlQm9vbGVhbnMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoL14oPzp0cnVlfGZhbHNlKSQvaS50ZXN0KHN0cikpIHtcbiAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIGJ1aWxkZXIsIGRlZmF1bHRzLCBwYXJzZXIsIHByb2Nlc3NvcnMsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuICBidWlsZGVyID0gcmVxdWlyZSgnLi9idWlsZGVyJyk7XG5cbiAgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcblxuICBwcm9jZXNzb3JzID0gcmVxdWlyZSgnLi9wcm9jZXNzb3JzJyk7XG5cbiAgZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzLmRlZmF1bHRzO1xuXG4gIGV4cG9ydHMucHJvY2Vzc29ycyA9IHByb2Nlc3NvcnM7XG5cbiAgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChWYWxpZGF0aW9uRXJyb3IsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKG1lc3NhZ2UpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIFZhbGlkYXRpb25FcnJvcjtcblxuICB9KShFcnJvcik7XG5cbiAgZXhwb3J0cy5CdWlsZGVyID0gYnVpbGRlci5CdWlsZGVyO1xuXG4gIGV4cG9ydHMuUGFyc2VyID0gcGFyc2VyLlBhcnNlcjtcblxuICBleHBvcnRzLnBhcnNlU3RyaW5nID0gcGFyc2VyLnBhcnNlU3RyaW5nO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIGFzc2lnbiwgaXNBcnJheSwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIGlzUGxhaW5PYmplY3QsXG4gICAgc2xpY2UgPSBbXS5zbGljZSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksIGtleSwgbGVuLCBzb3VyY2UsIHNvdXJjZXMsIHRhcmdldDtcbiAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0sIHNvdXJjZXMgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICBpZiAoaXNGdW5jdGlvbihPYmplY3QuYXNzaWduKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAhIXZhbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfTtcblxuICBpc09iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciByZWY7XG4gICAgcmV0dXJuICEhdmFsICYmICgocmVmID0gdHlwZW9mIHZhbCkgPT09ICdmdW5jdGlvbicgfHwgcmVmID09PSAnb2JqZWN0Jyk7XG4gIH07XG5cbiAgaXNBcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKEFycmF5LmlzQXJyYXkpKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuICB9O1xuXG4gIGlzRW1wdHkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJldHVybiAhdmFsLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChrZXkgaW4gdmFsKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHZhbCwga2V5KSkgY29udGludWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIGN0b3IsIHByb3RvO1xuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIChwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpKSAmJiAoY3RvciA9IHByb3RvLmNvbnN0cnVjdG9yKSAmJiAodHlwZW9mIGN0b3IgPT09ICdmdW5jdGlvbicpICYmIChjdG9yIGluc3RhbmNlb2YgY3RvcikgJiYgKEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGN0b3IpID09PSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChPYmplY3QpKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuICBtb2R1bGUuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuICBtb2R1bGUuZXhwb3J0cy5pc0VtcHR5ID0gaXNFbXB0eTtcblxuICBtb2R1bGUuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxBdHRyaWJ1dGU7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxBdHRyaWJ1dGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MQXR0cmlidXRlKHBhcmVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmVudC5vcHRpb25zO1xuICAgICAgdGhpcy5zdHJpbmdpZnkgPSBwYXJlbnQuc3RyaW5naWZ5O1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lIG9mIGVsZW1lbnQgXCIgKyBwYXJlbnQubmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZSB2YWx1ZSBmb3IgYXR0cmlidXRlIFwiICsgbmFtZSArIFwiIG9mIGVsZW1lbnQgXCIgKyBwYXJlbnQubmFtZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm5hbWUgPSB0aGlzLnN0cmluZ2lmeS5hdHROYW1lKG5hbWUpO1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3RyaW5naWZ5LmF0dFZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBYTUxBdHRyaWJ1dGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MQXR0cmlidXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5hdHRyaWJ1dGUodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxBdHRyaWJ1dGU7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxDRGF0YSwgWE1MTm9kZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTENEYXRhID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MQ0RhdGEsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MQ0RhdGEocGFyZW50LCB0ZXh0KSB7XG4gICAgICBYTUxDRGF0YS5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIENEQVRBIHRleHRcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLnN0cmluZ2lmeS5jZGF0YSh0ZXh0KTtcbiAgICB9XG5cbiAgICBYTUxDRGF0YS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIH07XG5cbiAgICBYTUxDRGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykuY2RhdGEodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxDRGF0YTtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxDb21tZW50LCBYTUxOb2RlLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MQ29tbWVudCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTENvbW1lbnQsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MQ29tbWVudChwYXJlbnQsIHRleHQpIHtcbiAgICAgIFhNTENvbW1lbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBjb21tZW50IHRleHRcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLnN0cmluZ2lmeS5jb21tZW50KHRleHQpO1xuICAgIH1cblxuICAgIFhNTENvbW1lbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MQ29tbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykuY29tbWVudCh0aGlzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTENvbW1lbnQ7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MRFREQXR0TGlzdCwgWE1MTm9kZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERUREF0dExpc3QgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxEVERBdHRMaXN0LCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTERUREF0dExpc3QocGFyZW50LCBlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICBYTUxEVERBdHRMaXN0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAoZWxlbWVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIERURCBlbGVtZW50IG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGF0dHJpYnV0ZSBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFhdHRyaWJ1dGVUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGF0dHJpYnV0ZSB0eXBlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWZhdWx0VmFsdWVUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGF0dHJpYnV0ZSBkZWZhdWx0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZVR5cGUuaW5kZXhPZignIycpICE9PSAwKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZVR5cGUgPSAnIycgKyBkZWZhdWx0VmFsdWVUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWZhdWx0VmFsdWVUeXBlLm1hdGNoKC9eKCNSRVFVSVJFRHwjSU1QTElFRHwjRklYRUR8I0RFRkFVTFQpJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGVmYXVsdCB2YWx1ZSB0eXBlOyBleHBlY3RlZDogI1JFUVVJUkVELCAjSU1QTElFRCwgI0ZJWEVEIG9yICNERUZBVUxUXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAmJiAhZGVmYXVsdFZhbHVlVHlwZS5tYXRjaCgvXigjRklYRUR8I0RFRkFVTFQpJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmF1bHQgdmFsdWUgb25seSBhcHBsaWVzIHRvICNGSVhFRCBvciAjREVGQVVMVFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxlbWVudE5hbWUgPSB0aGlzLnN0cmluZ2lmeS5lbGVOYW1lKGVsZW1lbnROYW1lKTtcbiAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IHRoaXMuc3RyaW5naWZ5LmF0dE5hbWUoYXR0cmlidXRlTmFtZSk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZVR5cGUgPSB0aGlzLnN0cmluZ2lmeS5kdGRBdHRUeXBlKGF0dHJpYnV0ZVR5cGUpO1xuICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5kdGRBdHREZWZhdWx0KGRlZmF1bHRWYWx1ZSk7XG4gICAgICB0aGlzLmRlZmF1bHRWYWx1ZVR5cGUgPSBkZWZhdWx0VmFsdWVUeXBlO1xuICAgIH1cblxuICAgIFhNTERUREF0dExpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KG9wdGlvbnMpLmR0ZEF0dExpc3QodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEVERBdHRMaXN0O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERUREVsZW1lbnQsIFhNTE5vZGUsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEVERFbGVtZW50ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MRFRERWxlbWVudCwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEVERFbGVtZW50KHBhcmVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIFhNTERUREVsZW1lbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBEVEQgZWxlbWVudCBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9ICcoI1BDREFUQSknO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gJygnICsgdmFsdWUuam9pbignLCcpICsgJyknO1xuICAgICAgfVxuICAgICAgdGhpcy5uYW1lID0gdGhpcy5zdHJpbmdpZnkuZWxlTmFtZShuYW1lKTtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5kdGRFbGVtZW50VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIFhNTERUREVsZW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KG9wdGlvbnMpLmR0ZEVsZW1lbnQodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEVERFbGVtZW50O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERUREVudGl0eSwgWE1MTm9kZSwgaXNPYmplY3QsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBpc09iamVjdCA9IHJlcXVpcmUoJy4vVXRpbGl0eScpLmlzT2JqZWN0O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERUREVudGl0eSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTERUREVudGl0eSwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxEVERFbnRpdHkocGFyZW50LCBwZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIFhNTERUREVudGl0eS5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVudGl0eSBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBlbnRpdHkgdmFsdWVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnBlID0gISFwZTtcbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5LmVsZU5hbWUobmFtZSk7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5zdHJpbmdpZnkuZHRkRW50aXR5VmFsdWUodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5wdWJJRCAmJiAhdmFsdWUuc3lzSUQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQdWJsaWMgYW5kL29yIHN5c3RlbSBpZGVudGlmaWVycyBhcmUgcmVxdWlyZWQgZm9yIGFuIGV4dGVybmFsIGVudGl0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUucHViSUQgJiYgIXZhbHVlLnN5c0lEKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3lzdGVtIGlkZW50aWZpZXIgaXMgcmVxdWlyZWQgZm9yIGEgcHVibGljIGV4dGVybmFsIGVudGl0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUucHViSUQgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucHViSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRQdWJJRCh2YWx1ZS5wdWJJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnN5c0lEICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnN5c0lEID0gdGhpcy5zdHJpbmdpZnkuZHRkU3lzSUQodmFsdWUuc3lzSUQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5uRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5uRGF0YSA9IHRoaXMuc3RyaW5naWZ5LmR0ZE5EYXRhKHZhbHVlLm5EYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZSAmJiB0aGlzLm5EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90YXRpb24gZGVjbGFyYXRpb24gaXMgbm90IGFsbG93ZWQgaW4gYSBwYXJhbWV0ZXIgZW50aXR5XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MRFRERW50aXR5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5kdGRFbnRpdHkodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEVERFbnRpdHk7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MRFRETm90YXRpb24sIFhNTE5vZGUsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEVEROb3RhdGlvbiA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTERURE5vdGF0aW9uLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTERURE5vdGF0aW9uKHBhcmVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIFhNTERURE5vdGF0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgbm90YXRpb24gbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWUucHViSUQgJiYgIXZhbHVlLnN5c0lEKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlB1YmxpYyBvciBzeXN0ZW0gaWRlbnRpZmllcnMgYXJlIHJlcXVpcmVkIGZvciBhbiBleHRlcm5hbCBlbnRpdHlcIik7XG4gICAgICB9XG4gICAgICB0aGlzLm5hbWUgPSB0aGlzLnN0cmluZ2lmeS5lbGVOYW1lKG5hbWUpO1xuICAgICAgaWYgKHZhbHVlLnB1YklEICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5wdWJJRCA9IHRoaXMuc3RyaW5naWZ5LmR0ZFB1YklEKHZhbHVlLnB1YklEKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZS5zeXNJRCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3lzSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRTeXNJRCh2YWx1ZS5zeXNJRCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MRFRETm90YXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KG9wdGlvbnMpLmR0ZE5vdGF0aW9uKHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRFRETm90YXRpb247XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MRGVjbGFyYXRpb24sIFhNTE5vZGUsIGlzT2JqZWN0LFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgaXNPYmplY3QgPSByZXF1aXJlKCcuL1V0aWxpdHknKS5pc09iamVjdDtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEZWNsYXJhdGlvbiA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTERlY2xhcmF0aW9uLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTERlY2xhcmF0aW9uKHBhcmVudCwgdmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHZhciByZWY7XG4gICAgICBYTUxEZWNsYXJhdGlvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKGlzT2JqZWN0KHZlcnNpb24pKSB7XG4gICAgICAgIHJlZiA9IHZlcnNpb24sIHZlcnNpb24gPSByZWYudmVyc2lvbiwgZW5jb2RpbmcgPSByZWYuZW5jb2RpbmcsIHN0YW5kYWxvbmUgPSByZWYuc3RhbmRhbG9uZTtcbiAgICAgIH1cbiAgICAgIGlmICghdmVyc2lvbikge1xuICAgICAgICB2ZXJzaW9uID0gJzEuMCc7XG4gICAgICB9XG4gICAgICB0aGlzLnZlcnNpb24gPSB0aGlzLnN0cmluZ2lmeS54bWxWZXJzaW9uKHZlcnNpb24pO1xuICAgICAgaWYgKGVuY29kaW5nICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IHRoaXMuc3RyaW5naWZ5LnhtbEVuY29kaW5nKGVuY29kaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFuZGFsb25lICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGFuZGFsb25lID0gdGhpcy5zdHJpbmdpZnkueG1sU3RhbmRhbG9uZShzdGFuZGFsb25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxEZWNsYXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5zZXQob3B0aW9ucykuZGVjbGFyYXRpb24odGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEZWNsYXJhdGlvbjtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEVERBdHRMaXN0LCBYTUxEVERFbGVtZW50LCBYTUxEVERFbnRpdHksIFhNTERURE5vdGF0aW9uLCBYTUxEb2NUeXBlLCBYTUxOb2RlLCBpc09iamVjdCxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9VdGlsaXR5JykuaXNPYmplY3Q7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIFhNTERUREF0dExpc3QgPSByZXF1aXJlKCcuL1hNTERUREF0dExpc3QnKTtcblxuICBYTUxEVERFbnRpdHkgPSByZXF1aXJlKCcuL1hNTERUREVudGl0eScpO1xuXG4gIFhNTERUREVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTERUREVsZW1lbnQnKTtcblxuICBYTUxEVEROb3RhdGlvbiA9IHJlcXVpcmUoJy4vWE1MRFRETm90YXRpb24nKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERvY1R5cGUgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxEb2NUeXBlLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTERvY1R5cGUocGFyZW50LCBwdWJJRCwgc3lzSUQpIHtcbiAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICBYTUxEb2NUeXBlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICB0aGlzLmRvY3VtZW50T2JqZWN0ID0gcGFyZW50O1xuICAgICAgaWYgKGlzT2JqZWN0KHB1YklEKSkge1xuICAgICAgICByZWYgPSBwdWJJRCwgcHViSUQgPSByZWYucHViSUQsIHN5c0lEID0gcmVmLnN5c0lEO1xuICAgICAgfVxuICAgICAgaWYgKHN5c0lEID09IG51bGwpIHtcbiAgICAgICAgcmVmMSA9IFtwdWJJRCwgc3lzSURdLCBzeXNJRCA9IHJlZjFbMF0sIHB1YklEID0gcmVmMVsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJJRCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucHViSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRQdWJJRChwdWJJRCk7XG4gICAgICB9XG4gICAgICBpZiAoc3lzSUQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN5c0lEID0gdGhpcy5zdHJpbmdpZnkuZHRkU3lzSUQoc3lzSUQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MRFRERWxlbWVudCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmF0dExpc3QgPSBmdW5jdGlvbihlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBjaGlsZCA9IG5ldyBYTUxEVERBdHRMaXN0KHRoaXMsIGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5lbnRpdHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MRFRERW50aXR5KHRoaXMsIGZhbHNlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLnBFbnRpdHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MRFRERW50aXR5KHRoaXMsIHRydWUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUubm90YXRpb24gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MRFRETm90YXRpb24odGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5kb2NUeXBlKHRoaXMpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5lbGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChuYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmF0dCA9IGZ1bmN0aW9uKGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dExpc3QoZWxlbWVudE5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGRlZmF1bHRWYWx1ZVR5cGUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLmVudCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnRpdHkobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5wZW50ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBFbnRpdHkobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5ub3QgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90YXRpb24obmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdCgpIHx8IHRoaXMuZG9jdW1lbnRPYmplY3Q7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEb2NUeXBlO1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERvY3VtZW50LCBYTUxOb2RlLCBYTUxTdHJpbmdXcml0ZXIsIFhNTFN0cmluZ2lmaWVyLCBpc1BsYWluT2JqZWN0LFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vVXRpbGl0eScpLmlzUGxhaW5PYmplY3Q7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIFhNTFN0cmluZ2lmaWVyID0gcmVxdWlyZSgnLi9YTUxTdHJpbmdpZmllcicpO1xuXG4gIFhNTFN0cmluZ1dyaXRlciA9IHJlcXVpcmUoJy4vWE1MU3RyaW5nV3JpdGVyJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEb2N1bWVudCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTERvY3VtZW50LCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTERvY3VtZW50KG9wdGlvbnMpIHtcbiAgICAgIFhNTERvY3VtZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG51bGwpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIGlmICghb3B0aW9ucy53cml0ZXIpIHtcbiAgICAgICAgb3B0aW9ucy53cml0ZXIgPSBuZXcgWE1MU3RyaW5nV3JpdGVyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5zdHJpbmdpZnkgPSBuZXcgWE1MU3RyaW5naWZpZXIob3B0aW9ucyk7XG4gICAgICB0aGlzLmlzRG9jdW1lbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIFhNTERvY3VtZW50LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgICAgIHZhciB3cml0ZXJPcHRpb25zO1xuICAgICAgaWYgKCF3cml0ZXIpIHtcbiAgICAgICAgd3JpdGVyID0gdGhpcy5vcHRpb25zLndyaXRlcjtcbiAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh3cml0ZXIpKSB7XG4gICAgICAgIHdyaXRlck9wdGlvbnMgPSB3cml0ZXI7XG4gICAgICAgIHdyaXRlciA9IHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KHdyaXRlck9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyaXRlci5kb2N1bWVudCh0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KG9wdGlvbnMpLmRvY3VtZW50KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRG9jdW1lbnQ7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQXR0cmlidXRlLCBYTUxDRGF0YSwgWE1MQ29tbWVudCwgWE1MRFREQXR0TGlzdCwgWE1MRFRERWxlbWVudCwgWE1MRFRERW50aXR5LCBYTUxEVEROb3RhdGlvbiwgWE1MRGVjbGFyYXRpb24sIFhNTERvY1R5cGUsIFhNTERvY3VtZW50Q0IsIFhNTEVsZW1lbnQsIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgWE1MUmF3LCBYTUxTdHJpbmdXcml0ZXIsIFhNTFN0cmluZ2lmaWVyLCBYTUxUZXh0LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNQbGFpbk9iamVjdCwgcmVmLFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICByZWYgPSByZXF1aXJlKCcuL1V0aWxpdHknKSwgaXNPYmplY3QgPSByZWYuaXNPYmplY3QsIGlzRnVuY3Rpb24gPSByZWYuaXNGdW5jdGlvbiwgaXNQbGFpbk9iamVjdCA9IHJlZi5pc1BsYWluT2JqZWN0O1xuXG4gIFhNTEVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTEVsZW1lbnQnKTtcblxuICBYTUxDRGF0YSA9IHJlcXVpcmUoJy4vWE1MQ0RhdGEnKTtcblxuICBYTUxDb21tZW50ID0gcmVxdWlyZSgnLi9YTUxDb21tZW50Jyk7XG5cbiAgWE1MUmF3ID0gcmVxdWlyZSgnLi9YTUxSYXcnKTtcblxuICBYTUxUZXh0ID0gcmVxdWlyZSgnLi9YTUxUZXh0Jyk7XG5cbiAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gcmVxdWlyZSgnLi9YTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24nKTtcblxuICBYTUxEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vWE1MRGVjbGFyYXRpb24nKTtcblxuICBYTUxEb2NUeXBlID0gcmVxdWlyZSgnLi9YTUxEb2NUeXBlJyk7XG5cbiAgWE1MRFREQXR0TGlzdCA9IHJlcXVpcmUoJy4vWE1MRFREQXR0TGlzdCcpO1xuXG4gIFhNTERUREVudGl0eSA9IHJlcXVpcmUoJy4vWE1MRFRERW50aXR5Jyk7XG5cbiAgWE1MRFRERWxlbWVudCA9IHJlcXVpcmUoJy4vWE1MRFRERWxlbWVudCcpO1xuXG4gIFhNTERURE5vdGF0aW9uID0gcmVxdWlyZSgnLi9YTUxEVEROb3RhdGlvbicpO1xuXG4gIFhNTEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vWE1MQXR0cmlidXRlJyk7XG5cbiAgWE1MU3RyaW5naWZpZXIgPSByZXF1aXJlKCcuL1hNTFN0cmluZ2lmaWVyJyk7XG5cbiAgWE1MU3RyaW5nV3JpdGVyID0gcmVxdWlyZSgnLi9YTUxTdHJpbmdXcml0ZXInKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERvY3VtZW50Q0IgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MRG9jdW1lbnRDQihvcHRpb25zLCBvbkRhdGEsIG9uRW5kKSB7XG4gICAgICB2YXIgd3JpdGVyT3B0aW9ucztcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICBpZiAoIW9wdGlvbnMud3JpdGVyKSB7XG4gICAgICAgIG9wdGlvbnMud3JpdGVyID0gbmV3IFhNTFN0cmluZ1dyaXRlcihvcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChvcHRpb25zLndyaXRlcikpIHtcbiAgICAgICAgd3JpdGVyT3B0aW9ucyA9IG9wdGlvbnMud3JpdGVyO1xuICAgICAgICBvcHRpb25zLndyaXRlciA9IG5ldyBYTUxTdHJpbmdXcml0ZXIod3JpdGVyT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy53cml0ZXIgPSBvcHRpb25zLndyaXRlcjtcbiAgICAgIHRoaXMuc3RyaW5naWZ5ID0gbmV3IFhNTFN0cmluZ2lmaWVyKG9wdGlvbnMpO1xuICAgICAgdGhpcy5vbkRhdGFDYWxsYmFjayA9IG9uRGF0YSB8fCBmdW5jdGlvbigpIHt9O1xuICAgICAgdGhpcy5vbkVuZENhbGxiYWNrID0gb25FbmQgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSAtMTtcbiAgICAgIHRoaXMub3BlblRhZ3MgPSB7fTtcbiAgICAgIHRoaXMuZG9jdW1lbnRTdGFydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmRvY3VtZW50Q29tcGxldGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgIH1cblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICB2YXIgcmVmMTtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBub2RlIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yb290ICYmIHRoaXMuY3VycmVudExldmVsID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb2N1bWVudCBjYW4gb25seSBoYXZlIG9uZSByb290IG5vZGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLm9wZW5DdXJyZW50KCk7XG4gICAgICBuYW1lID0gbmFtZS52YWx1ZU9mKCk7XG4gICAgICBpZiAoYXR0cmlidXRlcyA9PSBudWxsKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnZhbHVlT2YoKTtcbiAgICAgIGlmICghaXNPYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgICAgcmVmMSA9IFthdHRyaWJ1dGVzLCB0ZXh0XSwgdGV4dCA9IHJlZjFbMF0sIGF0dHJpYnV0ZXMgPSByZWYxWzFdO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5ldyBYTUxFbGVtZW50KHRoaXMsIG5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgdGhpcy5jdXJyZW50Tm9kZS5jaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5jdXJyZW50TGV2ZWwrKztcbiAgICAgIHRoaXMub3BlblRhZ3NbdGhpcy5jdXJyZW50TGV2ZWxdID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICAgIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy50ZXh0KHRleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSAmJiB0aGlzLmN1cnJlbnROb2RlIGluc3RhbmNlb2YgWE1MRG9jVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kdGRFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5hdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGF0dE5hbWUsIGF0dFZhbHVlO1xuICAgICAgaWYgKCF0aGlzLmN1cnJlbnROb2RlIHx8IHRoaXMuY3VycmVudE5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbW1lZGlhdGVseSBhZnRlciBhbiBlbGUoKSBjYWxsIGluIGNhbGxiYWNrIG1vZGVcIik7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgICBmb3IgKGF0dE5hbWUgaW4gbmFtZSkge1xuICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKG5hbWUsIGF0dE5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICBhdHRWYWx1ZSA9IG5hbWVbYXR0TmFtZV07XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGUoYXR0TmFtZSwgYXR0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2tpcE51bGxBdHRyaWJ1dGVzIHx8ICh2YWx1ZSAhPSBudWxsKSkge1xuICAgICAgICAgIHRoaXMuY3VycmVudE5vZGUuYXR0cmlidXRlc1tuYW1lXSA9IG5ldyBYTUxBdHRyaWJ1dGUodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MVGV4dCh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci50ZXh0KG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmNkYXRhID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxDRGF0YSh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5jZGF0YShub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5jb21tZW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxDb21tZW50KHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmNvbW1lbnQobm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxSYXcodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIucmF3KG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmluc3RydWN0aW9uID0gZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgdmFyIGksIGluc1RhcmdldCwgaW5zVmFsdWUsIGxlbiwgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRhcmdldC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGluc1RhcmdldCA9IHRhcmdldFtpXTtcbiAgICAgICAgICB0aGlzLmluc3RydWN0aW9uKGluc1RhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICBmb3IgKGluc1RhcmdldCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbCh0YXJnZXQsIGluc1RhcmdldCkpIGNvbnRpbnVlO1xuICAgICAgICAgIGluc1ZhbHVlID0gdGFyZ2V0W2luc1RhcmdldF07XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbihpbnNUYXJnZXQsIGluc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBuZXcgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uKHRoaXMsIHRhcmdldCwgdmFsdWUpO1xuICAgICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZGVjbGFyYXRpb24gPSBmdW5jdGlvbih2ZXJzaW9uLCBlbmNvZGluZywgc3RhbmRhbG9uZSkge1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB0aGlzLm9wZW5DdXJyZW50KCk7XG4gICAgICBpZiAodGhpcy5kb2N1bWVudFN0YXJ0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVjbGFyYXRpb24oKSBtdXN0IGJlIHRoZSBmaXJzdCBub2RlXCIpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5ldyBYTUxEZWNsYXJhdGlvbih0aGlzLCB2ZXJzaW9uLCBlbmNvZGluZywgc3RhbmRhbG9uZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5kZWNsYXJhdGlvbihub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5kb2N0eXBlID0gZnVuY3Rpb24ocm9vdCwgcHViSUQsIHN5c0lEKSB7XG4gICAgICB0aGlzLm9wZW5DdXJyZW50KCk7XG4gICAgICBpZiAocm9vdCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgcm9vdCBub2RlIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImR0ZCgpIG11c3QgY29tZSBiZWZvcmUgdGhlIHJvb3Qgbm9kZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBuZXcgWE1MRG9jVHlwZSh0aGlzLCBwdWJJRCwgc3lzSUQpO1xuICAgICAgdGhpcy5jdXJyZW50Tm9kZS5yb290Tm9kZU5hbWUgPSByb290O1xuICAgICAgdGhpcy5jdXJyZW50Tm9kZS5jaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5jdXJyZW50TGV2ZWwrKztcbiAgICAgIHRoaXMub3BlblRhZ3NbdGhpcy5jdXJyZW50TGV2ZWxdID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5kdGRFbGVtZW50ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxEVERFbGVtZW50KHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmR0ZEVsZW1lbnQobm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuYXR0TGlzdCA9IGZ1bmN0aW9uKGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxEVERBdHRMaXN0KHRoaXMsIGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuZHRkQXR0TGlzdChub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5lbnRpdHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB0aGlzLm9wZW5DdXJyZW50KCk7XG4gICAgICBub2RlID0gbmV3IFhNTERUREVudGl0eSh0aGlzLCBmYWxzZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuZHRkRW50aXR5KG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnBFbnRpdHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB0aGlzLm9wZW5DdXJyZW50KCk7XG4gICAgICBub2RlID0gbmV3IFhNTERUREVudGl0eSh0aGlzLCB0cnVlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5kdGRFbnRpdHkobm9kZSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUubm90YXRpb24gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB0aGlzLm9wZW5DdXJyZW50KCk7XG4gICAgICBub2RlID0gbmV3IFhNTERURE5vdGF0aW9uKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmR0ZE5vdGF0aW9uKG5vZGUsIHRoaXMuY3VycmVudExldmVsICsgMSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWwgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBkb2N1bWVudCBub2RlIGhhcyBubyBwYXJlbnRcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIHRoaXMuY2xvc2VOb2RlKHRoaXMuY3VycmVudE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3Blbk5vZGUodGhpcy5jdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsb3NlTm9kZSh0aGlzLm9wZW5UYWdzW3RoaXMuY3VycmVudExldmVsXSk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5vcGVuVGFnc1t0aGlzLmN1cnJlbnRMZXZlbF07XG4gICAgICB0aGlzLmN1cnJlbnRMZXZlbC0tO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgd2hpbGUgKHRoaXMuY3VycmVudExldmVsID49IDApIHtcbiAgICAgICAgdGhpcy51cCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMub25FbmQoKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUub3BlbkN1cnJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUuY2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuTm9kZSh0aGlzLmN1cnJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUub3Blbk5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAoIW5vZGUuaXNPcGVuKSB7XG4gICAgICAgIGlmICghdGhpcy5yb290ICYmIHRoaXMuY3VycmVudExldmVsID09PSAwICYmIG5vZGUgaW5zdGFuY2VvZiBYTUxFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5yb290ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5vcGVuTm9kZShub2RlLCB0aGlzLmN1cnJlbnRMZXZlbCkpO1xuICAgICAgICByZXR1cm4gbm9kZS5pc09wZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5jbG9zZU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAoIW5vZGUuaXNDbG9zZWQpIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuY2xvc2VOb2RlKG5vZGUsIHRoaXMuY3VycmVudExldmVsKSk7XG4gICAgICAgIHJldHVybiBub2RlLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIHRoaXMuZG9jdW1lbnRTdGFydGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLm9uRGF0YUNhbGxiYWNrKGNodW5rKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9jdW1lbnRDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMub25FbmRDYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5lbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUubm9kID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUudHh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5kYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2RhdGEodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5jb20gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tbWVudCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmlucyA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5kZWMgPSBmdW5jdGlvbih2ZXJzaW9uLCBlbmNvZGluZywgc3RhbmRhbG9uZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyYXRpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5kdGQgPSBmdW5jdGlvbihyb290LCBwdWJJRCwgc3lzSUQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3R5cGUocm9vdCwgcHViSUQsIHN5c0lEKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLm4gPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5kID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNkYXRhKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21tZW50KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUuciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYXcodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5pID0gZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb24odGFyZ2V0LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmF0dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUgJiYgdGhpcy5jdXJyZW50Tm9kZSBpbnN0YW5jZW9mIFhNTERvY1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0TGlzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFhNTERvY3VtZW50Q0IucHJvdG90eXBlLmEgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlICYmIHRoaXMuY3VycmVudE5vZGUgaW5zdGFuY2VvZiBYTUxEb2NUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dExpc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBYTUxEb2N1bWVudENCLnByb3RvdHlwZS5lbnQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50aXR5KG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUucGVudCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wRW50aXR5KG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jdW1lbnRDQi5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdGF0aW9uKG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTERvY3VtZW50Q0I7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxBdHRyaWJ1dGUsIFhNTEVsZW1lbnQsIFhNTE5vZGUsIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCByZWYsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICByZWYgPSByZXF1aXJlKCcuL1V0aWxpdHknKSwgaXNPYmplY3QgPSByZWYuaXNPYmplY3QsIGlzRnVuY3Rpb24gPSByZWYuaXNGdW5jdGlvbjtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgWE1MQXR0cmlidXRlID0gcmVxdWlyZSgnLi9YTUxBdHRyaWJ1dGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTEVsZW1lbnQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxFbGVtZW50LCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTEVsZW1lbnQocGFyZW50LCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICBYTUxFbGVtZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZWxlbWVudCBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5uYW1lID0gdGhpcy5zdHJpbmdpZnkuZWxlTmFtZShuYW1lKTtcbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZShhdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuaXNEb2N1bWVudCkge1xuICAgICAgICB0aGlzLmlzUm9vdCA9IHRydWU7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRPYmplY3QgPSBwYXJlbnQ7XG4gICAgICAgIHBhcmVudC5yb290T2JqZWN0ID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF0dCwgYXR0TmFtZSwgY2xvbmVkU2VsZiwgcmVmMTtcbiAgICAgIGNsb25lZFNlbGYgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgaWYgKGNsb25lZFNlbGYuaXNSb290KSB7XG4gICAgICAgIGNsb25lZFNlbGYuZG9jdW1lbnRPYmplY3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgY2xvbmVkU2VsZi5hdHRyaWJ1dGVzID0ge307XG4gICAgICByZWYxID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgZm9yIChhdHROYW1lIGluIHJlZjEpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmMSwgYXR0TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBhdHQgPSByZWYxW2F0dE5hbWVdO1xuICAgICAgICBjbG9uZWRTZWxmLmF0dHJpYnV0ZXNbYXR0TmFtZV0gPSBhdHQuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIGNsb25lZFNlbGYuY2hpbGRyZW4gPSBbXTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgY2xvbmVkQ2hpbGQ7XG4gICAgICAgIGNsb25lZENoaWxkID0gY2hpbGQuY2xvbmUoKTtcbiAgICAgICAgY2xvbmVkQ2hpbGQucGFyZW50ID0gY2xvbmVkU2VsZjtcbiAgICAgICAgcmV0dXJuIGNsb25lZFNlbGYuY2hpbGRyZW4ucHVzaChjbG9uZWRDaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjbG9uZWRTZWxmO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5hdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGF0dE5hbWUsIGF0dFZhbHVlO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICBuYW1lID0gbmFtZS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgZm9yIChhdHROYW1lIGluIG5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChuYW1lLCBhdHROYW1lKSkgY29udGludWU7XG4gICAgICAgICAgYXR0VmFsdWUgPSBuYW1lW2F0dE5hbWVdO1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlKGF0dE5hbWUsIGF0dFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNraXBOdWxsQXR0cmlidXRlcyB8fCAodmFsdWUgIT0gbnVsbCkpIHtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSBuZXcgWE1MQXR0cmlidXRlKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBhdHROYW1lLCBpLCBsZW47XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXR0cmlidXRlIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBuYW1lID0gbmFtZS52YWx1ZU9mKCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBuYW1lLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgYXR0TmFtZSA9IG5hbWVbaV07XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1thdHROYW1lXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5lbGVtZW50KHRoaXMpO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5hdHQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUuYSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRWxlbWVudDtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxDRGF0YSwgWE1MQ29tbWVudCwgWE1MRGVjbGFyYXRpb24sIFhNTERvY1R5cGUsIFhNTEVsZW1lbnQsIFhNTE5vZGUsIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgWE1MUmF3LCBYTUxUZXh0LCBpc0VtcHR5LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcmVmLFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICByZWYgPSByZXF1aXJlKCcuL1V0aWxpdHknKSwgaXNPYmplY3QgPSByZWYuaXNPYmplY3QsIGlzRnVuY3Rpb24gPSByZWYuaXNGdW5jdGlvbiwgaXNFbXB0eSA9IHJlZi5pc0VtcHR5O1xuXG4gIFhNTEVsZW1lbnQgPSBudWxsO1xuXG4gIFhNTENEYXRhID0gbnVsbDtcblxuICBYTUxDb21tZW50ID0gbnVsbDtcblxuICBYTUxEZWNsYXJhdGlvbiA9IG51bGw7XG5cbiAgWE1MRG9jVHlwZSA9IG51bGw7XG5cbiAgWE1MUmF3ID0gbnVsbDtcblxuICBYTUxUZXh0ID0gbnVsbDtcblxuICBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSBudWxsO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MTm9kZSA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBYTUxOb2RlKHBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5wYXJlbnQub3B0aW9ucztcbiAgICAgICAgdGhpcy5zdHJpbmdpZnkgPSB0aGlzLnBhcmVudC5zdHJpbmdpZnk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICBpZiAoIVhNTEVsZW1lbnQpIHtcbiAgICAgICAgWE1MRWxlbWVudCA9IHJlcXVpcmUoJy4vWE1MRWxlbWVudCcpO1xuICAgICAgICBYTUxDRGF0YSA9IHJlcXVpcmUoJy4vWE1MQ0RhdGEnKTtcbiAgICAgICAgWE1MQ29tbWVudCA9IHJlcXVpcmUoJy4vWE1MQ29tbWVudCcpO1xuICAgICAgICBYTUxEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vWE1MRGVjbGFyYXRpb24nKTtcbiAgICAgICAgWE1MRG9jVHlwZSA9IHJlcXVpcmUoJy4vWE1MRG9jVHlwZScpO1xuICAgICAgICBYTUxSYXcgPSByZXF1aXJlKCcuL1hNTFJhdycpO1xuICAgICAgICBYTUxUZXh0ID0gcmVxdWlyZSgnLi9YTUxUZXh0Jyk7XG4gICAgICAgIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHZhciBjaGlsZE5vZGUsIGl0ZW0sIGosIGssIGtleSwgbGFzdENoaWxkLCBsZW4sIGxlbjEsIHJlZjEsIHZhbDtcbiAgICAgIGxhc3RDaGlsZCA9IG51bGw7XG4gICAgICBpZiAoYXR0cmlidXRlcyA9PSBudWxsKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnZhbHVlT2YoKTtcbiAgICAgIGlmICghaXNPYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgICAgcmVmMSA9IFthdHRyaWJ1dGVzLCB0ZXh0XSwgdGV4dCA9IHJlZjFbMF0sIGF0dHJpYnV0ZXMgPSByZWYxWzFdO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICBuYW1lID0gbmFtZS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSBuYW1lLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgaXRlbSA9IG5hbWVbal07XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5lbGVtZW50KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24obmFtZSkpIHtcbiAgICAgICAgbGFzdENoaWxkID0gdGhpcy5lbGVtZW50KG5hbWUuYXBwbHkoKSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgIGZvciAoa2V5IGluIG5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChuYW1lLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICB2YWwgPSBuYW1lW2tleV07XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLmFwcGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoaXNPYmplY3QodmFsKSkgJiYgKGlzRW1wdHkodmFsKSkpIHtcbiAgICAgICAgICAgIHZhbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydEF0dEtleSAmJiBrZXkuaW5kZXhPZih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0QXR0S2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5hdHRyaWJ1dGUoa2V5LnN1YnN0cih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0QXR0S2V5Lmxlbmd0aCksIHZhbCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLnNlcGFyYXRlQXJyYXlJdGVtcyAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAoayA9IDAsIGxlbjEgPSB2YWwubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgICAgICAgIGl0ZW0gPSB2YWxba107XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IHt9O1xuICAgICAgICAgICAgICBjaGlsZE5vZGVba2V5XSA9IGl0ZW07XG4gICAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5lbGVtZW50KGtleSk7XG4gICAgICAgICAgICBsYXN0Q2hpbGQuZWxlbWVudCh2YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmVsZW1lbnQoa2V5LCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0VGV4dEtleSAmJiBuYW1lLmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydFRleHRLZXkpID09PSAwKSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy50ZXh0KHRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0Q0RhdGFLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRDRGF0YUtleSkgPT09IDApIHtcbiAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmNkYXRhKHRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0Q29tbWVudEtleSAmJiBuYW1lLmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydENvbW1lbnRLZXkpID09PSAwKSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5jb21tZW50KHRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UmF3S2V5ICYmIG5hbWUuaW5kZXhPZih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UmF3S2V5KSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMucmF3KHRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UElLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRQSUtleSkgPT09IDApIHtcbiAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmluc3RydWN0aW9uKG5hbWUuc3Vic3RyKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRQSUtleS5sZW5ndGgpLCB0ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLm5vZGUobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0Q2hpbGQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY3JlYXRlIGFueSBlbGVtZW50cyB3aXRoOiBcIiArIG5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RDaGlsZDtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgdmFyIGNoaWxkLCBpLCByZW1vdmVkO1xuICAgICAgaWYgKHRoaXMuaXNSb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbnNlcnQgZWxlbWVudHMgYXQgcm9vdCBsZXZlbFwiKTtcbiAgICAgIH1cbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpKTtcbiAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCByZW1vdmVkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICB2YXIgY2hpbGQsIGksIHJlbW92ZWQ7XG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluc2VydCBlbGVtZW50cyBhdCByb290IGxldmVsXCIpO1xuICAgICAgfVxuICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICByZW1vdmVkID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGkgKyAxKTtcbiAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCByZW1vdmVkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgcmVmMTtcbiAgICAgIGlmICh0aGlzLmlzUm9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVtb3ZlIHRoZSByb290IGVsZW1lbnRcIik7XG4gICAgICB9XG4gICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIFtdLnNwbGljZS5hcHBseSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgW2ksIGkgLSBpICsgMV0uY29uY2F0KHJlZjEgPSBbXSkpLCByZWYxO1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgdmFyIGNoaWxkLCByZWYxO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICBuYW1lID0gbmFtZS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzIHx8IChhdHRyaWJ1dGVzID0ge30pO1xuICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMudmFsdWVPZigpO1xuICAgICAgaWYgKCFpc09iamVjdChhdHRyaWJ1dGVzKSkge1xuICAgICAgICByZWYxID0gW2F0dHJpYnV0ZXMsIHRleHRdLCB0ZXh0ID0gcmVmMVswXSwgYXR0cmlidXRlcyA9IHJlZjFbMV07XG4gICAgICB9XG4gICAgICBjaGlsZCA9IG5ldyBYTUxFbGVtZW50KHRoaXMsIG5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgICAgICBjaGlsZC50ZXh0KHRleHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBjaGlsZCA9IG5ldyBYTUxUZXh0KHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuY2RhdGEgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MQ0RhdGEodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5jb21tZW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTENvbW1lbnQodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5jb21tZW50QmVmb3JlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpKTtcbiAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuY29tbWVudCh2YWx1ZSk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgcmVtb3ZlZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuY29tbWVudEFmdGVyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpICsgMSk7XG4gICAgICBjaGlsZCA9IHRoaXMucGFyZW50LmNvbW1lbnQodmFsdWUpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5wYXJlbnQuY2hpbGRyZW4sIHJlbW92ZWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBjaGlsZCA9IG5ldyBYTUxSYXcodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5pbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHZhciBpbnNUYXJnZXQsIGluc1ZhbHVlLCBpbnN0cnVjdGlvbiwgaiwgbGVuO1xuICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gdGFyZ2V0Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgaW5zVGFyZ2V0ID0gdGFyZ2V0W2pdO1xuICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24oaW5zVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIGZvciAoaW5zVGFyZ2V0IGluIHRhcmdldCkge1xuICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHRhcmdldCwgaW5zVGFyZ2V0KSkgY29udGludWU7XG4gICAgICAgICAgaW5zVmFsdWUgPSB0YXJnZXRbaW5zVGFyZ2V0XTtcbiAgICAgICAgICB0aGlzLmluc3RydWN0aW9uKGluc1RhcmdldCwgaW5zVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdHJ1Y3Rpb24gPSBuZXcgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uKHRoaXMsIHRhcmdldCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmluc3RydWN0aW9uQmVmb3JlID0gZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkLCBpLCByZW1vdmVkO1xuICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICByZW1vdmVkID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGkpO1xuICAgICAgY2hpbGQgPSB0aGlzLnBhcmVudC5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCByZW1vdmVkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5pbnN0cnVjdGlvbkFmdGVyID0gZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkLCBpLCByZW1vdmVkO1xuICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICByZW1vdmVkID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGkgKyAxKTtcbiAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuaW5zdHJ1Y3Rpb24odGFyZ2V0LCB2YWx1ZSk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgcmVtb3ZlZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZGVjbGFyYXRpb24gPSBmdW5jdGlvbih2ZXJzaW9uLCBlbmNvZGluZywgc3RhbmRhbG9uZSkge1xuICAgICAgdmFyIGRvYywgeG1sZGVjO1xuICAgICAgZG9jID0gdGhpcy5kb2N1bWVudCgpO1xuICAgICAgeG1sZGVjID0gbmV3IFhNTERlY2xhcmF0aW9uKGRvYywgdmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpO1xuICAgICAgaWYgKGRvYy5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFhNTERlY2xhcmF0aW9uKSB7XG4gICAgICAgIGRvYy5jaGlsZHJlblswXSA9IHhtbGRlYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvYy5jaGlsZHJlbi51bnNoaWZ0KHhtbGRlYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9jLnJvb3QoKSB8fCBkb2M7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmRvY3R5cGUgPSBmdW5jdGlvbihwdWJJRCwgc3lzSUQpIHtcbiAgICAgIHZhciBjaGlsZCwgZG9jLCBkb2N0eXBlLCBpLCBqLCBrLCBsZW4sIGxlbjEsIHJlZjEsIHJlZjI7XG4gICAgICBkb2MgPSB0aGlzLmRvY3VtZW50KCk7XG4gICAgICBkb2N0eXBlID0gbmV3IFhNTERvY1R5cGUoZG9jLCBwdWJJRCwgc3lzSUQpO1xuICAgICAgcmVmMSA9IGRvYy5jaGlsZHJlbjtcbiAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuICAgICAgICBjaGlsZCA9IHJlZjFbaV07XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFhNTERvY1R5cGUpIHtcbiAgICAgICAgICBkb2MuY2hpbGRyZW5baV0gPSBkb2N0eXBlO1xuICAgICAgICAgIHJldHVybiBkb2N0eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWYyID0gZG9jLmNoaWxkcmVuO1xuICAgICAgZm9yIChpID0gayA9IDAsIGxlbjEgPSByZWYyLmxlbmd0aDsgayA8IGxlbjE7IGkgPSArK2spIHtcbiAgICAgICAgY2hpbGQgPSByZWYyW2ldO1xuICAgICAgICBpZiAoY2hpbGQuaXNSb290KSB7XG4gICAgICAgICAgZG9jLmNoaWxkcmVuLnNwbGljZShpLCAwLCBkb2N0eXBlKTtcbiAgICAgICAgICByZXR1cm4gZG9jdHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9jLmNoaWxkcmVuLnB1c2goZG9jdHlwZSk7XG4gICAgICByZXR1cm4gZG9jdHlwZTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzUm9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcm9vdCBub2RlIGhhcyBubyBwYXJlbnQuIFVzZSBkb2MoKSBpZiB5b3UgbmVlZCB0byBnZXQgdGhlIGRvY3VtZW50IG9iamVjdC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgbm9kZSA9IHRoaXM7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5pc0RvY3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucm9vdE9iamVjdDtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzUm9vdCkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGU7XG4gICAgICBub2RlID0gdGhpcztcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmlzRG9jdW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQoKS5lbmQob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpO1xuICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICBpZiAoaSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBhdCB0aGUgZmlyc3Qgbm9kZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlbltpIC0gMV07XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpO1xuICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICBpZiAoaSA9PT0gLTEgfHwgaSA9PT0gdGhpcy5wYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IGF0IHRoZSBsYXN0IG5vZGVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGRyZW5baSArIDFdO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5pbXBvcnREb2N1bWVudCA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgdmFyIGNsb25lZFJvb3Q7XG4gICAgICBjbG9uZWRSb290ID0gZG9jLnJvb3QoKS5jbG9uZSgpO1xuICAgICAgY2xvbmVkUm9vdC5wYXJlbnQgPSB0aGlzO1xuICAgICAgY2xvbmVkUm9vdC5pc1Jvb3QgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjbG9uZWRSb290KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5lbGUgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5ub2QgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS50eHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmRhdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jZGF0YSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmNvbSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21tZW50KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW5zID0gZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb24odGFyZ2V0LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmRvYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQoKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZGVjID0gZnVuY3Rpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9uKHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZHRkID0gZnVuY3Rpb24ocHViSUQsIHN5c0lEKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N0eXBlKHB1YklELCBzeXNJRCk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmUgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5uID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jZGF0YSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tbWVudCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLnIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmF3KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaSA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS51ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy51cCgpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5pbXBvcnRYTUxCdWlsZGVyID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbXBvcnREb2N1bWVudChkb2MpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MTm9kZTtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTE5vZGUsIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbixcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ocGFyZW50LCB0YXJnZXQsIHZhbHVlKSB7XG4gICAgICBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGluc3RydWN0aW9uIHRhcmdldFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5zdHJpbmdpZnkuaW5zVGFyZ2V0KHRhcmdldCk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3RyaW5naWZ5Lmluc1ZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24odGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb247XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MTm9kZSwgWE1MUmF3LFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MUmF3ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MUmF3LCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTFJhdyhwYXJlbnQsIHRleHQpIHtcbiAgICAgIFhNTFJhdy5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJhdyB0ZXh0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3RyaW5naWZ5LnJhdyh0ZXh0KTtcbiAgICB9XG5cbiAgICBYTUxSYXcucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MUmF3LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnNldChvcHRpb25zKS5yYXcodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxSYXc7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ0RhdGEsIFhNTENvbW1lbnQsIFhNTERUREF0dExpc3QsIFhNTERUREVsZW1lbnQsIFhNTERUREVudGl0eSwgWE1MRFRETm90YXRpb24sIFhNTERlY2xhcmF0aW9uLCBYTUxEb2NUeXBlLCBYTUxFbGVtZW50LCBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIFhNTFJhdywgWE1MU3RyZWFtV3JpdGVyLCBYTUxUZXh0LCBYTUxXcml0ZXJCYXNlLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgWE1MRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL1hNTERlY2xhcmF0aW9uJyk7XG5cbiAgWE1MRG9jVHlwZSA9IHJlcXVpcmUoJy4vWE1MRG9jVHlwZScpO1xuXG4gIFhNTENEYXRhID0gcmVxdWlyZSgnLi9YTUxDRGF0YScpO1xuXG4gIFhNTENvbW1lbnQgPSByZXF1aXJlKCcuL1hNTENvbW1lbnQnKTtcblxuICBYTUxFbGVtZW50ID0gcmVxdWlyZSgnLi9YTUxFbGVtZW50Jyk7XG5cbiAgWE1MUmF3ID0gcmVxdWlyZSgnLi9YTUxSYXcnKTtcblxuICBYTUxUZXh0ID0gcmVxdWlyZSgnLi9YTUxUZXh0Jyk7XG5cbiAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gcmVxdWlyZSgnLi9YTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24nKTtcblxuICBYTUxEVERBdHRMaXN0ID0gcmVxdWlyZSgnLi9YTUxEVERBdHRMaXN0Jyk7XG5cbiAgWE1MRFRERWxlbWVudCA9IHJlcXVpcmUoJy4vWE1MRFRERWxlbWVudCcpO1xuXG4gIFhNTERUREVudGl0eSA9IHJlcXVpcmUoJy4vWE1MRFRERW50aXR5Jyk7XG5cbiAgWE1MRFRETm90YXRpb24gPSByZXF1aXJlKCcuL1hNTERURE5vdGF0aW9uJyk7XG5cbiAgWE1MV3JpdGVyQmFzZSA9IHJlcXVpcmUoJy4vWE1MV3JpdGVyQmFzZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MU3RyZWFtV3JpdGVyID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MU3RyZWFtV3JpdGVyLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTFN0cmVhbVdyaXRlcihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICAgIFhNTFN0cmVhbVdyaXRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgIH1cblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZG9jdW1lbnQgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgaiwgbGVuLCBsZW4xLCByZWYsIHJlZjEsIHJlc3VsdHM7XG4gICAgICByZWYgPSBkb2MuY2hpbGRyZW47XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICAgIGNoaWxkLmlzTGFzdFJvb3ROb2RlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBkb2MuY2hpbGRyZW5bZG9jLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmlzTGFzdFJvb3ROb2RlID0gdHJ1ZTtcbiAgICAgIHJlZjEgPSBkb2MuY2hpbGRyZW47XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICBmb3IgKGogPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgY2hpbGQgPSByZWYxW2pdO1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MRGVjbGFyYXRpb24pOlxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZGVjbGFyYXRpb24oY2hpbGQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERvY1R5cGUpOlxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZG9jVHlwZShjaGlsZCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MQ29tbWVudCk6XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5jb21tZW50KGNoaWxkKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24pOlxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucHJvY2Vzc2luZ0luc3RydWN0aW9uKGNoaWxkKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZWxlbWVudChjaGlsZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgWE1MU3RyZWFtV3JpdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGUgPSBmdW5jdGlvbihhdHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSgnICcgKyBhdHQubmFtZSArICc9XCInICsgYXR0LnZhbHVlICsgJ1wiJyk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuY2RhdGEgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhW0NEQVRBWycgKyBub2RlLnRleHQgKyAnXV0+JyArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuY29tbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZShsZXZlbCkgKyAnPCEtLSAnICsgbm9kZS50ZXh0ICsgJyAtLT4nICsgdGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyZWFtV3JpdGVyLnByb3RvdHlwZS5kZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSk7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSgnPD94bWwgdmVyc2lvbj1cIicgKyBub2RlLnZlcnNpb24gKyAnXCInKTtcbiAgICAgIGlmIChub2RlLmVuY29kaW5nICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBlbmNvZGluZz1cIicgKyBub2RlLmVuY29kaW5nICsgJ1wiJyk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5zdGFuZGFsb25lICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBzdGFuZGFsb25lPVwiJyArIG5vZGUuc3RhbmRhbG9uZSArICdcIicpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz8+Jyk7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyZWFtV3JpdGVyLnByb3RvdHlwZS5kb2NUeXBlID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByZWY7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2UobGV2ZWwpKTtcbiAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCc8IURPQ1RZUEUgJyArIG5vZGUucm9vdCgpLm5hbWUpO1xuICAgICAgaWYgKG5vZGUucHViSUQgJiYgbm9kZS5zeXNJRCkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5zeXNJRCkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFNZU1RFTSBcIicgKyBub2RlLnN5c0lEICsgJ1wiJyk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgWycpO1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLmVuZGxpbmUobm9kZSkpO1xuICAgICAgICByZWYgPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IHJlZltpXTtcbiAgICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEVERBdHRMaXN0KTpcbiAgICAgICAgICAgICAgdGhpcy5kdGRBdHRMaXN0KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERUREVsZW1lbnQpOlxuICAgICAgICAgICAgICB0aGlzLmR0ZEVsZW1lbnQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MRFRERW50aXR5KTpcbiAgICAgICAgICAgICAgdGhpcy5kdGRFbnRpdHkoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MRFRETm90YXRpb24pOlxuICAgICAgICAgICAgICB0aGlzLmR0ZE5vdGF0aW9uKGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENEYXRhKTpcbiAgICAgICAgICAgICAgdGhpcy5jZGF0YShjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxDb21tZW50KTpcbiAgICAgICAgICAgICAgdGhpcy5jb21tZW50KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbik6XG4gICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ0luc3RydWN0aW9uKGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gRFREIG5vZGUgdHlwZTogXCIgKyBjaGlsZC5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJ10nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICc+Jyk7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyZWFtV3JpdGVyLnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHZhciBhdHQsIGNoaWxkLCBpLCBsZW4sIG5hbWUsIHJlZiwgcmVmMSwgc3BhY2U7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIHNwYWNlID0gdGhpcy5zcGFjZShsZXZlbCk7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZShzcGFjZSArICc8JyArIG5vZGUubmFtZSk7XG4gICAgICByZWYgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwgbmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBhdHQgPSByZWZbbmFtZV07XG4gICAgICAgIHRoaXMuYXR0cmlidXRlKGF0dCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgbm9kZS5jaGlsZHJlbi5ldmVyeShmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLnZhbHVlID09PSAnJztcbiAgICAgIH0pKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93RW1wdHkpIHtcbiAgICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnPjwvJyArIG5vZGUubmFtZSArICc+Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJy8+Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV0dHkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgKG5vZGUuY2hpbGRyZW5bMF0udmFsdWUgIT0gbnVsbCkpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJz4nKTtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUobm9kZS5jaGlsZHJlblswXS52YWx1ZSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCc8LycgKyBub2RlLm5hbWUgKyAnPicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJz4nICsgdGhpcy5uZXdsaW5lKTtcbiAgICAgICAgcmVmMSA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IHJlZjFbaV07XG4gICAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MQ0RhdGEpOlxuICAgICAgICAgICAgICB0aGlzLmNkYXRhKGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENvbW1lbnQpOlxuICAgICAgICAgICAgICB0aGlzLmNvbW1lbnQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MRWxlbWVudCk6XG4gICAgICAgICAgICAgIHRoaXMuZWxlbWVudChjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxSYXcpOlxuICAgICAgICAgICAgICB0aGlzLnJhdyhjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxUZXh0KTpcbiAgICAgICAgICAgICAgdGhpcy50ZXh0KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbik6XG4gICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ0luc3RydWN0aW9uKGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gWE1MIG5vZGUgdHlwZTogXCIgKyBjaGlsZC5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoc3BhY2UgKyAnPC8nICsgbm9kZS5uYW1lICsgJz4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLmVuZGxpbmUobm9kZSkpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLnByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArICc8PycgKyBub2RlLnRhcmdldCk7XG4gICAgICBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnICcgKyBub2RlLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPz4nICsgdGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyZWFtV3JpdGVyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2UobGV2ZWwpICsgbm9kZS52YWx1ZSArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZShsZXZlbCkgKyBub2RlLnZhbHVlICsgdGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyZWFtV3JpdGVyLnByb3RvdHlwZS5kdGRBdHRMaXN0ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhQVRUTElTVCAnICsgbm9kZS5lbGVtZW50TmFtZSArICcgJyArIG5vZGUuYXR0cmlidXRlTmFtZSArICcgJyArIG5vZGUuYXR0cmlidXRlVHlwZSk7XG4gICAgICBpZiAobm9kZS5kZWZhdWx0VmFsdWVUeXBlICE9PSAnI0RFRkFVTFQnKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgJyArIG5vZGUuZGVmYXVsdFZhbHVlVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBcIicgKyBub2RlLmRlZmF1bHRWYWx1ZSArICdcIicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICc+JyArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZHRkRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlKGxldmVsKSArICc8IUVMRU1FTlQgJyArIG5vZGUubmFtZSArICcgJyArIG5vZGUudmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICc+JyArIHRoaXMuZW5kbGluZShub2RlKSk7XG4gICAgfTtcblxuICAgIFhNTFN0cmVhbVdyaXRlci5wcm90b3R5cGUuZHRkRW50aXR5ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhRU5USVRZJyk7XG4gICAgICBpZiAobm9kZS5wZSkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnICUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgJyArIG5vZGUubmFtZSk7XG4gICAgICBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFwiJyArIG5vZGUudmFsdWUgKyAnXCInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlLnB1YklEICYmIG5vZGUuc3lzSUQpIHtcbiAgICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnN5c0lEKSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBTWVNURU0gXCInICsgbm9kZS5zeXNJRCArICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm5EYXRhKSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBOREFUQSAnICsgbm9kZS5uRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicgKyB0aGlzLmVuZGxpbmUobm9kZSkpO1xuICAgIH07XG5cbiAgICBYTUxTdHJlYW1Xcml0ZXIucHJvdG90eXBlLmR0ZE5vdGF0aW9uID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhTk9UQVRJT04gJyArIG5vZGUubmFtZSk7XG4gICAgICBpZiAobm9kZS5wdWJJRCAmJiBub2RlLnN5c0lEKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgUFVCTElDIFwiJyArIG5vZGUucHViSUQgKyAnXCIgXCInICsgbm9kZS5zeXNJRCArICdcIicpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnB1YklEKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCcgUFVCTElDIFwiJyArIG5vZGUucHViSUQgKyAnXCInKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5zeXNJRCkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFNZU1RFTSBcIicgKyBub2RlLnN5c0lEICsgJ1wiJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5zcGFjZWJlZm9yZXNsYXNoICsgJz4nICsgdGhpcy5lbmRsaW5lKG5vZGUpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyZWFtV3JpdGVyLnByb3RvdHlwZS5lbmRsaW5lID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKCFub2RlLmlzTGFzdFJvb3ROb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld2xpbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxTdHJlYW1Xcml0ZXI7XG5cbiAgfSkoWE1MV3JpdGVyQmFzZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ0RhdGEsIFhNTENvbW1lbnQsIFhNTERUREF0dExpc3QsIFhNTERUREVsZW1lbnQsIFhNTERUREVudGl0eSwgWE1MRFRETm90YXRpb24sIFhNTERlY2xhcmF0aW9uLCBYTUxEb2NUeXBlLCBYTUxFbGVtZW50LCBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIFhNTFJhdywgWE1MU3RyaW5nV3JpdGVyLCBYTUxUZXh0LCBYTUxXcml0ZXJCYXNlLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgWE1MRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL1hNTERlY2xhcmF0aW9uJyk7XG5cbiAgWE1MRG9jVHlwZSA9IHJlcXVpcmUoJy4vWE1MRG9jVHlwZScpO1xuXG4gIFhNTENEYXRhID0gcmVxdWlyZSgnLi9YTUxDRGF0YScpO1xuXG4gIFhNTENvbW1lbnQgPSByZXF1aXJlKCcuL1hNTENvbW1lbnQnKTtcblxuICBYTUxFbGVtZW50ID0gcmVxdWlyZSgnLi9YTUxFbGVtZW50Jyk7XG5cbiAgWE1MUmF3ID0gcmVxdWlyZSgnLi9YTUxSYXcnKTtcblxuICBYTUxUZXh0ID0gcmVxdWlyZSgnLi9YTUxUZXh0Jyk7XG5cbiAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gcmVxdWlyZSgnLi9YTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24nKTtcblxuICBYTUxEVERBdHRMaXN0ID0gcmVxdWlyZSgnLi9YTUxEVERBdHRMaXN0Jyk7XG5cbiAgWE1MRFRERWxlbWVudCA9IHJlcXVpcmUoJy4vWE1MRFRERWxlbWVudCcpO1xuXG4gIFhNTERUREVudGl0eSA9IHJlcXVpcmUoJy4vWE1MRFRERW50aXR5Jyk7XG5cbiAgWE1MRFRETm90YXRpb24gPSByZXF1aXJlKCcuL1hNTERURE5vdGF0aW9uJyk7XG5cbiAgWE1MV3JpdGVyQmFzZSA9IHJlcXVpcmUoJy4vWE1MV3JpdGVyQmFzZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MU3RyaW5nV3JpdGVyID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MU3RyaW5nV3JpdGVyLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTFN0cmluZ1dyaXRlcihvcHRpb25zKSB7XG4gICAgICBYTUxTdHJpbmdXcml0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5kb2N1bWVudCA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgdmFyIGNoaWxkLCBpLCBsZW4sIHIsIHJlZjtcbiAgICAgIHRoaXMudGV4dGlzcHJlc2VudCA9IGZhbHNlO1xuICAgICAgciA9ICcnO1xuICAgICAgcmVmID0gZG9jLmNoaWxkcmVuO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICByICs9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEZWNsYXJhdGlvbik6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9uKGNoaWxkKTtcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERvY1R5cGUpOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb2NUeXBlKGNoaWxkKTtcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENvbW1lbnQpOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21tZW50KGNoaWxkKTtcbiAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbik6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihjaGlsZCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50KGNoaWxkLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmV0dHkgJiYgci5zbGljZSgtdGhpcy5uZXdsaW5lLmxlbmd0aCkgPT09IHRoaXMubmV3bGluZSkge1xuICAgICAgICByID0gci5zbGljZSgwLCAtdGhpcy5uZXdsaW5lLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGUgPSBmdW5jdGlvbihhdHQpIHtcbiAgICAgIHJldHVybiAnICcgKyBhdHQubmFtZSArICc9XCInICsgYXR0LnZhbHVlICsgJ1wiJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5jZGF0YSA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFjZShsZXZlbCkgKyAnPCFbQ0RBVEFbJyArIG5vZGUudGV4dCArICddXT4nICsgdGhpcy5uZXdsaW5lO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLmNvbW1lbnQgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhLS0gJyArIG5vZGUudGV4dCArICcgLS0+JyArIHRoaXMubmV3bGluZTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5kZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHIgPSB0aGlzLnNwYWNlKGxldmVsKTtcbiAgICAgIHIgKz0gJzw/eG1sIHZlcnNpb249XCInICsgbm9kZS52ZXJzaW9uICsgJ1wiJztcbiAgICAgIGlmIChub2RlLmVuY29kaW5nICE9IG51bGwpIHtcbiAgICAgICAgciArPSAnIGVuY29kaW5nPVwiJyArIG5vZGUuZW5jb2RpbmcgKyAnXCInO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuc3RhbmRhbG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHIgKz0gJyBzdGFuZGFsb25lPVwiJyArIG5vZGUuc3RhbmRhbG9uZSArICdcIic7XG4gICAgICB9XG4gICAgICByICs9IHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICc/Pic7XG4gICAgICByICs9IHRoaXMubmV3bGluZTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLmRvY1R5cGUgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdmFyIGNoaWxkLCBpLCBsZW4sIHIsIHJlZjtcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgciA9IHRoaXMuc3BhY2UobGV2ZWwpO1xuICAgICAgciArPSAnPCFET0NUWVBFICcgKyBub2RlLnJvb3QoKS5uYW1lO1xuICAgICAgaWYgKG5vZGUucHViSUQgJiYgbm9kZS5zeXNJRCkge1xuICAgICAgICByICs9ICcgUFVCTElDIFwiJyArIG5vZGUucHViSUQgKyAnXCIgXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuc3lzSUQpIHtcbiAgICAgICAgciArPSAnIFNZU1RFTSBcIicgKyBub2RlLnN5c0lEICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgciArPSAnIFsnO1xuICAgICAgICByICs9IHRoaXMubmV3bGluZTtcbiAgICAgICAgcmVmID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICAgICAgciArPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERUREF0dExpc3QpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmR0ZEF0dExpc3QoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERUREVsZW1lbnQpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmR0ZEVsZW1lbnQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTERUREVudGl0eSk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHRkRW50aXR5KGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBjYXNlICEoY2hpbGQgaW5zdGFuY2VvZiBYTUxEVEROb3RhdGlvbik6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHRkTm90YXRpb24oY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENEYXRhKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jZGF0YShjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MQ29tbWVudCk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWVudChjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBEVEQgbm9kZSB0eXBlOiBcIiArIGNoaWxkLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgciArPSAnXSc7XG4gICAgICB9XG4gICAgICByICs9IHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICc+JztcbiAgICAgIHIgKz0gdGhpcy5uZXdsaW5lO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgYXR0LCBjaGlsZCwgaSwgaiwgbGVuLCBsZW4xLCBuYW1lLCByLCByZWYsIHJlZjEsIHJlZjIsIHNwYWNlLCB0ZXh0aXNwcmVzZW50d2Fzc2V0O1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICB0ZXh0aXNwcmVzZW50d2Fzc2V0ID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy50ZXh0aXNwcmVzZW50KSB7XG4gICAgICAgIHRoaXMubmV3bGluZSA9ICcnO1xuICAgICAgICB0aGlzLnByZXR0eSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5uZXdsaW5lID0gdGhpcy5uZXdsaW5lZGVmYXVsdDtcbiAgICAgICAgdGhpcy5wcmV0dHkgPSB0aGlzLnByZXR0eWRlZmF1bHQ7XG4gICAgICB9XG4gICAgICBzcGFjZSA9IHRoaXMuc3BhY2UobGV2ZWwpO1xuICAgICAgciA9ICcnO1xuICAgICAgciArPSBzcGFjZSArICc8JyArIG5vZGUubmFtZTtcbiAgICAgIHJlZiA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBuYW1lKSkgY29udGludWU7XG4gICAgICAgIGF0dCA9IHJlZltuYW1lXTtcbiAgICAgICAgciArPSB0aGlzLmF0dHJpYnV0ZShhdHQpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IG5vZGUuY2hpbGRyZW4uZXZlcnkoZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZS52YWx1ZSA9PT0gJyc7XG4gICAgICB9KSkge1xuICAgICAgICBpZiAodGhpcy5hbGxvd0VtcHR5KSB7XG4gICAgICAgICAgciArPSAnPjwvJyArIG5vZGUubmFtZSArICc+JyArIHRoaXMubmV3bGluZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByICs9IHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICcvPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV0dHkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgKG5vZGUuY2hpbGRyZW5bMF0udmFsdWUgIT0gbnVsbCkpIHtcbiAgICAgICAgciArPSAnPic7XG4gICAgICAgIHIgKz0gbm9kZS5jaGlsZHJlblswXS52YWx1ZTtcbiAgICAgICAgciArPSAnPC8nICsgbm9kZS5uYW1lICsgJz4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZG9udHByZXR0eXRleHRub2Rlcykge1xuICAgICAgICAgIHJlZjEgPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gcmVmMVtpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMudGV4dGlzcHJlc2VudCsrO1xuICAgICAgICAgICAgICB0ZXh0aXNwcmVzZW50d2Fzc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRleHRpc3ByZXNlbnQpIHtcbiAgICAgICAgICB0aGlzLm5ld2xpbmUgPSAnJztcbiAgICAgICAgICB0aGlzLnByZXR0eSA9IGZhbHNlO1xuICAgICAgICAgIHNwYWNlID0gdGhpcy5zcGFjZShsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgciArPSAnPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgICAgIHJlZjIgPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gcmVmMi5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICBjaGlsZCA9IHJlZjJbal07XG4gICAgICAgICAgciArPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTENEYXRhKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jZGF0YShjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MQ29tbWVudCk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWVudChjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MRWxlbWVudCk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChjaGlsZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgY2FzZSAhKGNoaWxkIGluc3RhbmNlb2YgWE1MUmF3KTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTFRleHQpOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQoY2hpbGQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICAgIGNhc2UgIShjaGlsZCBpbnN0YW5jZW9mIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbik6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc2luZ0luc3RydWN0aW9uKGNoaWxkLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gWE1MIG5vZGUgdHlwZTogXCIgKyBjaGlsZC5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0aXNwcmVzZW50d2Fzc2V0KSB7XG4gICAgICAgICAgdGhpcy50ZXh0aXNwcmVzZW50LS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRleHRpc3ByZXNlbnQpIHtcbiAgICAgICAgICB0aGlzLm5ld2xpbmUgPSB0aGlzLm5ld2xpbmVkZWZhdWx0O1xuICAgICAgICAgIHRoaXMucHJldHR5ID0gdGhpcy5wcmV0dHlkZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIHIgKz0gc3BhY2UgKyAnPC8nICsgbm9kZS5uYW1lICsgJz4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUucHJvY2Vzc2luZ0luc3RydWN0aW9uID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHZhciByO1xuICAgICAgciA9IHRoaXMuc3BhY2UobGV2ZWwpICsgJzw/JyArIG5vZGUudGFyZ2V0O1xuICAgICAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgciArPSAnICcgKyBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgciArPSB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPz4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUucmF3ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYWNlKGxldmVsKSArIG5vZGUudmFsdWUgKyB0aGlzLm5ld2xpbmU7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFjZShsZXZlbCkgKyBub2RlLnZhbHVlICsgdGhpcy5uZXdsaW5lO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLmR0ZEF0dExpc3QgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgdmFyIHI7XG4gICAgICByID0gdGhpcy5zcGFjZShsZXZlbCkgKyAnPCFBVFRMSVNUICcgKyBub2RlLmVsZW1lbnROYW1lICsgJyAnICsgbm9kZS5hdHRyaWJ1dGVOYW1lICsgJyAnICsgbm9kZS5hdHRyaWJ1dGVUeXBlO1xuICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlVHlwZSAhPT0gJyNERUZBVUxUJykge1xuICAgICAgICByICs9ICcgJyArIG5vZGUuZGVmYXVsdFZhbHVlVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByICs9ICcgXCInICsgbm9kZS5kZWZhdWx0VmFsdWUgKyAnXCInO1xuICAgICAgfVxuICAgICAgciArPSB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5kdGRFbGVtZW50ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYWNlKGxldmVsKSArICc8IUVMRU1FTlQgJyArIG5vZGUubmFtZSArICcgJyArIG5vZGUudmFsdWUgKyB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ1dyaXRlci5wcm90b3R5cGUuZHRkRW50aXR5ID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHZhciByO1xuICAgICAgciA9IHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhRU5USVRZJztcbiAgICAgIGlmIChub2RlLnBlKSB7XG4gICAgICAgIHIgKz0gJyAlJztcbiAgICAgIH1cbiAgICAgIHIgKz0gJyAnICsgbm9kZS5uYW1lO1xuICAgICAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgciArPSAnIFwiJyArIG5vZGUudmFsdWUgKyAnXCInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGUucHViSUQgJiYgbm9kZS5zeXNJRCkge1xuICAgICAgICAgIHIgKz0gJyBQVUJMSUMgXCInICsgbm9kZS5wdWJJRCArICdcIiBcIicgKyBub2RlLnN5c0lEICsgJ1wiJztcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnN5c0lEKSB7XG4gICAgICAgICAgciArPSAnIFNZU1RFTSBcIicgKyBub2RlLnN5c0lEICsgJ1wiJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5uRGF0YSkge1xuICAgICAgICAgIHIgKz0gJyBOREFUQSAnICsgbm9kZS5uRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgciArPSB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggKyAnPicgKyB0aGlzLm5ld2xpbmU7XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5kdGROb3RhdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGxldmVsKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHIgPSB0aGlzLnNwYWNlKGxldmVsKSArICc8IU5PVEFUSU9OICcgKyBub2RlLm5hbWU7XG4gICAgICBpZiAobm9kZS5wdWJJRCAmJiBub2RlLnN5c0lEKSB7XG4gICAgICAgIHIgKz0gJyBQVUJMSUMgXCInICsgbm9kZS5wdWJJRCArICdcIiBcIicgKyBub2RlLnN5c0lEICsgJ1wiJztcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5wdWJJRCkge1xuICAgICAgICByICs9ICcgUFVCTElDIFwiJyArIG5vZGUucHViSUQgKyAnXCInO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnN5c0lEKSB7XG4gICAgICAgIHIgKz0gJyBTWVNURU0gXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICB9XG4gICAgICByICs9IHRoaXMuc3BhY2ViZWZvcmVzbGFzaCArICc+JyArIHRoaXMubmV3bGluZTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdXcml0ZXIucHJvdG90eXBlLm9wZW5Ob2RlID0gZnVuY3Rpb24obm9kZSwgbGV2ZWwpIHtcbiAgICAgIHZhciBhdHQsIG5hbWUsIHIsIHJlZjtcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBYTUxFbGVtZW50KSB7XG4gICAgICAgIHIgPSB0aGlzLnNwYWNlKGxldmVsKSArICc8JyArIG5vZGUubmFtZTtcbiAgICAgICAgcmVmID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBuYW1lKSkgY29udGludWU7XG4gICAgICAgICAgYXR0ID0gcmVmW25hbWVdO1xuICAgICAgICAgIHIgKz0gdGhpcy5hdHRyaWJ1dGUoYXR0KTtcbiAgICAgICAgfVxuICAgICAgICByICs9IChub2RlLmNoaWxkcmVuID8gJz4nIDogJy8+JykgKyB0aGlzLm5ld2xpbmU7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHRoaXMuc3BhY2UobGV2ZWwpICsgJzwhRE9DVFlQRSAnICsgbm9kZS5yb290Tm9kZU5hbWU7XG4gICAgICAgIGlmIChub2RlLnB1YklEICYmIG5vZGUuc3lzSUQpIHtcbiAgICAgICAgICByICs9ICcgUFVCTElDIFwiJyArIG5vZGUucHViSUQgKyAnXCIgXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5zeXNJRCkge1xuICAgICAgICAgIHIgKz0gJyBTWVNURU0gXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgciArPSAobm9kZS5jaGlsZHJlbiA/ICcgWycgOiAnPicpICsgdGhpcy5uZXdsaW5lO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MU3RyaW5nV3JpdGVyLnByb3RvdHlwZS5jbG9zZU5vZGUgPSBmdW5jdGlvbihub2RlLCBsZXZlbCkge1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgIGNhc2UgIShub2RlIGluc3RhbmNlb2YgWE1MRWxlbWVudCk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2UobGV2ZWwpICsgJzwvJyArIG5vZGUubmFtZSArICc+JyArIHRoaXMubmV3bGluZTtcbiAgICAgICAgY2FzZSAhKG5vZGUgaW5zdGFuY2VvZiBYTUxEb2NUeXBlKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zcGFjZShsZXZlbCkgKyAnXT4nICsgdGhpcy5uZXdsaW5lO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gWE1MU3RyaW5nV3JpdGVyO1xuXG4gIH0pKFhNTFdyaXRlckJhc2UpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTFN0cmluZ2lmaWVyLFxuICAgIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFN0cmluZ2lmaWVyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTFN0cmluZ2lmaWVyKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuYXNzZXJ0TGVnYWxDaGFyID0gYmluZCh0aGlzLmFzc2VydExlZ2FsQ2hhciwgdGhpcyk7XG4gICAgICB2YXIga2V5LCByZWYsIHZhbHVlO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIHRoaXMubm9Eb3VibGVFbmNvZGluZyA9IG9wdGlvbnMubm9Eb3VibGVFbmNvZGluZztcbiAgICAgIHJlZiA9IG9wdGlvbnMuc3RyaW5naWZ5IHx8IHt9O1xuICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwga2V5KSkgY29udGludWU7XG4gICAgICAgIHZhbHVlID0gcmVmW2tleV07XG4gICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5lbGVOYW1lID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydExlZ2FsQ2hhcih2YWwpO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZWxlVGV4dCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIodGhpcy5lbEVzY2FwZSh2YWwpKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNkYXRhID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKCddXT4nLCAnXV1dXT48IVtDREFUQVs+Jyk7XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIodmFsKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbW1lbnQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhbCA9ICcnICsgdmFsIHx8ICcnO1xuICAgICAgaWYgKHZhbC5tYXRjaCgvLS0vKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21tZW50IHRleHQgY2Fubm90IGNvbnRhaW4gZG91YmxlLWh5cGVuOiBcIiArIHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIodmFsKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuYXR0TmFtZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCA9ICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuYXR0VmFsdWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhbCA9ICcnICsgdmFsIHx8ICcnO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0RXNjYXBlKHZhbCk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5pbnNUYXJnZXQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmluc1ZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIGlmICh2YWwubWF0Y2goL1xcPz4vKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gdmFsdWU6IFwiICsgdmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS54bWxWZXJzaW9uID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIGlmICghdmFsLm1hdGNoKC8xXFwuWzAtOV0rLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2ZXJzaW9uIG51bWJlcjogXCIgKyB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLnhtbEVuY29kaW5nID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIGlmICghdmFsLm1hdGNoKC9eW0EtWmEtel0oPzpbQS1aYS16MC05Ll8tXSkqJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZW5jb2Rpbmc6IFwiICsgdmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS54bWxTdGFuZGFsb25lID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHJldHVybiBcInllc1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwibm9cIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmR0ZFB1YklEID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRTeXNJRCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkRWxlbWVudFZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRBdHRUeXBlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRBdHREZWZhdWx0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmR0ZEVudGl0eVZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRORGF0YSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydEF0dEtleSA9ICdAJztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0UElLZXkgPSAnPyc7XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydFRleHRLZXkgPSAnI3RleHQnO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRDRGF0YUtleSA9ICcjY2RhdGEnO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRDb21tZW50S2V5ID0gJyNjb21tZW50JztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0UmF3S2V5ID0gJyNyYXcnO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmFzc2VydExlZ2FsQ2hhciA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIHJlcztcbiAgICAgIHJlcyA9IHN0ci5tYXRjaCgvW1xcMFxcdUZGRkVcXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS8pO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYXJhY3RlciBpbiBzdHJpbmc6IFwiICsgc3RyICsgXCIgYXQgaW5kZXggXCIgKyByZXMuaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmVsRXNjYXBlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgYW1wcmVnZXg7XG4gICAgICBhbXByZWdleCA9IHRoaXMubm9Eb3VibGVFbmNvZGluZyA/IC8oPyEmXFxTKzspJi9nIDogLyYvZztcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZShhbXByZWdleCwgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cXHIvZywgJyYjeEQ7Jyk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5hdHRFc2NhcGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciBhbXByZWdleDtcbiAgICAgIGFtcHJlZ2V4ID0gdGhpcy5ub0RvdWJsZUVuY29kaW5nID8gLyg/ISZcXFMrOykmL2cgOiAvJi9nO1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKGFtcHJlZ2V4LCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLnJlcGxhY2UoL1xcdC9nLCAnJiN4OTsnKS5yZXBsYWNlKC9cXG4vZywgJyYjeEE7JykucmVwbGFjZSgvXFxyL2csICcmI3hEOycpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MU3RyaW5naWZpZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMi43XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxOb2RlLCBYTUxUZXh0LFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MVGV4dCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTFRleHQsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MVGV4dChwYXJlbnQsIHRleHQpIHtcbiAgICAgIFhNTFRleHQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBlbGVtZW50IHRleHRcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5zdHJpbmdpZnkuZWxlVGV4dCh0ZXh0KTtcbiAgICB9XG5cbiAgICBYTUxUZXh0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfTtcblxuICAgIFhNTFRleHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuc2V0KG9wdGlvbnMpLnRleHQodGhpcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxUZXh0O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTFdyaXRlckJhc2UsXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MV3JpdGVyQmFzZSA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBYTUxXcml0ZXJCYXNlKG9wdGlvbnMpIHtcbiAgICAgIHZhciBrZXksIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgcmVmNiwgdmFsdWU7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgdGhpcy5wcmV0dHkgPSBvcHRpb25zLnByZXR0eSB8fCBmYWxzZTtcbiAgICAgIHRoaXMuYWxsb3dFbXB0eSA9IChyZWYgPSBvcHRpb25zLmFsbG93RW1wdHkpICE9IG51bGwgPyByZWYgOiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnByZXR0eSkge1xuICAgICAgICB0aGlzLmluZGVudCA9IChyZWYxID0gb3B0aW9ucy5pbmRlbnQpICE9IG51bGwgPyByZWYxIDogJyAgJztcbiAgICAgICAgdGhpcy5uZXdsaW5lID0gKHJlZjIgPSBvcHRpb25zLm5ld2xpbmUpICE9IG51bGwgPyByZWYyIDogJ1xcbic7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gKHJlZjMgPSBvcHRpb25zLm9mZnNldCkgIT0gbnVsbCA/IHJlZjMgOiAwO1xuICAgICAgICB0aGlzLmRvbnRwcmV0dHl0ZXh0bm9kZXMgPSAocmVmNCA9IG9wdGlvbnMuZG9udHByZXR0eXRleHRub2RlcykgIT0gbnVsbCA/IHJlZjQgOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSAnJztcbiAgICAgICAgdGhpcy5uZXdsaW5lID0gJyc7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5kb250cHJldHR5dGV4dG5vZGVzID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3BhY2ViZWZvcmVzbGFzaCA9IChyZWY1ID0gb3B0aW9ucy5zcGFjZWJlZm9yZXNsYXNoKSAhPSBudWxsID8gcmVmNSA6ICcnO1xuICAgICAgaWYgKHRoaXMuc3BhY2ViZWZvcmVzbGFzaCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggPSAnICc7XG4gICAgICB9XG4gICAgICB0aGlzLm5ld2xpbmVkZWZhdWx0ID0gdGhpcy5uZXdsaW5lO1xuICAgICAgdGhpcy5wcmV0dHlkZWZhdWx0ID0gdGhpcy5wcmV0dHk7XG4gICAgICByZWY2ID0gb3B0aW9ucy53cml0ZXIgfHwge307XG4gICAgICBmb3IgKGtleSBpbiByZWY2KSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZjYsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YWx1ZSA9IHJlZjZba2V5XTtcbiAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MV3JpdGVyQmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGtleSwgcmVmLCB2YWx1ZTtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICBpZiAoXCJwcmV0dHlcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucHJldHR5ID0gb3B0aW9ucy5wcmV0dHk7XG4gICAgICB9XG4gICAgICBpZiAoXCJhbGxvd0VtcHR5XCIgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLmFsbG93RW1wdHkgPSBvcHRpb25zLmFsbG93RW1wdHk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmV0dHkpIHtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSBcImluZGVudFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmluZGVudCA6ICcgICc7XG4gICAgICAgIHRoaXMubmV3bGluZSA9IFwibmV3bGluZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLm5ld2xpbmUgOiAnXFxuJztcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBcIm9mZnNldFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLm9mZnNldCA6IDA7XG4gICAgICAgIHRoaXMuZG9udHByZXR0eXRleHRub2RlcyA9IFwiZG9udHByZXR0eXRleHRub2Rlc1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLmRvbnRwcmV0dHl0ZXh0bm9kZXMgOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSAnJztcbiAgICAgICAgdGhpcy5uZXdsaW5lID0gJyc7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5kb250cHJldHR5dGV4dG5vZGVzID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3BhY2ViZWZvcmVzbGFzaCA9IFwic3BhY2ViZWZvcmVzbGFzaFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnNwYWNlYmVmb3Jlc2xhc2ggOiAnJztcbiAgICAgIGlmICh0aGlzLnNwYWNlYmVmb3Jlc2xhc2ggPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zcGFjZWJlZm9yZXNsYXNoID0gJyAnO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXdsaW5lZGVmYXVsdCA9IHRoaXMubmV3bGluZTtcbiAgICAgIHRoaXMucHJldHR5ZGVmYXVsdCA9IHRoaXMucHJldHR5O1xuICAgICAgcmVmID0gb3B0aW9ucy53cml0ZXIgfHwge307XG4gICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MV3JpdGVyQmFzZS5wcm90b3R5cGUuc3BhY2UgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgICAgdmFyIGluZGVudDtcbiAgICAgIGlmICh0aGlzLnByZXR0eSkge1xuICAgICAgICBpbmRlbnQgPSAobGV2ZWwgfHwgMCkgKyB0aGlzLm9mZnNldCArIDE7XG4gICAgICAgIGlmIChpbmRlbnQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBcnJheShpbmRlbnQpLmpvaW4odGhpcy5pbmRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gWE1MV3JpdGVyQmFzZTtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjdcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERvY3VtZW50LCBYTUxEb2N1bWVudENCLCBYTUxTdHJlYW1Xcml0ZXIsIFhNTFN0cmluZ1dyaXRlciwgYXNzaWduLCBpc0Z1bmN0aW9uLCByZWY7XG5cbiAgcmVmID0gcmVxdWlyZSgnLi9VdGlsaXR5JyksIGFzc2lnbiA9IHJlZi5hc3NpZ24sIGlzRnVuY3Rpb24gPSByZWYuaXNGdW5jdGlvbjtcblxuICBYTUxEb2N1bWVudCA9IHJlcXVpcmUoJy4vWE1MRG9jdW1lbnQnKTtcblxuICBYTUxEb2N1bWVudENCID0gcmVxdWlyZSgnLi9YTUxEb2N1bWVudENCJyk7XG5cbiAgWE1MU3RyaW5nV3JpdGVyID0gcmVxdWlyZSgnLi9YTUxTdHJpbmdXcml0ZXInKTtcblxuICBYTUxTdHJlYW1Xcml0ZXIgPSByZXF1aXJlKCcuL1hNTFN0cmVhbVdyaXRlcicpO1xuXG4gIG1vZHVsZS5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uKG5hbWUsIHhtbGRlYywgZG9jdHlwZSwgb3B0aW9ucykge1xuICAgIHZhciBkb2MsIHJvb3Q7XG4gICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBlbGVtZW50IG5lZWRzIGEgbmFtZVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IGFzc2lnbih7fSwgeG1sZGVjLCBkb2N0eXBlLCBvcHRpb25zKTtcbiAgICBkb2MgPSBuZXcgWE1MRG9jdW1lbnQob3B0aW9ucyk7XG4gICAgcm9vdCA9IGRvYy5lbGVtZW50KG5hbWUpO1xuICAgIGlmICghb3B0aW9ucy5oZWFkbGVzcykge1xuICAgICAgZG9jLmRlY2xhcmF0aW9uKG9wdGlvbnMpO1xuICAgICAgaWYgKChvcHRpb25zLnB1YklEICE9IG51bGwpIHx8IChvcHRpb25zLnN5c0lEICE9IG51bGwpKSB7XG4gICAgICAgIGRvYy5kb2N0eXBlKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5iZWdpbiA9IGZ1bmN0aW9uKG9wdGlvbnMsIG9uRGF0YSwgb25FbmQpIHtcbiAgICB2YXIgcmVmMTtcbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgcmVmMSA9IFtvcHRpb25zLCBvbkRhdGFdLCBvbkRhdGEgPSByZWYxWzBdLCBvbkVuZCA9IHJlZjFbMV07XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmIChvbkRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MRG9jdW1lbnRDQihvcHRpb25zLCBvbkRhdGEsIG9uRW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBYTUxEb2N1bWVudChvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuc3RyaW5nV3JpdGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgWE1MU3RyaW5nV3JpdGVyKG9wdGlvbnMpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLnN0cmVhbVdyaXRlciA9IGZ1bmN0aW9uKHN0cmVhbSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgWE1MU3RyZWFtV3JpdGVyKHN0cmVhbSwgb3B0aW9ucyk7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIHNoYSA9IHJlcXVpcmUoJy4vc2hhJyk7XG52YXIgc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKTtcbnZhciBtZDUgPSByZXF1aXJlKCcuL21kNScpO1xuXG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgc2hhMTogc2hhLFxuICBzaGEyNTY6IHNoYTI1NixcbiAgbWQ1OiBtZDVcbn07XG5cbnZhciBibG9ja3NpemUgPSA2NDtcbnZhciB6ZXJvQnVmZmVyID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpO1xuemVyb0J1ZmZlci5maWxsKDApO1xuXG5mdW5jdGlvbiBobWFjKGZuLCBrZXksIGRhdGEpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihrZXkpKSBrZXkgPSBuZXcgQnVmZmVyKGtleSk7XG4gIGlmKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEpO1xuXG4gIGlmKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBmbihrZXkpXG4gIH0gZWxzZSBpZihrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCB6ZXJvQnVmZmVyXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSksIG9wYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHZhciBoYXNoID0gZm4oQnVmZmVyLmNvbmNhdChbaXBhZCwgZGF0YV0pKVxuICByZXR1cm4gZm4oQnVmZmVyLmNvbmNhdChbb3BhZCwgaGFzaF0pKVxufVxuXG5mdW5jdGlvbiBoYXNoKGFsZywga2V5KSB7XG4gIGFsZyA9IGFsZyB8fCAnc2hhMSc7XG4gIHZhciBmbiA9IGFsZ29yaXRobXNbYWxnXTtcbiAgdmFyIGJ1ZnMgPSBbXTtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIGlmKCFmbikgZXJyb3IoJ2FsZ29yaXRobTonLCBhbGcsICdpcyBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEpO1xuXG4gICAgICBidWZzLnB1c2goZGF0YSk7XG4gICAgICBsZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgZGlnZXN0OiBmdW5jdGlvbiAoZW5jKSB7XG4gICAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChidWZzKTtcbiAgICAgIHZhciByID0ga2V5ID8gaG1hYyhmbiwga2V5LCBidWYpIDogZm4oYnVmKTtcbiAgICAgIGJ1ZnMgPSBudWxsO1xuICAgICAgcmV0dXJuIGVuYyA/IHIudG9TdHJpbmcoZW5jKSA6IHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXJyb3IgKCkge1xuICB2YXIgbSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJylcbiAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICBtLFxuICAgICd3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cycsXG4gICAgJ2h0dHA6Ly9naXRodWIuY29tL2RvbWluaWN0YXJyL2NyeXB0by1icm93c2VyaWZ5J1xuICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoYWxnKSB7IHJldHVybiBoYXNoKGFsZykgfTtcbmV4cG9ydHMuY3JlYXRlSG1hYyA9IGZ1bmN0aW9uIChhbGcsIGtleSkgeyByZXR1cm4gaGFzaChhbGcsIGtleSkgfTtcblxuZnVuY3Rpb24gZWFjaChhLCBmKSB7XG4gIGZvcih2YXIgaSBpbiBhKVxuICAgIGYoYVtpXSwgaSlcbn1cblxuLy8gdGhlIGxlYXN0IEkgY2FuIGRvIGlzIG1ha2UgZXJyb3IgbWVzc2FnZXMgZm9yIHRoZSByZXN0IG9mIHRoZSBub2RlLmpzL2NyeXB0byBhcGkuXG5lYWNoKFsnY3JlYXRlQ3JlZGVudGlhbHMnXG4gICwgJ2NyZWF0ZUNpcGhlcidcbiAgLCAnY3JlYXRlQ2lwaGVyaXYnXG4gICwgJ2NyZWF0ZURlY2lwaGVyJ1xuICAsICdjcmVhdGVEZWNpcGhlcml2J1xuICAsICdjcmVhdGVTaWduJ1xuICAsICdjcmVhdGVWZXJpZnknXG4gICwgJ2NyZWF0ZURpZmZpZUhlbGxtYW4nXG4gICwgJ3Bia2RmMiddLCBmdW5jdGlvbiAobmFtZSkge1xuICBleHBvcnRzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdzb3JyeSwnLCBuYW1lLCAnaXMgbm90IGltcGxlbWVudGVkIHlldCcpXG4gIH1cbn0pOyIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgaW50U2l6ZSA9IDQ7XG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoaW50U2l6ZSk7IHplcm9CdWZmZXIuZmlsbCgwKTtcbnZhciBjaHJzeiA9IDg7XG5cbmZ1bmN0aW9uIHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pIHtcbiAgaWYgKChidWYubGVuZ3RoICUgaW50U2l6ZSkgIT09IDApIHtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aCArIChpbnRTaXplIC0gKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSk7XG4gICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCB6ZXJvQnVmZmVyXSwgbGVuKTtcbiAgfVxuXG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLnJlYWRJbnQzMkJFIDogYnVmLnJlYWRJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gaW50U2l6ZSkge1xuICAgIGFyci5wdXNoKGZuLmNhbGwoYnVmLCBpKSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gdG9CdWZmZXIoYXJyLCBzaXplLCBiaWdFbmRpYW4pIHtcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi53cml0ZUludDMyQkUgOiBidWYud3JpdGVJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuLmNhbGwoYnVmLCBhcnJbaV0sIGkgKiA0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuXG5mdW5jdGlvbiBoYXNoKGJ1ZiwgZm4sIGhhc2hTaXplLCBiaWdFbmRpYW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gbmV3IEJ1ZmZlcihidWYpO1xuICB2YXIgYXJyID0gZm4odG9BcnJheShidWYsIGJpZ0VuZGlhbiksIGJ1Zi5sZW5ndGggKiBjaHJzeik7XG4gIHJldHVybiB0b0J1ZmZlcihhcnIsIGhhc2hTaXplLCBiaWdFbmRpYW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgaGFzaDogaGFzaCB9O1xuIiwiLypcclxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxyXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxyXG4gKiBWZXJzaW9uIDIuMSBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDIuXHJcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcclxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXHJcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXHJcbiAqL1xyXG5cclxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcclxuXHJcbi8qXHJcbiAqIFBlcmZvcm0gYSBzaW1wbGUgc2VsZi10ZXN0IHRvIHNlZSBpZiB0aGUgVk0gaXMgd29ya2luZ1xyXG4gKi9cclxuZnVuY3Rpb24gbWQ1X3ZtX3Rlc3QoKVxyXG57XHJcbiAgcmV0dXJuIGhleF9tZDUoXCJhYmNcIikgPT0gXCI5MDAxNTA5ODNjZDI0ZmIwZDY5NjNmN2QyOGUxN2Y3MlwiO1xyXG59XHJcblxyXG4vKlxyXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3JlX21kNSh4LCBsZW4pXHJcbntcclxuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xyXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKChsZW4pICUgMzIpO1xyXG4gIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcclxuXHJcbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcclxuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XHJcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcclxuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XHJcblxyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcclxuICB7XHJcbiAgICB2YXIgb2xkYSA9IGE7XHJcbiAgICB2YXIgb2xkYiA9IGI7XHJcbiAgICB2YXIgb2xkYyA9IGM7XHJcbiAgICB2YXIgb2xkZCA9IGQ7XHJcblxyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDBdLCA3ICwgLTY4MDg3NjkzNik7XHJcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcclxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xyXG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDRdLCA3ICwgLTE3NjQxODg5Nyk7XHJcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XHJcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XHJcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgN10sIDIyLCAtNDU3MDU5ODMpO1xyXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDhdLCA3ICwgIDE3NzAwMzU0MTYpO1xyXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xyXG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTBdLCAxNywgLTQyMDYzKTtcclxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcclxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKzEyXSwgNyAsICAxODA0NjAzNjgyKTtcclxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKzEzXSwgMTIsIC00MDM0MTEwMSk7XHJcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XHJcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XHJcblxyXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDFdLCA1ICwgLTE2NTc5NjUxMCk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgNl0sIDkgLCAtMTA2OTUwMTYzMik7XHJcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcclxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xyXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDVdLCA1ICwgLTcwMTU1ODY5MSk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxMF0sIDkgLCAgMzgwMTYwODMpO1xyXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XHJcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcclxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA5XSwgNSAsICA1Njg0NDY0MzgpO1xyXG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTRdLCA5ICwgLTEwMTk4MDM2OTApO1xyXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XHJcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XHJcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsxM10sIDUgLCAtMTQ0NDY4MTQ2Nyk7XHJcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgMl0sIDkgLCAtNTE0MDM3ODQpO1xyXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xyXG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xyXG5cclxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xyXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xyXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcclxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyAxXSwgNCAsIC0xNTMwOTkyMDYwKTtcclxuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA0XSwgMTEsICAxMjcyODkzMzUzKTtcclxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xyXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krMTNdLCA0ICwgIDY4MTI3OTE3NCk7XHJcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcclxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xyXG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDZdLCAyMywgIDc2MDI5MTg5KTtcclxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xyXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XHJcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE2LCAgNTMwNzQyNTIwKTtcclxuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xyXG5cclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyAwXSwgNiAsIC0xOTg2MzA4NDQpO1xyXG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDddLCAxMCwgIDExMjY4OTE0MTUpO1xyXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xyXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKzEyXSwgNiAsICAxNzAwNDg1NTcxKTtcclxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcclxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcclxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcclxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA4XSwgNiAsICAxODczMzEzMzU5KTtcclxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XHJcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XHJcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XHJcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDYgLCAtMTQ1NTIzMDcwKTtcclxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzExXSwgMTAsIC0xMTIwMjEwMzc5KTtcclxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xyXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XHJcblxyXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xyXG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xyXG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xyXG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xyXG4gIH1cclxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCk7XHJcblxyXG59XHJcblxyXG4vKlxyXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIHNhZmVfYWRkKGJpdF9yb2woc2FmZV9hZGQoc2FmZV9hZGQoYSwgcSksIHNhZmVfYWRkKHgsIHQpKSwgcyksYik7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2ZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2dnKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XHJcbn1cclxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXHJcbntcclxuICByZXR1cm4gbWQ1X2NtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xyXG59XHJcbmZ1bmN0aW9uIG1kNV9paShhLCBiLCBjLCBkLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xyXG59XHJcblxyXG4vKlxyXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XHJcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxyXG57XHJcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcclxuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XHJcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XHJcbn1cclxuXHJcbi8qXHJcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cclxuICovXHJcbmZ1bmN0aW9uIGJpdF9yb2wobnVtLCBjbnQpXHJcbntcclxuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWQ1KGJ1Zikge1xyXG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX21kNSwgMTYpO1xyXG59O1xyXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBTSEEtMSBvZiBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvcmVfc2hhMSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbGVuICUgMzIpO1xuICB4WygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG5cbiAgdmFyIHcgPSBBcnJheSg4MCk7XG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuICB2YXIgZSA9IC0xMDA5NTg5Nzc2O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcbiAgICB2YXIgb2xkZSA9IGU7XG5cbiAgICBmb3IodmFyIGogPSAwOyBqIDwgODA7IGorKylcbiAgICB7XG4gICAgICBpZihqIDwgMTYpIHdbal0gPSB4W2kgKyBqXTtcbiAgICAgIGVsc2Ugd1tqXSA9IHJvbCh3W2otM10gXiB3W2otOF0gXiB3W2otMTRdIF4gd1tqLTE2XSwgMSk7XG4gICAgICB2YXIgdCA9IHNhZmVfYWRkKHNhZmVfYWRkKHJvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXG4gICAgICAgIHNhZmVfYWRkKHNhZmVfYWRkKGUsIHdbal0pLCBzaGExX2t0KGopKSk7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IHJvbChiLCAzMCk7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgICBlID0gc2FmZV9hZGQoZSwgb2xkZSk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQsIGUpO1xuXG59XG5cbi8qXG4gKiBQZXJmb3JtIHRoZSBhcHByb3ByaWF0ZSB0cmlwbGV0IGNvbWJpbmF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudFxuICogaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfZnQodCwgYiwgYywgZClcbntcbiAgaWYodCA8IDIwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZCk7XG4gIGlmKHQgPCA0MCkgcmV0dXJuIGIgXiBjIF4gZDtcbiAgaWYodCA8IDYwKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpO1xuICByZXR1cm4gYiBeIGMgXiBkO1xufVxuXG4vKlxuICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBhZGRpdGl2ZSBjb25zdGFudCBmb3IgdGhlIGN1cnJlbnQgaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfa3QodClcbntcbiAgcmV0dXJuICh0IDwgMjApID8gIDE1MTg1MDAyNDkgOiAodCA8IDQwKSA/ICAxODU5Nzc1MzkzIDpcbiAgICAodCA8IDYwKSA/IC0xODk0MDA3NTg4IDogLTg5OTQ5NzUxNDtcbn1cblxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXG57XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIHJvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYTEoYnVmKSB7XG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX3NoYTEsIDIwLCB0cnVlKTtcbn07XG4iLCJcbi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG52YXIgc2FmZV9hZGQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59O1xuXG52YXIgUyA9IGZ1bmN0aW9uKFgsIG4pIHtcbiAgcmV0dXJuIChYID4+PiBuKSB8IChYIDw8ICgzMiAtIG4pKTtcbn07XG5cbnZhciBSID0gZnVuY3Rpb24oWCwgbikge1xuICByZXR1cm4gKFggPj4+IG4pO1xufTtcblxudmFyIENoID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICByZXR1cm4gKCh4ICYgeSkgXiAoKH54KSAmIHopKTtcbn07XG5cbnZhciBNYWogPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHJldHVybiAoKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopKTtcbn07XG5cbnZhciBTaWdtYTAyNTYgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoUyh4LCAyKSBeIFMoeCwgMTMpIF4gUyh4LCAyMikpO1xufTtcblxudmFyIFNpZ21hMTI1NiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChTKHgsIDYpIF4gUyh4LCAxMSkgXiBTKHgsIDI1KSk7XG59O1xuXG52YXIgR2FtbWEwMjU2ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKFMoeCwgNykgXiBTKHgsIDE4KSBeIFIoeCwgMykpO1xufTtcblxudmFyIEdhbW1hMTI1NiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChTKHgsIDE3KSBeIFMoeCwgMTkpIF4gUih4LCAxMCkpO1xufTtcblxudmFyIGNvcmVfc2hhMjU2ID0gZnVuY3Rpb24obSwgbCkge1xuICB2YXIgSyA9IG5ldyBBcnJheSgweDQyOEEyRjk4LDB4NzEzNzQ0OTEsMHhCNUMwRkJDRiwweEU5QjVEQkE1LDB4Mzk1NkMyNUIsMHg1OUYxMTFGMSwweDkyM0Y4MkE0LDB4QUIxQzVFRDUsMHhEODA3QUE5OCwweDEyODM1QjAxLDB4MjQzMTg1QkUsMHg1NTBDN0RDMywweDcyQkU1RDc0LDB4ODBERUIxRkUsMHg5QkRDMDZBNywweEMxOUJGMTc0LDB4RTQ5QjY5QzEsMHhFRkJFNDc4NiwweEZDMTlEQzYsMHgyNDBDQTFDQywweDJERTkyQzZGLDB4NEE3NDg0QUEsMHg1Q0IwQTlEQywweDc2Rjk4OERBLDB4OTgzRTUxNTIsMHhBODMxQzY2RCwweEIwMDMyN0M4LDB4QkY1OTdGQzcsMHhDNkUwMEJGMywweEQ1QTc5MTQ3LDB4NkNBNjM1MSwweDE0MjkyOTY3LDB4MjdCNzBBODUsMHgyRTFCMjEzOCwweDREMkM2REZDLDB4NTMzODBEMTMsMHg2NTBBNzM1NCwweDc2NkEwQUJCLDB4ODFDMkM5MkUsMHg5MjcyMkM4NSwweEEyQkZFOEExLDB4QTgxQTY2NEIsMHhDMjRCOEI3MCwweEM3NkM1MUEzLDB4RDE5MkU4MTksMHhENjk5MDYyNCwweEY0MEUzNTg1LDB4MTA2QUEwNzAsMHgxOUE0QzExNiwweDFFMzc2QzA4LDB4Mjc0ODc3NEMsMHgzNEIwQkNCNSwweDM5MUMwQ0IzLDB4NEVEOEFBNEEsMHg1QjlDQ0E0RiwweDY4MkU2RkYzLDB4NzQ4RjgyRUUsMHg3OEE1NjM2RiwweDg0Qzg3ODE0LDB4OENDNzAyMDgsMHg5MEJFRkZGQSwweEE0NTA2Q0VCLDB4QkVGOUEzRjcsMHhDNjcxNzhGMik7XG4gIHZhciBIQVNIID0gbmV3IEFycmF5KDB4NkEwOUU2NjcsIDB4QkI2N0FFODUsIDB4M0M2RUYzNzIsIDB4QTU0RkY1M0EsIDB4NTEwRTUyN0YsIDB4OUIwNTY4OEMsIDB4MUY4M0Q5QUIsIDB4NUJFMENEMTkpO1xuICAgIHZhciBXID0gbmV3IEFycmF5KDY0KTtcbiAgICB2YXIgYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgajtcbiAgICB2YXIgVDEsIFQyO1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICBtW2wgPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsICUgMzIpO1xuICBtWygobCArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xuICAgIGEgPSBIQVNIWzBdOyBiID0gSEFTSFsxXTsgYyA9IEhBU0hbMl07IGQgPSBIQVNIWzNdOyBlID0gSEFTSFs0XTsgZiA9IEhBU0hbNV07IGcgPSBIQVNIWzZdOyBoID0gSEFTSFs3XTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDY0OyBqKyspIHtcbiAgICAgIGlmIChqIDwgMTYpIHtcbiAgICAgICAgV1tqXSA9IG1baiArIGldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgV1tqXSA9IHNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKEdhbW1hMTI1NihXW2ogLSAyXSksIFdbaiAtIDddKSwgR2FtbWEwMjU2KFdbaiAtIDE1XSkpLCBXW2ogLSAxNl0pO1xuICAgICAgfVxuICAgICAgVDEgPSBzYWZlX2FkZChzYWZlX2FkZChzYWZlX2FkZChzYWZlX2FkZChoLCBTaWdtYTEyNTYoZSkpLCBDaChlLCBmLCBnKSksIEtbal0pLCBXW2pdKTtcbiAgICAgIFQyID0gc2FmZV9hZGQoU2lnbWEwMjU2KGEpLCBNYWooYSwgYiwgYykpO1xuICAgICAgaCA9IGc7IGcgPSBmOyBmID0gZTsgZSA9IHNhZmVfYWRkKGQsIFQxKTsgZCA9IGM7IGMgPSBiOyBiID0gYTsgYSA9IHNhZmVfYWRkKFQxLCBUMik7XG4gICAgfVxuICAgIEhBU0hbMF0gPSBzYWZlX2FkZChhLCBIQVNIWzBdKTsgSEFTSFsxXSA9IHNhZmVfYWRkKGIsIEhBU0hbMV0pOyBIQVNIWzJdID0gc2FmZV9hZGQoYywgSEFTSFsyXSk7IEhBU0hbM10gPSBzYWZlX2FkZChkLCBIQVNIWzNdKTtcbiAgICBIQVNIWzRdID0gc2FmZV9hZGQoZSwgSEFTSFs0XSk7IEhBU0hbNV0gPSBzYWZlX2FkZChmLCBIQVNIWzVdKTsgSEFTSFs2XSA9IHNhZmVfYWRkKGcsIEhBU0hbNl0pOyBIQVNIWzddID0gc2FmZV9hZGQoaCwgSEFTSFs3XSk7XG4gIH1cbiAgcmV0dXJuIEhBU0g7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYTI1NihidWYpIHtcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfc2hhMjU2LCAzMiwgdHJ1ZSk7XG59O1xuIiwiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcubWltZSA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gdHlwZU1hcCBbT2JqZWN0XSBNYXAgb2YgTUlNRSB0eXBlIC0+IEFycmF5W2V4dGVuc2lvbnNdXG4gICAqIEBwYXJhbSAuLi5cbiAgICovXG4gIGNsYXNzIE1pbWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5fdHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5fZXh0ZW5zaW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGVmaW5lKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIG1pbWV0eXBlIC0+IHh0ZW5zaW9uIG1hcHBpbmdzLiAgRWFjaCBrZXkgaXMgYSBtaW1lLXR5cGUgdGhhdCBtYXBzXG4gICAgICogdG8gYW4gYXJyYXkgb2YgZXh0ZW5zaW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIHR5cGUuICBUaGUgZmlyc3QgZXh0ZW5zaW9uIGlzXG4gICAgICogdXNlZCBhcyB0aGUgZGVmYXVsdCBleHRlbnNpb24gZm9yIHRoZSB0eXBlLlxuICAgICAqXG4gICAgICogZS5nLiBtaW1lLmRlZmluZSh7J2F1ZGlvL29nZycsIFsnb2dhJywgJ29nZycsICdzcHgnXX0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIG1hcCAoT2JqZWN0KSB0eXBlIGRlZmluaXRpb25zXG4gICAgICovXG4gICAgZGVmaW5lKHR5cGVNYXAsIGZvcmNlKSB7XG4gICAgICBmb3IgKGxldCB0eXBlIGluIHR5cGVNYXApIHtcbiAgICAgICAgdmFyIGV4dGVuc2lvbnMgPSB0eXBlTWFwW3R5cGVdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZXh0ID0gZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgICBpZiAoIWZvcmNlICYmIChleHQgaW4gdGhpcy5fdHlwZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHQgdG8gY2hhbmdlIG1hcHBpbmcgZm9yIFwiJHtleHR9XCIgZXh0ZW5zaW9uIGZyb20gXCIke3RoaXMuX3R5cGVzW2V4dF19XCIgdG8gXCIke3R5cGV9XCIuIFBhc3MgXFxgZm9yY2U9dHJ1ZVxcYCB0byBhbGxvdyB0aGlzLCBvdGhlcndpc2UgcmVtb3ZlIFwiJHtleHR9XCIgZnJvbSB0aGUgbGlzdCBvZiBleHRlbnNpb25zIGZvciBcIiR7dHlwZX1cIi5gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl90eXBlc1tleHRdID0gdHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSBmaXJzdCBleHRlbnNpb24gYXMgZGVmYXVsdFxuICAgICAgICBpZiAoZm9yY2UgfHwgIXRoaXMuX2V4dGVuc2lvbnNbdHlwZV0pIHtcbiAgICAgICAgICB0aGlzLl9leHRlbnNpb25zW3R5cGVdID0gZXh0ZW5zaW9uc1swXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvb2t1cCBhIG1pbWUgdHlwZSBiYXNlZCBvbiBleHRlbnNpb25cbiAgICAgKi9cbiAgICBnZXRUeXBlKHBhdGgpIHtcbiAgICAgIHBhdGggPSBTdHJpbmcocGF0aCk7XG4gICAgICB2YXIgbGFzdCA9IHBhdGgucmVwbGFjZSgvXi4qWy9cXFxcXS8sICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGV4dCA9IGxhc3QucmVwbGFjZSgvXi4qXFwuLywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHZhciBoYXNQYXRoID0gbGFzdC5sZW5ndGggPCBwYXRoLmxlbmd0aDtcbiAgICAgIHZhciBoYXNEb3QgPSBleHQubGVuZ3RoIDwgbGFzdC5sZW5ndGggLSAxO1xuXG4gICAgICByZXR1cm4gKGhhc0RvdCB8fCAhaGFzUGF0aCkgJiYgdGhpcy5fdHlwZXNbZXh0XSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBmaWxlIGV4dGVuc2lvbiBhc3NvY2lhdGVkIHdpdGggYSBtaW1lIHR5cGVcbiAgICAgKi9cbiAgICBnZXRFeHRlbnNpb24odHlwZSkge1xuICAgICAgdHlwZSA9IC9eXFxzKihbXjtcXHNdKikvLnRlc3QodHlwZSkgJiYgUmVnRXhwLiQxO1xuICAgICAgcmV0dXJuIHR5cGUgJiYgdGhpcy5fZXh0ZW5zaW9uc1t0eXBlLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG4gICAgfVxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBNaW1lO1xuXG59LHt9XSwyOltmdW5jdGlvbihyLG1vZHVsZSxleHBvcnRzKXtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGNvbnN0IE1pbWUgPSByKCcuL01pbWUnKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXcgTWltZShyKCcuL3R5cGVzL3N0YW5kYXJkJyksIHIoJy4vdHlwZXMvb3RoZXInKSk7XG5cbn0se1wiLi9NaW1lXCI6MSxcIi4vdHlwZXMvb3RoZXJcIjozLFwiLi90eXBlcy9zdGFuZGFyZFwiOjR9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgbW9kdWxlLmV4cG9ydHM9e1wiYXBwbGljYXRpb24vcHJzLmN3d1wiOltcImN3d1wiXSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLnBpYy1idy1sYXJnZVwiOltcInBsYlwiXSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLnBpYy1idy1zbWFsbFwiOltcInBzYlwiXSxcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLnBpYy1idy12YXJcIjpbXCJwdmJcIl0sXCJhcHBsaWNhdGlvbi92bmQuM2dwcDIudGNhcFwiOltcInRjYXBcIl0sXCJhcHBsaWNhdGlvbi92bmQuM20ucG9zdC1pdC1ub3Rlc1wiOltcInB3blwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hY2NwYWMuc2ltcGx5LmFzb1wiOltcImFzb1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5hY2NwYWMuc2ltcGx5LmltcFwiOltcImltcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hY3Vjb2JvbFwiOltcImFjdVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hY3Vjb3JwXCI6W1wiYXRjXCIsXCJhY3V0Y1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5haXItYXBwbGljYXRpb24taW5zdGFsbGVyLXBhY2thZ2UremlwXCI6W1wiYWlyXCJdLFwiYXBwbGljYXRpb24vdm5kLmFkb2JlLmZvcm1zY2VudHJhbC5mY2R0XCI6W1wiZmNkdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5meHBcIjpbXCJmeHBcIixcImZ4cGxcIl0sXCJhcHBsaWNhdGlvbi92bmQuYWRvYmUueGRwK3htbFwiOltcInhkcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hZG9iZS54ZmRmXCI6W1wieGZkZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5haGVhZC5zcGFjZVwiOltcImFoZWFkXCJdLFwiYXBwbGljYXRpb24vdm5kLmFpcnppcC5maWxlc2VjdXJlLmF6ZlwiOltcImF6ZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5haXJ6aXAuZmlsZXNlY3VyZS5henNcIjpbXCJhenNcIl0sXCJhcHBsaWNhdGlvbi92bmQuYW1hem9uLmVib29rXCI6W1wiYXp3XCJdLFwiYXBwbGljYXRpb24vdm5kLmFtZXJpY2FuZHluYW1pY3MuYWNjXCI6W1wiYWNjXCJdLFwiYXBwbGljYXRpb24vdm5kLmFtaWdhLmFtaVwiOltcImFtaVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hbmRyb2lkLnBhY2thZ2UtYXJjaGl2ZVwiOltcImFwa1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5hbnNlci13ZWItY2VydGlmaWNhdGUtaXNzdWUtaW5pdGlhdGlvblwiOltcImNpaVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hbnNlci13ZWItZnVuZHMtdHJhbnNmZXItaW5pdGlhdGlvblwiOltcImZ0aVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hbnRpeC5nYW1lLWNvbXBvbmVudFwiOltcImF0eFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hcHBsZS5pbnN0YWxsZXIreG1sXCI6W1wibXBrZ1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsXCI6W1wibTN1OFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5hcHBsZS5wa3Bhc3NcIjpbXCJwa3Bhc3NcIl0sXCJhcHBsaWNhdGlvbi92bmQuYXJpc3RhbmV0d29ya3Muc3dpXCI6W1wic3dpXCJdLFwiYXBwbGljYXRpb24vdm5kLmFzdHJhZWEtc29mdHdhcmUuaW90YVwiOltcImlvdGFcIl0sXCJhcHBsaWNhdGlvbi92bmQuYXVkaW9ncmFwaFwiOltcImFlcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ibHVlaWNlLm11bHRpcGFzc1wiOltcIm1wbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ibWlcIjpbXCJibWlcIl0sXCJhcHBsaWNhdGlvbi92bmQuYnVzaW5lc3NvYmplY3RzXCI6W1wicmVwXCJdLFwiYXBwbGljYXRpb24vdm5kLmNoZW1kcmF3K3htbFwiOltcImNkeG1sXCJdLFwiYXBwbGljYXRpb24vdm5kLmNoaXBudXRzLmthcmFva2UtbW1kXCI6W1wibW1kXCJdLFwiYXBwbGljYXRpb24vdm5kLmNpbmRlcmVsbGFcIjpbXCJjZHlcIl0sXCJhcHBsaWNhdGlvbi92bmQuY2xheW1vcmVcIjpbXCJjbGFcIl0sXCJhcHBsaWNhdGlvbi92bmQuY2xvYW50by5ycDlcIjpbXCJycDlcIl0sXCJhcHBsaWNhdGlvbi92bmQuY2xvbmsuYzRncm91cFwiOltcImM0Z1wiLFwiYzRkXCIsXCJjNGZcIixcImM0cFwiLFwiYzR1XCJdLFwiYXBwbGljYXRpb24vdm5kLmNsdWV0cnVzdC5jYXJ0b21vYmlsZS1jb25maWdcIjpbXCJjMTFhbWNcIl0sXCJhcHBsaWNhdGlvbi92bmQuY2x1ZXRydXN0LmNhcnRvbW9iaWxlLWNvbmZpZy1wa2dcIjpbXCJjMTFhbXpcIl0sXCJhcHBsaWNhdGlvbi92bmQuY29tbW9uc3BhY2VcIjpbXCJjc3BcIl0sXCJhcHBsaWNhdGlvbi92bmQuY29udGFjdC5jbXNnXCI6W1wiY2RiY21zZ1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5jb3Ntb2NhbGxlclwiOltcImNtY1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyXCI6W1wiY2xreFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLmtleWJvYXJkXCI6W1wiY2xra1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLnBhbGV0dGVcIjpbXCJjbGtwXCJdLFwiYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIudGVtcGxhdGVcIjpbXCJjbGt0XCJdLFwiYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIud29yZGJhbmtcIjpbXCJjbGt3XCJdLFwiYXBwbGljYXRpb24vdm5kLmNyaXRpY2FsdG9vbHMud2JzK3htbFwiOltcIndic1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5jdGMtcG9zbWxcIjpbXCJwbWxcIl0sXCJhcHBsaWNhdGlvbi92bmQuY3Vwcy1wcGRcIjpbXCJwcGRcIl0sXCJhcHBsaWNhdGlvbi92bmQuY3VybC5jYXJcIjpbXCJjYXJcIl0sXCJhcHBsaWNhdGlvbi92bmQuY3VybC5wY3VybFwiOltcInBjdXJsXCJdLFwiYXBwbGljYXRpb24vdm5kLmRhcnRcIjpbXCJkYXJ0XCJdLFwiYXBwbGljYXRpb24vdm5kLmRhdGEtdmlzaW9uLnJkelwiOltcInJkelwiXSxcImFwcGxpY2F0aW9uL3ZuZC5kZWNlLmRhdGFcIjpbXCJ1dmZcIixcInV2dmZcIixcInV2ZFwiLFwidXZ2ZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5kZWNlLnR0bWwreG1sXCI6W1widXZ0XCIsXCJ1dnZ0XCJdLFwiYXBwbGljYXRpb24vdm5kLmRlY2UudW5zcGVjaWZpZWRcIjpbXCJ1dnhcIixcInV2dnhcIl0sXCJhcHBsaWNhdGlvbi92bmQuZGVjZS56aXBcIjpbXCJ1dnpcIixcInV2dnpcIl0sXCJhcHBsaWNhdGlvbi92bmQuZGVub3ZvLmZjc2VsYXlvdXQtbGlua1wiOltcImZlX2xhdW5jaFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5kbmFcIjpbXCJkbmFcIl0sXCJhcHBsaWNhdGlvbi92bmQuZG9sYnkubWxwXCI6W1wibWxwXCJdLFwiYXBwbGljYXRpb24vdm5kLmRwZ3JhcGhcIjpbXCJkcGdcIl0sXCJhcHBsaWNhdGlvbi92bmQuZHJlYW1mYWN0b3J5XCI6W1wiZGZhY1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5kcy1rZXlwb2ludFwiOltcImtweHhcIl0sXCJhcHBsaWNhdGlvbi92bmQuZHZiLmFpdFwiOltcImFpdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5kdmIuc2VydmljZVwiOltcInN2Y1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5keW5hZ2VvXCI6W1wiZ2VvXCJdLFwiYXBwbGljYXRpb24vdm5kLmVjb3dpbi5jaGFydFwiOltcIm1hZ1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5lbmxpdmVuXCI6W1wibm1sXCJdLFwiYXBwbGljYXRpb24vdm5kLmVwc29uLmVzZlwiOltcImVzZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5lcHNvbi5tc2ZcIjpbXCJtc2ZcIl0sXCJhcHBsaWNhdGlvbi92bmQuZXBzb24ucXVpY2thbmltZVwiOltcInFhbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5lcHNvbi5zYWx0XCI6W1wic2x0XCJdLFwiYXBwbGljYXRpb24vdm5kLmVwc29uLnNzZlwiOltcInNzZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5lc3ppZ25vMyt4bWxcIjpbXCJlczNcIixcImV0M1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5lenBpeC1hbGJ1bVwiOltcImV6MlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5lenBpeC1wYWNrYWdlXCI6W1wiZXozXCJdLFwiYXBwbGljYXRpb24vdm5kLmZkZlwiOltcImZkZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5mZHNuLm1zZWVkXCI6W1wibXNlZWRcIl0sXCJhcHBsaWNhdGlvbi92bmQuZmRzbi5zZWVkXCI6W1wic2VlZFwiLFwiZGF0YWxlc3NcIl0sXCJhcHBsaWNhdGlvbi92bmQuZmxvZ3JhcGhpdFwiOltcImdwaFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5mbHV4dGltZS5jbGlwXCI6W1wiZnRjXCJdLFwiYXBwbGljYXRpb24vdm5kLmZyYW1lbWFrZXJcIjpbXCJmbVwiLFwiZnJhbWVcIixcIm1ha2VyXCIsXCJib29rXCJdLFwiYXBwbGljYXRpb24vdm5kLmZyb2dhbnMuZm5jXCI6W1wiZm5jXCJdLFwiYXBwbGljYXRpb24vdm5kLmZyb2dhbnMubHRmXCI6W1wibHRmXCJdLFwiYXBwbGljYXRpb24vdm5kLmZzYy53ZWJsYXVuY2hcIjpbXCJmc2NcIl0sXCJhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5c1wiOltcIm9hc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzMlwiOltcIm9hMlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzM1wiOltcIm9hM1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzZ3BcIjpbXCJmZzVcIl0sXCJhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5c3Byc1wiOltcImJoMlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZGRkXCI6W1wiZGRkXCJdLFwiYXBwbGljYXRpb24vdm5kLmZ1aml4ZXJveC5kb2N1d29ya3NcIjpbXCJ4ZHdcIl0sXCJhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmRvY3V3b3Jrcy5iaW5kZXJcIjpbXCJ4YmRcIl0sXCJhcHBsaWNhdGlvbi92bmQuZnV6enlzaGVldFwiOltcImZ6c1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5nZW5vbWF0aXgudHV4ZWRvXCI6W1widHhkXCJdLFwiYXBwbGljYXRpb24vdm5kLmdlb2dlYnJhLmZpbGVcIjpbXCJnZ2JcIl0sXCJhcHBsaWNhdGlvbi92bmQuZ2VvZ2VicmEudG9vbFwiOltcImdndFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5nZW9tZXRyeS1leHBsb3JlclwiOltcImdleFwiLFwiZ3JlXCJdLFwiYXBwbGljYXRpb24vdm5kLmdlb25leHRcIjpbXCJneHRcIl0sXCJhcHBsaWNhdGlvbi92bmQuZ2VvcGxhblwiOltcImcyd1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5nZW9zcGFjZVwiOltcImczd1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5nbXhcIjpbXCJnbXhcIl0sXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMuZG9jdW1lbnRcIjpbXCJnZG9jXCJdLFwiYXBwbGljYXRpb24vdm5kLmdvb2dsZS1hcHBzLnByZXNlbnRhdGlvblwiOltcImdzbGlkZXNcIl0sXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMuc3ByZWFkc2hlZXRcIjpbXCJnc2hlZXRcIl0sXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbCt4bWxcIjpbXCJrbWxcIl0sXCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttelwiOltcImttelwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ncmFmZXFcIjpbXCJncWZcIixcImdxc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtYWNjb3VudFwiOltcImdhY1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtaGVscFwiOltcImdoZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtaWRlbnRpdHktbWVzc2FnZVwiOltcImdpbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtaW5qZWN0b3JcIjpbXCJncnZcIl0sXCJhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLXRvb2wtbWVzc2FnZVwiOltcImd0bVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtdG9vbC10ZW1wbGF0ZVwiOltcInRwbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtdmNhcmRcIjpbXCJ2Y2dcIl0sXCJhcHBsaWNhdGlvbi92bmQuaGFsK3htbFwiOltcImhhbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5oYW5kaGVsZC1lbnRlcnRhaW5tZW50K3htbFwiOltcInptbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5oYmNpXCI6W1wiaGJjaVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5oaGUubGVzc29uLXBsYXllclwiOltcImxlc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5ocC1ocGdsXCI6W1wiaHBnbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ocC1ocGlkXCI6W1wiaHBpZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ocC1ocHNcIjpbXCJocHNcIl0sXCJhcHBsaWNhdGlvbi92bmQuaHAtamx5dFwiOltcImpsdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ocC1wY2xcIjpbXCJwY2xcIl0sXCJhcHBsaWNhdGlvbi92bmQuaHAtcGNseGxcIjpbXCJwY2x4bFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5oeWRyb3N0YXRpeC5zb2YtZGF0YVwiOltcInNmZC1oZHN0eFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5pYm0ubWluaXBheVwiOltcIm1weVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5pYm0ubW9kY2FwXCI6W1wiYWZwXCIsXCJsaXN0YWZwXCIsXCJsaXN0MzgyMFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5pYm0ucmlnaHRzLW1hbmFnZW1lbnRcIjpbXCJpcm1cIl0sXCJhcHBsaWNhdGlvbi92bmQuaWJtLnNlY3VyZS1jb250YWluZXJcIjpbXCJzY1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5pY2Nwcm9maWxlXCI6W1wiaWNjXCIsXCJpY21cIl0sXCJhcHBsaWNhdGlvbi92bmQuaWdsb2FkZXJcIjpbXCJpZ2xcIl0sXCJhcHBsaWNhdGlvbi92bmQuaW1tZXJ2aXNpb24taXZwXCI6W1wiaXZwXCJdLFwiYXBwbGljYXRpb24vdm5kLmltbWVydmlzaW9uLWl2dVwiOltcIml2dVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5pbnNvcnMuaWdtXCI6W1wiaWdtXCJdLFwiYXBwbGljYXRpb24vdm5kLmludGVyY29uLmZvcm1uZXRcIjpbXCJ4cHdcIixcInhweFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5pbnRlcmdlb1wiOltcImkyZ1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5pbnR1LnFib1wiOltcInFib1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5pbnR1LnFmeFwiOltcInFmeFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5pcHVucGx1Z2dlZC5yY3Byb2ZpbGVcIjpbXCJyY3Byb2ZpbGVcIl0sXCJhcHBsaWNhdGlvbi92bmQuaXJlcG9zaXRvcnkucGFja2FnZSt4bWxcIjpbXCJpcnBcIl0sXCJhcHBsaWNhdGlvbi92bmQuaXMteHByXCI6W1wieHByXCJdLFwiYXBwbGljYXRpb24vdm5kLmlzYWMuZmNzXCI6W1wiZmNzXCJdLFwiYXBwbGljYXRpb24vdm5kLmphbVwiOltcImphbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5qY3AuamF2YW1lLm1pZGxldC1ybXNcIjpbXCJybXNcIl0sXCJhcHBsaWNhdGlvbi92bmQuamlzcFwiOltcImppc3BcIl0sXCJhcHBsaWNhdGlvbi92bmQuam9vc3Quam9kYS1hcmNoaXZlXCI6W1wiam9kYVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5rYWhvb3R6XCI6W1wia3R6XCIsXCJrdHJcIl0sXCJhcHBsaWNhdGlvbi92bmQua2RlLmthcmJvblwiOltcImthcmJvblwiXSxcImFwcGxpY2F0aW9uL3ZuZC5rZGUua2NoYXJ0XCI6W1wiY2hydFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5rZGUua2Zvcm11bGFcIjpbXCJrZm9cIl0sXCJhcHBsaWNhdGlvbi92bmQua2RlLmtpdmlvXCI6W1wiZmx3XCJdLFwiYXBwbGljYXRpb24vdm5kLmtkZS5rb250b3VyXCI6W1wia29uXCJdLFwiYXBwbGljYXRpb24vdm5kLmtkZS5rcHJlc2VudGVyXCI6W1wia3ByXCIsXCJrcHRcIl0sXCJhcHBsaWNhdGlvbi92bmQua2RlLmtzcHJlYWRcIjpbXCJrc3BcIl0sXCJhcHBsaWNhdGlvbi92bmQua2RlLmt3b3JkXCI6W1wia3dkXCIsXCJrd3RcIl0sXCJhcHBsaWNhdGlvbi92bmQua2VuYW1lYWFwcFwiOltcImh0a2VcIl0sXCJhcHBsaWNhdGlvbi92bmQua2lkc3BpcmF0aW9uXCI6W1wia2lhXCJdLFwiYXBwbGljYXRpb24vdm5kLmtpbmFyXCI6W1wia25lXCIsXCJrbnBcIl0sXCJhcHBsaWNhdGlvbi92bmQua29hblwiOltcInNrcFwiLFwic2tkXCIsXCJza3RcIixcInNrbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5rb2Rhay1kZXNjcmlwdG9yXCI6W1wic3NlXCJdLFwiYXBwbGljYXRpb24vdm5kLmxhcy5sYXMreG1sXCI6W1wibGFzeG1sXCJdLFwiYXBwbGljYXRpb24vdm5kLmxsYW1hZ3JhcGhpY3MubGlmZS1iYWxhbmNlLmRlc2t0b3BcIjpbXCJsYmRcIl0sXCJhcHBsaWNhdGlvbi92bmQubGxhbWFncmFwaGljcy5saWZlLWJhbGFuY2UuZXhjaGFuZ2UreG1sXCI6W1wibGJlXCJdLFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLTEtMi0zXCI6W1wiMTIzXCJdLFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLWFwcHJvYWNoXCI6W1wiYXByXCJdLFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLWZyZWVsYW5jZVwiOltcInByZVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5sb3R1cy1ub3Rlc1wiOltcIm5zZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5sb3R1cy1vcmdhbml6ZXJcIjpbXCJvcmdcIl0sXCJhcHBsaWNhdGlvbi92bmQubG90dXMtc2NyZWVuY2FtXCI6W1wic2NtXCJdLFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLXdvcmRwcm9cIjpbXCJsd3BcIl0sXCJhcHBsaWNhdGlvbi92bmQubWFjcG9ydHMucG9ydHBrZ1wiOltcInBvcnRwa2dcIl0sXCJhcHBsaWNhdGlvbi92bmQubWNkXCI6W1wibWNkXCJdLFwiYXBwbGljYXRpb24vdm5kLm1lZGNhbGNkYXRhXCI6W1wibWMxXCJdLFwiYXBwbGljYXRpb24vdm5kLm1lZGlhc3RhdGlvbi5jZGtleVwiOltcImNka2V5XCJdLFwiYXBwbGljYXRpb24vdm5kLm1mZXJcIjpbXCJtd2ZcIl0sXCJhcHBsaWNhdGlvbi92bmQubWZtcFwiOltcIm1mbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5taWNyb2dyYWZ4LmZsb1wiOltcImZsb1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5taWNyb2dyYWZ4LmlneFwiOltcImlneFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5taWZcIjpbXCJtaWZcIl0sXCJhcHBsaWNhdGlvbi92bmQubW9iaXVzLmRhZlwiOltcImRhZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tb2JpdXMuZGlzXCI6W1wiZGlzXCJdLFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5tYmtcIjpbXCJtYmtcIl0sXCJhcHBsaWNhdGlvbi92bmQubW9iaXVzLm1xeVwiOltcIm1xeVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubXNsXCI6W1wibXNsXCJdLFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5wbGNcIjpbXCJwbGNcIl0sXCJhcHBsaWNhdGlvbi92bmQubW9iaXVzLnR4ZlwiOltcInR4ZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tb3BodW4uYXBwbGljYXRpb25cIjpbXCJtcG5cIl0sXCJhcHBsaWNhdGlvbi92bmQubW9waHVuLmNlcnRpZmljYXRlXCI6W1wibXBjXCJdLFwiYXBwbGljYXRpb24vdm5kLm1vemlsbGEueHVsK3htbFwiOltcInh1bFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1hcnRnYWxyeVwiOltcImNpbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1jYWItY29tcHJlc3NlZFwiOltcImNhYlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbFwiOltcInhsc1wiLFwieGxtXCIsXCJ4bGFcIixcInhsY1wiLFwieGx0XCIsXCJ4bHdcIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuYWRkaW4ubWFjcm9lbmFibGVkLjEyXCI6W1wieGxhbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5iaW5hcnkubWFjcm9lbmFibGVkLjEyXCI6W1wieGxzYlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5tYWNyb2VuYWJsZWQuMTJcIjpbXCJ4bHNtXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnRlbXBsYXRlLm1hY3JvZW5hYmxlZC4xMlwiOltcInhsdG1cIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdFwiOltcImVvdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1odG1saGVscFwiOltcImNobVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1pbXNcIjpbXCJpbXNcIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtbHJtXCI6W1wibHJtXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLW9mZmljZXRoZW1lXCI6W1widGhteFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1vdXRsb29rXCI6W1wibXNnXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLXBraS5zZWNjYXRcIjpbXCJjYXRcIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtcGtpLnN0bFwiOltcInN0bFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50XCI6W1wicHB0XCIsXCJwcHNcIixcInBvdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LmFkZGluLm1hY3JvZW5hYmxlZC4xMlwiOltcInBwYW1cIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5wcmVzZW50YXRpb24ubWFjcm9lbmFibGVkLjEyXCI6W1wicHB0bVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnNsaWRlLm1hY3JvZW5hYmxlZC4xMlwiOltcInNsZG1cIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5zbGlkZXNob3cubWFjcm9lbmFibGVkLjEyXCI6W1wicHBzbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnRlbXBsYXRlLm1hY3JvZW5hYmxlZC4xMlwiOltcInBvdG1cIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtcHJvamVjdFwiOltcIm1wcFwiLFwibXB0XCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLXdvcmQuZG9jdW1lbnQubWFjcm9lbmFibGVkLjEyXCI6W1wiZG9jbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLnRlbXBsYXRlLm1hY3JvZW5hYmxlZC4xMlwiOltcImRvdG1cIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtd29ya3NcIjpbXCJ3cHNcIixcIndrc1wiLFwid2NtXCIsXCJ3ZGJcIl0sXCJhcHBsaWNhdGlvbi92bmQubXMtd3BsXCI6W1wid3BsXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zLXhwc2RvY3VtZW50XCI6W1wieHBzXCJdLFwiYXBwbGljYXRpb24vdm5kLm1zZXFcIjpbXCJtc2VxXCJdLFwiYXBwbGljYXRpb24vdm5kLm11c2ljaWFuXCI6W1wibXVzXCJdLFwiYXBwbGljYXRpb24vdm5kLm11dmVlLnN0eWxlXCI6W1wibXN0eVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5teW5mY1wiOltcInRhZ2xldFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5uZXVyb2xhbmd1YWdlLm5sdVwiOltcIm5sdVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5uaXRmXCI6W1wibnRmXCIsXCJuaXRmXCJdLFwiYXBwbGljYXRpb24vdm5kLm5vYmxlbmV0LWRpcmVjdG9yeVwiOltcIm5uZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ub2JsZW5ldC1zZWFsZXJcIjpbXCJubnNcIl0sXCJhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtd2ViXCI6W1wibm53XCJdLFwiYXBwbGljYXRpb24vdm5kLm5va2lhLm4tZ2FnZS5kYXRhXCI6W1wibmdkYXRcIl0sXCJhcHBsaWNhdGlvbi92bmQubm9raWEubi1nYWdlLnN5bWJpYW4uaW5zdGFsbFwiOltcIm4tZ2FnZVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yYWRpby1wcmVzZXRcIjpbXCJycHN0XCJdLFwiYXBwbGljYXRpb24vdm5kLm5va2lhLnJhZGlvLXByZXNldHNcIjpbXCJycHNzXCJdLFwiYXBwbGljYXRpb24vdm5kLm5vdmFkaWdtLmVkbVwiOltcImVkbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5lZHhcIjpbXCJlZHhcIl0sXCJhcHBsaWNhdGlvbi92bmQubm92YWRpZ20uZXh0XCI6W1wiZXh0XCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5jaGFydFwiOltcIm9kY1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuY2hhcnQtdGVtcGxhdGVcIjpbXCJvdGNcIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmRhdGFiYXNlXCI6W1wib2RiXCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5mb3JtdWxhXCI6W1wib2RmXCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5mb3JtdWxhLXRlbXBsYXRlXCI6W1wib2RmdFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZ3JhcGhpY3NcIjpbXCJvZGdcIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmdyYXBoaWNzLXRlbXBsYXRlXCI6W1wib3RnXCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5pbWFnZVwiOltcIm9kaVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuaW1hZ2UtdGVtcGxhdGVcIjpbXCJvdGlcIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnByZXNlbnRhdGlvblwiOltcIm9kcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uLXRlbXBsYXRlXCI6W1wib3RwXCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldFwiOltcIm9kc1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuc3ByZWFkc2hlZXQtdGVtcGxhdGVcIjpbXCJvdHNcIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHRcIjpbXCJvZHRcIl0sXCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtbWFzdGVyXCI6W1wib2RtXCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0LXRlbXBsYXRlXCI6W1wib3R0XCJdLFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0LXdlYlwiOltcIm90aFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vbHBjLXN1Z2FyXCI6W1wieG9cIl0sXCJhcHBsaWNhdGlvbi92bmQub21hLmRkMit4bWxcIjpbXCJkZDJcIl0sXCJhcHBsaWNhdGlvbi92bmQub3Blbm9mZmljZW9yZy5leHRlbnNpb25cIjpbXCJveHRcIl0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uXCI6W1wicHB0eFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZVwiOltcInNsZHhcIl0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGVzaG93XCI6W1wicHBzeFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC50ZW1wbGF0ZVwiOltcInBvdHhcIl0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldFwiOltcInhsc3hcIl0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC50ZW1wbGF0ZVwiOltcInhsdHhcIl0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudFwiOltcImRvY3hcIl0sXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC50ZW1wbGF0ZVwiOltcImRvdHhcIl0sXCJhcHBsaWNhdGlvbi92bmQub3NnZW8ubWFwZ3VpZGUucGFja2FnZVwiOltcIm1ncFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5vc2dpLmRwXCI6W1wiZHBcIl0sXCJhcHBsaWNhdGlvbi92bmQub3NnaS5zdWJzeXN0ZW1cIjpbXCJlc2FcIl0sXCJhcHBsaWNhdGlvbi92bmQucGFsbVwiOltcInBkYlwiLFwicHFhXCIsXCJvcHJjXCJdLFwiYXBwbGljYXRpb24vdm5kLnBhd2FhZmlsZVwiOltcInBhd1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5wZy5mb3JtYXRcIjpbXCJzdHJcIl0sXCJhcHBsaWNhdGlvbi92bmQucGcub3Nhc2xpXCI6W1wiZWk2XCJdLFwiYXBwbGljYXRpb24vdm5kLnBpY3NlbFwiOltcImVmaWZcIl0sXCJhcHBsaWNhdGlvbi92bmQucG1pLndpZGdldFwiOltcIndnXCJdLFwiYXBwbGljYXRpb24vdm5kLnBvY2tldGxlYXJuXCI6W1wicGxmXCJdLFwiYXBwbGljYXRpb24vdm5kLnBvd2VyYnVpbGRlcjZcIjpbXCJwYmRcIl0sXCJhcHBsaWNhdGlvbi92bmQucHJldmlld3N5c3RlbXMuYm94XCI6W1wiYm94XCJdLFwiYXBwbGljYXRpb24vdm5kLnByb3RldXMubWFnYXppbmVcIjpbXCJtZ3pcIl0sXCJhcHBsaWNhdGlvbi92bmQucHVibGlzaGFyZS1kZWx0YS10cmVlXCI6W1wicXBzXCJdLFwiYXBwbGljYXRpb24vdm5kLnB2aS5wdGlkMVwiOltcInB0aWRcIl0sXCJhcHBsaWNhdGlvbi92bmQucXVhcmsucXVhcmt4cHJlc3NcIjpbXCJxeGRcIixcInF4dFwiLFwicXdkXCIsXCJxd3RcIixcInF4bFwiLFwicXhiXCJdLFwiYXBwbGljYXRpb24vdm5kLnJlYWx2bmMuYmVkXCI6W1wiYmVkXCJdLFwiYXBwbGljYXRpb24vdm5kLnJlY29yZGFyZS5tdXNpY3htbFwiOltcIm14bFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5yZWNvcmRhcmUubXVzaWN4bWwreG1sXCI6W1wibXVzaWN4bWxcIl0sXCJhcHBsaWNhdGlvbi92bmQucmlnLmNyeXB0b25vdGVcIjpbXCJjcnlwdG9ub3RlXCJdLFwiYXBwbGljYXRpb24vdm5kLnJpbS5jb2RcIjpbXCJjb2RcIl0sXCJhcHBsaWNhdGlvbi92bmQucm4tcmVhbG1lZGlhXCI6W1wicm1cIl0sXCJhcHBsaWNhdGlvbi92bmQucm4tcmVhbG1lZGlhLXZiclwiOltcInJtdmJcIl0sXCJhcHBsaWNhdGlvbi92bmQucm91dGU2Ni5saW5rNjYreG1sXCI6W1wibGluazY2XCJdLFwiYXBwbGljYXRpb24vdm5kLnNhaWxpbmd0cmFja2VyLnRyYWNrXCI6W1wic3RcIl0sXCJhcHBsaWNhdGlvbi92bmQuc2VlbWFpbFwiOltcInNlZVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zZW1hXCI6W1wic2VtYVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zZW1kXCI6W1wic2VtZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zZW1mXCI6W1wic2VtZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5mb3JtZGF0YVwiOltcImlmbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5mb3JtdGVtcGxhdGVcIjpbXCJpdHBcIl0sXCJhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQuaW50ZXJjaGFuZ2VcIjpbXCJpaWZcIl0sXCJhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQucGFja2FnZVwiOltcImlwa1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5zaW10ZWNoLW1pbmRtYXBwZXJcIjpbXCJ0d2RcIixcInR3ZHNcIl0sXCJhcHBsaWNhdGlvbi92bmQuc21hZlwiOltcIm1tZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zbWFydC50ZWFjaGVyXCI6W1widGVhY2hlclwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zb2xlbnQuc2RrbSt4bWxcIjpbXCJzZGttXCIsXCJzZGtkXCJdLFwiYXBwbGljYXRpb24vdm5kLnNwb3RmaXJlLmR4cFwiOltcImR4cFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zcG90ZmlyZS5zZnNcIjpbXCJzZnNcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmNhbGNcIjpbXCJzZGNcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmRyYXdcIjpbXCJzZGFcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmltcHJlc3NcIjpbXCJzZGRcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLm1hdGhcIjpbXCJzbWZcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLndyaXRlclwiOltcInNkd1wiLFwidm9yXCJdLFwiYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi53cml0ZXItZ2xvYmFsXCI6W1wic2dsXCJdLFwiYXBwbGljYXRpb24vdm5kLnN0ZXBtYW5pYS5wYWNrYWdlXCI6W1wic216aXBcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3RlcG1hbmlhLnN0ZXBjaGFydFwiOltcInNtXCJdLFwiYXBwbGljYXRpb24vdm5kLnN1bi53YWRsK3htbFwiOltcIndhZGxcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5jYWxjXCI6W1wic3hjXCJdLFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwuY2FsYy50ZW1wbGF0ZVwiOltcInN0Y1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmRyYXdcIjpbXCJzeGRcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5kcmF3LnRlbXBsYXRlXCI6W1wic3RkXCJdLFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwuaW1wcmVzc1wiOltcInN4aVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmltcHJlc3MudGVtcGxhdGVcIjpbXCJzdGlcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5tYXRoXCI6W1wic3htXCJdLFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyXCI6W1wic3h3XCJdLFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyLmdsb2JhbFwiOltcInN4Z1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLndyaXRlci50ZW1wbGF0ZVwiOltcInN0d1wiXSxcImFwcGxpY2F0aW9uL3ZuZC5zdXMtY2FsZW5kYXJcIjpbXCJzdXNcIixcInN1c3BcIl0sXCJhcHBsaWNhdGlvbi92bmQuc3ZkXCI6W1wic3ZkXCJdLFwiYXBwbGljYXRpb24vdm5kLnN5bWJpYW4uaW5zdGFsbFwiOltcInNpc1wiLFwic2lzeFwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zeW5jbWwreG1sXCI6W1wieHNtXCJdLFwiYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kbSt3YnhtbFwiOltcImJkbVwiXSxcImFwcGxpY2F0aW9uL3ZuZC5zeW5jbWwuZG0reG1sXCI6W1wieGRtXCJdLFwiYXBwbGljYXRpb24vdm5kLnRhby5pbnRlbnQtbW9kdWxlLWFyY2hpdmVcIjpbXCJ0YW9cIl0sXCJhcHBsaWNhdGlvbi92bmQudGNwZHVtcC5wY2FwXCI6W1wicGNhcFwiLFwiY2FwXCIsXCJkbXBcIl0sXCJhcHBsaWNhdGlvbi92bmQudG1vYmlsZS1saXZldHZcIjpbXCJ0bW9cIl0sXCJhcHBsaWNhdGlvbi92bmQudHJpZC50cHRcIjpbXCJ0cHRcIl0sXCJhcHBsaWNhdGlvbi92bmQudHJpc2NhcGUubXhzXCI6W1wibXhzXCJdLFwiYXBwbGljYXRpb24vdm5kLnRydWVhcHBcIjpbXCJ0cmFcIl0sXCJhcHBsaWNhdGlvbi92bmQudWZkbFwiOltcInVmZFwiLFwidWZkbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC51aXEudGhlbWVcIjpbXCJ1dHpcIl0sXCJhcHBsaWNhdGlvbi92bmQudW1hamluXCI6W1widW1qXCJdLFwiYXBwbGljYXRpb24vdm5kLnVuaXR5XCI6W1widW5pdHl3ZWJcIl0sXCJhcHBsaWNhdGlvbi92bmQudW9tbCt4bWxcIjpbXCJ1b21sXCJdLFwiYXBwbGljYXRpb24vdm5kLnZjeFwiOltcInZjeFwiXSxcImFwcGxpY2F0aW9uL3ZuZC52aXNpb1wiOltcInZzZFwiLFwidnN0XCIsXCJ2c3NcIixcInZzd1wiXSxcImFwcGxpY2F0aW9uL3ZuZC52aXNpb25hcnlcIjpbXCJ2aXNcIl0sXCJhcHBsaWNhdGlvbi92bmQudnNmXCI6W1widnNmXCJdLFwiYXBwbGljYXRpb24vdm5kLndhcC53YnhtbFwiOltcIndieG1sXCJdLFwiYXBwbGljYXRpb24vdm5kLndhcC53bWxjXCI6W1wid21sY1wiXSxcImFwcGxpY2F0aW9uL3ZuZC53YXAud21sc2NyaXB0Y1wiOltcIndtbHNjXCJdLFwiYXBwbGljYXRpb24vdm5kLndlYnR1cmJvXCI6W1wid3RiXCJdLFwiYXBwbGljYXRpb24vdm5kLndvbGZyYW0ucGxheWVyXCI6W1wibmJwXCJdLFwiYXBwbGljYXRpb24vdm5kLndvcmRwZXJmZWN0XCI6W1wid3BkXCJdLFwiYXBwbGljYXRpb24vdm5kLndxZFwiOltcIndxZFwiXSxcImFwcGxpY2F0aW9uL3ZuZC53dC5zdGZcIjpbXCJzdGZcIl0sXCJhcHBsaWNhdGlvbi92bmQueGFyYVwiOltcInhhclwiXSxcImFwcGxpY2F0aW9uL3ZuZC54ZmRsXCI6W1wieGZkbFwiXSxcImFwcGxpY2F0aW9uL3ZuZC55YW1haGEuaHYtZGljXCI6W1wiaHZkXCJdLFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi1zY3JpcHRcIjpbXCJodnNcIl0sXCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLmh2LXZvaWNlXCI6W1wiaHZwXCJdLFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5vcGVuc2NvcmVmb3JtYXRcIjpbXCJvc2ZcIl0sXCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLm9wZW5zY29yZWZvcm1hdC5vc2ZwdmcreG1sXCI6W1wib3NmcHZnXCJdLFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5zbWFmLWF1ZGlvXCI6W1wic2FmXCJdLFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5zbWFmLXBocmFzZVwiOltcInNwZlwiXSxcImFwcGxpY2F0aW9uL3ZuZC55ZWxsb3dyaXZlci1jdXN0b20tbWVudVwiOltcImNtcFwiXSxcImFwcGxpY2F0aW9uL3ZuZC56dWxcIjpbXCJ6aXJcIixcInppcnpcIl0sXCJhcHBsaWNhdGlvbi92bmQuenphenouZGVjayt4bWxcIjpbXCJ6YXpcIl0sXCJhcHBsaWNhdGlvbi94LTd6LWNvbXByZXNzZWRcIjpbXCI3elwiXSxcImFwcGxpY2F0aW9uL3gtYWJpd29yZFwiOltcImFid1wiXSxcImFwcGxpY2F0aW9uL3gtYWNlLWNvbXByZXNzZWRcIjpbXCJhY2VcIl0sXCJhcHBsaWNhdGlvbi94LWFwcGxlLWRpc2tpbWFnZVwiOltdLFwiYXBwbGljYXRpb24veC1hcmpcIjpbXCJhcmpcIl0sXCJhcHBsaWNhdGlvbi94LWF1dGhvcndhcmUtYmluXCI6W1wiYWFiXCIsXCJ4MzJcIixcInUzMlwiLFwidm94XCJdLFwiYXBwbGljYXRpb24veC1hdXRob3J3YXJlLW1hcFwiOltcImFhbVwiXSxcImFwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1zZWdcIjpbXCJhYXNcIl0sXCJhcHBsaWNhdGlvbi94LWJjcGlvXCI6W1wiYmNwaW9cIl0sXCJhcHBsaWNhdGlvbi94LWJkb2NcIjpbXSxcImFwcGxpY2F0aW9uL3gtYml0dG9ycmVudFwiOltcInRvcnJlbnRcIl0sXCJhcHBsaWNhdGlvbi94LWJsb3JiXCI6W1wiYmxiXCIsXCJibG9yYlwiXSxcImFwcGxpY2F0aW9uL3gtYnppcFwiOltcImJ6XCJdLFwiYXBwbGljYXRpb24veC1iemlwMlwiOltcImJ6MlwiLFwiYm96XCJdLFwiYXBwbGljYXRpb24veC1jYnJcIjpbXCJjYnJcIixcImNiYVwiLFwiY2J0XCIsXCJjYnpcIixcImNiN1wiXSxcImFwcGxpY2F0aW9uL3gtY2RsaW5rXCI6W1widmNkXCJdLFwiYXBwbGljYXRpb24veC1jZnMtY29tcHJlc3NlZFwiOltcImNmc1wiXSxcImFwcGxpY2F0aW9uL3gtY2hhdFwiOltcImNoYXRcIl0sXCJhcHBsaWNhdGlvbi94LWNoZXNzLXBnblwiOltcInBnblwiXSxcImFwcGxpY2F0aW9uL3gtY2hyb21lLWV4dGVuc2lvblwiOltcImNyeFwiXSxcImFwcGxpY2F0aW9uL3gtY29jb2FcIjpbXCJjY29cIl0sXCJhcHBsaWNhdGlvbi94LWNvbmZlcmVuY2VcIjpbXCJuc2NcIl0sXCJhcHBsaWNhdGlvbi94LWNwaW9cIjpbXCJjcGlvXCJdLFwiYXBwbGljYXRpb24veC1jc2hcIjpbXCJjc2hcIl0sXCJhcHBsaWNhdGlvbi94LWRlYmlhbi1wYWNrYWdlXCI6W1widWRlYlwiXSxcImFwcGxpY2F0aW9uL3gtZGdjLWNvbXByZXNzZWRcIjpbXCJkZ2NcIl0sXCJhcHBsaWNhdGlvbi94LWRpcmVjdG9yXCI6W1wiZGlyXCIsXCJkY3JcIixcImR4clwiLFwiY3N0XCIsXCJjY3RcIixcImN4dFwiLFwidzNkXCIsXCJmZ2RcIixcInN3YVwiXSxcImFwcGxpY2F0aW9uL3gtZG9vbVwiOltcIndhZFwiXSxcImFwcGxpY2F0aW9uL3gtZHRibmN4K3htbFwiOltcIm5jeFwiXSxcImFwcGxpY2F0aW9uL3gtZHRib29rK3htbFwiOltcImR0YlwiXSxcImFwcGxpY2F0aW9uL3gtZHRicmVzb3VyY2UreG1sXCI6W1wicmVzXCJdLFwiYXBwbGljYXRpb24veC1kdmlcIjpbXCJkdmlcIl0sXCJhcHBsaWNhdGlvbi94LWVudm95XCI6W1wiZXZ5XCJdLFwiYXBwbGljYXRpb24veC1ldmFcIjpbXCJldmFcIl0sXCJhcHBsaWNhdGlvbi94LWZvbnQtYmRmXCI6W1wiYmRmXCJdLFwiYXBwbGljYXRpb24veC1mb250LWdob3N0c2NyaXB0XCI6W1wiZ3NmXCJdLFwiYXBwbGljYXRpb24veC1mb250LWxpbnV4LXBzZlwiOltcInBzZlwiXSxcImFwcGxpY2F0aW9uL3gtZm9udC1vdGZcIjpbXSxcImFwcGxpY2F0aW9uL3gtZm9udC1wY2ZcIjpbXCJwY2ZcIl0sXCJhcHBsaWNhdGlvbi94LWZvbnQtc25mXCI6W1wic25mXCJdLFwiYXBwbGljYXRpb24veC1mb250LXR0ZlwiOltcInR0ZlwiLFwidHRjXCJdLFwiYXBwbGljYXRpb24veC1mb250LXR5cGUxXCI6W1wicGZhXCIsXCJwZmJcIixcInBmbVwiLFwiYWZtXCJdLFwiYXBwbGljYXRpb24veC1mcmVlYXJjXCI6W1wiYXJjXCJdLFwiYXBwbGljYXRpb24veC1mdXR1cmVzcGxhc2hcIjpbXCJzcGxcIl0sXCJhcHBsaWNhdGlvbi94LWdjYS1jb21wcmVzc2VkXCI6W1wiZ2NhXCJdLFwiYXBwbGljYXRpb24veC1nbHVseFwiOltcInVseFwiXSxcImFwcGxpY2F0aW9uL3gtZ251bWVyaWNcIjpbXCJnbnVtZXJpY1wiXSxcImFwcGxpY2F0aW9uL3gtZ3JhbXBzLXhtbFwiOltcImdyYW1wc1wiXSxcImFwcGxpY2F0aW9uL3gtZ3RhclwiOltcImd0YXJcIl0sXCJhcHBsaWNhdGlvbi94LWhkZlwiOltcImhkZlwiXSxcImFwcGxpY2F0aW9uL3gtaHR0cGQtcGhwXCI6W1wicGhwXCJdLFwiYXBwbGljYXRpb24veC1pbnN0YWxsLWluc3RydWN0aW9uc1wiOltcImluc3RhbGxcIl0sXCJhcHBsaWNhdGlvbi94LWlzbzk2NjAtaW1hZ2VcIjpbXSxcImFwcGxpY2F0aW9uL3gtamF2YS1hcmNoaXZlLWRpZmZcIjpbXCJqYXJkaWZmXCJdLFwiYXBwbGljYXRpb24veC1qYXZhLWpubHAtZmlsZVwiOltcImpubHBcIl0sXCJhcHBsaWNhdGlvbi94LWxhdGV4XCI6W1wibGF0ZXhcIl0sXCJhcHBsaWNhdGlvbi94LWx1YS1ieXRlY29kZVwiOltcImx1YWNcIl0sXCJhcHBsaWNhdGlvbi94LWx6aC1jb21wcmVzc2VkXCI6W1wibHpoXCIsXCJsaGFcIl0sXCJhcHBsaWNhdGlvbi94LW1ha2VzZWxmXCI6W1wicnVuXCJdLFwiYXBwbGljYXRpb24veC1taWVcIjpbXCJtaWVcIl0sXCJhcHBsaWNhdGlvbi94LW1vYmlwb2NrZXQtZWJvb2tcIjpbXCJwcmNcIixcIm1vYmlcIl0sXCJhcHBsaWNhdGlvbi94LW1zLWFwcGxpY2F0aW9uXCI6W1wiYXBwbGljYXRpb25cIl0sXCJhcHBsaWNhdGlvbi94LW1zLXNob3J0Y3V0XCI6W1wibG5rXCJdLFwiYXBwbGljYXRpb24veC1tcy13bWRcIjpbXCJ3bWRcIl0sXCJhcHBsaWNhdGlvbi94LW1zLXdtelwiOltcIndtelwiXSxcImFwcGxpY2F0aW9uL3gtbXMteGJhcFwiOltcInhiYXBcIl0sXCJhcHBsaWNhdGlvbi94LW1zYWNjZXNzXCI6W1wibWRiXCJdLFwiYXBwbGljYXRpb24veC1tc2JpbmRlclwiOltcIm9iZFwiXSxcImFwcGxpY2F0aW9uL3gtbXNjYXJkZmlsZVwiOltcImNyZFwiXSxcImFwcGxpY2F0aW9uL3gtbXNjbGlwXCI6W1wiY2xwXCJdLFwiYXBwbGljYXRpb24veC1tc2Rvcy1wcm9ncmFtXCI6W10sXCJhcHBsaWNhdGlvbi94LW1zZG93bmxvYWRcIjpbXCJjb21cIixcImJhdFwiXSxcImFwcGxpY2F0aW9uL3gtbXNtZWRpYXZpZXdcIjpbXCJtdmJcIixcIm0xM1wiLFwibTE0XCJdLFwiYXBwbGljYXRpb24veC1tc21ldGFmaWxlXCI6W1wid21mXCIsXCJlbWZcIixcImVtelwiXSxcImFwcGxpY2F0aW9uL3gtbXNtb25leVwiOltcIm1ueVwiXSxcImFwcGxpY2F0aW9uL3gtbXNwdWJsaXNoZXJcIjpbXCJwdWJcIl0sXCJhcHBsaWNhdGlvbi94LW1zc2NoZWR1bGVcIjpbXCJzY2RcIl0sXCJhcHBsaWNhdGlvbi94LW1zdGVybWluYWxcIjpbXCJ0cm1cIl0sXCJhcHBsaWNhdGlvbi94LW1zd3JpdGVcIjpbXCJ3cmlcIl0sXCJhcHBsaWNhdGlvbi94LW5ldGNkZlwiOltcIm5jXCIsXCJjZGZcIl0sXCJhcHBsaWNhdGlvbi94LW5zLXByb3h5LWF1dG9jb25maWdcIjpbXCJwYWNcIl0sXCJhcHBsaWNhdGlvbi94LW56YlwiOltcIm56YlwiXSxcImFwcGxpY2F0aW9uL3gtcGVybFwiOltcInBsXCIsXCJwbVwiXSxcImFwcGxpY2F0aW9uL3gtcGlsb3RcIjpbXSxcImFwcGxpY2F0aW9uL3gtcGtjczEyXCI6W1wicDEyXCIsXCJwZnhcIl0sXCJhcHBsaWNhdGlvbi94LXBrY3M3LWNlcnRpZmljYXRlc1wiOltcInA3YlwiLFwic3BjXCJdLFwiYXBwbGljYXRpb24veC1wa2NzNy1jZXJ0cmVxcmVzcFwiOltcInA3clwiXSxcImFwcGxpY2F0aW9uL3gtcmFyLWNvbXByZXNzZWRcIjpbXCJyYXJcIl0sXCJhcHBsaWNhdGlvbi94LXJlZGhhdC1wYWNrYWdlLW1hbmFnZXJcIjpbXCJycG1cIl0sXCJhcHBsaWNhdGlvbi94LXJlc2VhcmNoLWluZm8tc3lzdGVtc1wiOltcInJpc1wiXSxcImFwcGxpY2F0aW9uL3gtc2VhXCI6W1wic2VhXCJdLFwiYXBwbGljYXRpb24veC1zaFwiOltcInNoXCJdLFwiYXBwbGljYXRpb24veC1zaGFyXCI6W1wic2hhclwiXSxcImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCI6W1wic3dmXCJdLFwiYXBwbGljYXRpb24veC1zaWx2ZXJsaWdodC1hcHBcIjpbXCJ4YXBcIl0sXCJhcHBsaWNhdGlvbi94LXNxbFwiOltcInNxbFwiXSxcImFwcGxpY2F0aW9uL3gtc3R1ZmZpdFwiOltcInNpdFwiXSxcImFwcGxpY2F0aW9uL3gtc3R1ZmZpdHhcIjpbXCJzaXR4XCJdLFwiYXBwbGljYXRpb24veC1zdWJyaXBcIjpbXCJzcnRcIl0sXCJhcHBsaWNhdGlvbi94LXN2NGNwaW9cIjpbXCJzdjRjcGlvXCJdLFwiYXBwbGljYXRpb24veC1zdjRjcmNcIjpbXCJzdjRjcmNcIl0sXCJhcHBsaWNhdGlvbi94LXQzdm0taW1hZ2VcIjpbXCJ0M1wiXSxcImFwcGxpY2F0aW9uL3gtdGFkc1wiOltcImdhbVwiXSxcImFwcGxpY2F0aW9uL3gtdGFyXCI6W1widGFyXCJdLFwiYXBwbGljYXRpb24veC10Y2xcIjpbXCJ0Y2xcIixcInRrXCJdLFwiYXBwbGljYXRpb24veC10ZXhcIjpbXCJ0ZXhcIl0sXCJhcHBsaWNhdGlvbi94LXRleC10Zm1cIjpbXCJ0Zm1cIl0sXCJhcHBsaWNhdGlvbi94LXRleGluZm9cIjpbXCJ0ZXhpbmZvXCIsXCJ0ZXhpXCJdLFwiYXBwbGljYXRpb24veC10Z2lmXCI6W1wib2JqXCJdLFwiYXBwbGljYXRpb24veC11c3RhclwiOltcInVzdGFyXCJdLFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LWhkZFwiOltcImhkZFwiXSxcImFwcGxpY2F0aW9uL3gtdmlydHVhbGJveC1vdmFcIjpbXCJvdmFcIl0sXCJhcHBsaWNhdGlvbi94LXZpcnR1YWxib3gtb3ZmXCI6W1wib3ZmXCJdLFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LXZib3hcIjpbXCJ2Ym94XCJdLFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LXZib3gtZXh0cGFja1wiOltcInZib3gtZXh0cGFja1wiXSxcImFwcGxpY2F0aW9uL3gtdmlydHVhbGJveC12ZGlcIjpbXCJ2ZGlcIl0sXCJhcHBsaWNhdGlvbi94LXZpcnR1YWxib3gtdmhkXCI6W1widmhkXCJdLFwiYXBwbGljYXRpb24veC12aXJ0dWFsYm94LXZtZGtcIjpbXCJ2bWRrXCJdLFwiYXBwbGljYXRpb24veC13YWlzLXNvdXJjZVwiOltcInNyY1wiXSxcImFwcGxpY2F0aW9uL3gtd2ViLWFwcC1tYW5pZmVzdCtqc29uXCI6W1wid2ViYXBwXCJdLFwiYXBwbGljYXRpb24veC14NTA5LWNhLWNlcnRcIjpbXCJkZXJcIixcImNydFwiLFwicGVtXCJdLFwiYXBwbGljYXRpb24veC14ZmlnXCI6W1wiZmlnXCJdLFwiYXBwbGljYXRpb24veC14bGlmZit4bWxcIjpbXCJ4bGZcIl0sXCJhcHBsaWNhdGlvbi94LXhwaW5zdGFsbFwiOltcInhwaVwiXSxcImFwcGxpY2F0aW9uL3gteHpcIjpbXCJ4elwiXSxcImFwcGxpY2F0aW9uL3gtem1hY2hpbmVcIjpbXCJ6MVwiLFwiejJcIixcInozXCIsXCJ6NFwiLFwiejVcIixcIno2XCIsXCJ6N1wiLFwiejhcIl0sXCJhdWRpby92bmQuZGVjZS5hdWRpb1wiOltcInV2YVwiLFwidXZ2YVwiXSxcImF1ZGlvL3ZuZC5kaWdpdGFsLXdpbmRzXCI6W1wiZW9sXCJdLFwiYXVkaW8vdm5kLmRyYVwiOltcImRyYVwiXSxcImF1ZGlvL3ZuZC5kdHNcIjpbXCJkdHNcIl0sXCJhdWRpby92bmQuZHRzLmhkXCI6W1wiZHRzaGRcIl0sXCJhdWRpby92bmQubHVjZW50LnZvaWNlXCI6W1wibHZwXCJdLFwiYXVkaW8vdm5kLm1zLXBsYXlyZWFkeS5tZWRpYS5weWFcIjpbXCJweWFcIl0sXCJhdWRpby92bmQubnVlcmEuZWNlbHA0ODAwXCI6W1wiZWNlbHA0ODAwXCJdLFwiYXVkaW8vdm5kLm51ZXJhLmVjZWxwNzQ3MFwiOltcImVjZWxwNzQ3MFwiXSxcImF1ZGlvL3ZuZC5udWVyYS5lY2VscDk2MDBcIjpbXCJlY2VscDk2MDBcIl0sXCJhdWRpby92bmQucmlwXCI6W1wicmlwXCJdLFwiYXVkaW8veC1hYWNcIjpbXCJhYWNcIl0sXCJhdWRpby94LWFpZmZcIjpbXCJhaWZcIixcImFpZmZcIixcImFpZmNcIl0sXCJhdWRpby94LWNhZlwiOltcImNhZlwiXSxcImF1ZGlvL3gtZmxhY1wiOltcImZsYWNcIl0sXCJhdWRpby94LW00YVwiOltdLFwiYXVkaW8veC1tYXRyb3NrYVwiOltcIm1rYVwiXSxcImF1ZGlvL3gtbXBlZ3VybFwiOltcIm0zdVwiXSxcImF1ZGlvL3gtbXMtd2F4XCI6W1wid2F4XCJdLFwiYXVkaW8veC1tcy13bWFcIjpbXCJ3bWFcIl0sXCJhdWRpby94LXBuLXJlYWxhdWRpb1wiOltcInJhbVwiLFwicmFcIl0sXCJhdWRpby94LXBuLXJlYWxhdWRpby1wbHVnaW5cIjpbXCJybXBcIl0sXCJhdWRpby94LXJlYWxhdWRpb1wiOltdLFwiYXVkaW8veC13YXZcIjpbXSxcImNoZW1pY2FsL3gtY2R4XCI6W1wiY2R4XCJdLFwiY2hlbWljYWwveC1jaWZcIjpbXCJjaWZcIl0sXCJjaGVtaWNhbC94LWNtZGZcIjpbXCJjbWRmXCJdLFwiY2hlbWljYWwveC1jbWxcIjpbXCJjbWxcIl0sXCJjaGVtaWNhbC94LWNzbWxcIjpbXCJjc21sXCJdLFwiY2hlbWljYWwveC14eXpcIjpbXCJ4eXpcIl0sXCJpbWFnZS9wcnMuYnRpZlwiOltcImJ0aWZcIl0sXCJpbWFnZS92bmQuYWRvYmUucGhvdG9zaG9wXCI6W1wicHNkXCJdLFwiaW1hZ2Uvdm5kLmRlY2UuZ3JhcGhpY1wiOltcInV2aVwiLFwidXZ2aVwiLFwidXZnXCIsXCJ1dnZnXCJdLFwiaW1hZ2Uvdm5kLmRqdnVcIjpbXCJkanZ1XCIsXCJkanZcIl0sXCJpbWFnZS92bmQuZHZiLnN1YnRpdGxlXCI6W10sXCJpbWFnZS92bmQuZHdnXCI6W1wiZHdnXCJdLFwiaW1hZ2Uvdm5kLmR4ZlwiOltcImR4ZlwiXSxcImltYWdlL3ZuZC5mYXN0Ymlkc2hlZXRcIjpbXCJmYnNcIl0sXCJpbWFnZS92bmQuZnB4XCI6W1wiZnB4XCJdLFwiaW1hZ2Uvdm5kLmZzdFwiOltcImZzdFwiXSxcImltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLW1tclwiOltcIm1tclwiXSxcImltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLXJsY1wiOltcInJsY1wiXSxcImltYWdlL3ZuZC5tcy1tb2RpXCI6W1wibWRpXCJdLFwiaW1hZ2Uvdm5kLm1zLXBob3RvXCI6W1wid2RwXCJdLFwiaW1hZ2Uvdm5kLm5ldC1mcHhcIjpbXCJucHhcIl0sXCJpbWFnZS92bmQud2FwLndibXBcIjpbXCJ3Ym1wXCJdLFwiaW1hZ2Uvdm5kLnhpZmZcIjpbXCJ4aWZcIl0sXCJpbWFnZS94LTNkc1wiOltcIjNkc1wiXSxcImltYWdlL3gtY211LXJhc3RlclwiOltcInJhc1wiXSxcImltYWdlL3gtY214XCI6W1wiY214XCJdLFwiaW1hZ2UveC1mcmVlaGFuZFwiOltcImZoXCIsXCJmaGNcIixcImZoNFwiLFwiZmg1XCIsXCJmaDdcIl0sXCJpbWFnZS94LWljb25cIjpbXCJpY29cIl0sXCJpbWFnZS94LWpuZ1wiOltcImpuZ1wiXSxcImltYWdlL3gtbXJzaWQtaW1hZ2VcIjpbXCJzaWRcIl0sXCJpbWFnZS94LW1zLWJtcFwiOltdLFwiaW1hZ2UveC1wY3hcIjpbXCJwY3hcIl0sXCJpbWFnZS94LXBpY3RcIjpbXCJwaWNcIixcInBjdFwiXSxcImltYWdlL3gtcG9ydGFibGUtYW55bWFwXCI6W1wicG5tXCJdLFwiaW1hZ2UveC1wb3J0YWJsZS1iaXRtYXBcIjpbXCJwYm1cIl0sXCJpbWFnZS94LXBvcnRhYmxlLWdyYXltYXBcIjpbXCJwZ21cIl0sXCJpbWFnZS94LXBvcnRhYmxlLXBpeG1hcFwiOltcInBwbVwiXSxcImltYWdlL3gtcmdiXCI6W1wicmdiXCJdLFwiaW1hZ2UveC10Z2FcIjpbXCJ0Z2FcIl0sXCJpbWFnZS94LXhiaXRtYXBcIjpbXCJ4Ym1cIl0sXCJpbWFnZS94LXhwaXhtYXBcIjpbXCJ4cG1cIl0sXCJpbWFnZS94LXh3aW5kb3dkdW1wXCI6W1wieHdkXCJdLFwibW9kZWwvdm5kLmNvbGxhZGEreG1sXCI6W1wiZGFlXCJdLFwibW9kZWwvdm5kLmR3ZlwiOltcImR3ZlwiXSxcIm1vZGVsL3ZuZC5nZGxcIjpbXCJnZGxcIl0sXCJtb2RlbC92bmQuZ3R3XCI6W1wiZ3R3XCJdLFwibW9kZWwvdm5kLm10c1wiOltcIm10c1wiXSxcIm1vZGVsL3ZuZC52dHVcIjpbXCJ2dHVcIl0sXCJ0ZXh0L3Bycy5saW5lcy50YWdcIjpbXCJkc2NcIl0sXCJ0ZXh0L3ZuZC5jdXJsXCI6W1wiY3VybFwiXSxcInRleHQvdm5kLmN1cmwuZGN1cmxcIjpbXCJkY3VybFwiXSxcInRleHQvdm5kLmN1cmwubWN1cmxcIjpbXCJtY3VybFwiXSxcInRleHQvdm5kLmN1cmwuc2N1cmxcIjpbXCJzY3VybFwiXSxcInRleHQvdm5kLmR2Yi5zdWJ0aXRsZVwiOltcInN1YlwiXSxcInRleHQvdm5kLmZseVwiOltcImZseVwiXSxcInRleHQvdm5kLmZtaS5mbGV4c3RvclwiOltcImZseFwiXSxcInRleHQvdm5kLmdyYXBodml6XCI6W1wiZ3ZcIl0sXCJ0ZXh0L3ZuZC5pbjNkLjNkbWxcIjpbXCIzZG1sXCJdLFwidGV4dC92bmQuaW4zZC5zcG90XCI6W1wic3BvdFwiXSxcInRleHQvdm5kLnN1bi5qMm1lLmFwcC1kZXNjcmlwdG9yXCI6W1wiamFkXCJdLFwidGV4dC92bmQud2FwLndtbFwiOltcIndtbFwiXSxcInRleHQvdm5kLndhcC53bWxzY3JpcHRcIjpbXCJ3bWxzXCJdLFwidGV4dC94LWFzbVwiOltcInNcIixcImFzbVwiXSxcInRleHQveC1jXCI6W1wiY1wiLFwiY2NcIixcImN4eFwiLFwiY3BwXCIsXCJoXCIsXCJoaFwiLFwiZGljXCJdLFwidGV4dC94LWNvbXBvbmVudFwiOltcImh0Y1wiXSxcInRleHQveC1mb3J0cmFuXCI6W1wiZlwiLFwiZm9yXCIsXCJmNzdcIixcImY5MFwiXSxcInRleHQveC1oYW5kbGViYXJzLXRlbXBsYXRlXCI6W1wiaGJzXCJdLFwidGV4dC94LWphdmEtc291cmNlXCI6W1wiamF2YVwiXSxcInRleHQveC1sdWFcIjpbXCJsdWFcIl0sXCJ0ZXh0L3gtbWFya2Rvd25cIjpbXCJta2RcIl0sXCJ0ZXh0L3gtbmZvXCI6W1wibmZvXCJdLFwidGV4dC94LW9wbWxcIjpbXCJvcG1sXCJdLFwidGV4dC94LW9yZ1wiOltdLFwidGV4dC94LXBhc2NhbFwiOltcInBcIixcInBhc1wiXSxcInRleHQveC1wcm9jZXNzaW5nXCI6W1wicGRlXCJdLFwidGV4dC94LXNhc3NcIjpbXCJzYXNzXCJdLFwidGV4dC94LXNjc3NcIjpbXCJzY3NzXCJdLFwidGV4dC94LXNldGV4dFwiOltcImV0eFwiXSxcInRleHQveC1zZnZcIjpbXCJzZnZcIl0sXCJ0ZXh0L3gtc3VzZS15bXBcIjpbXCJ5bXBcIl0sXCJ0ZXh0L3gtdXVlbmNvZGVcIjpbXCJ1dVwiXSxcInRleHQveC12Y2FsZW5kYXJcIjpbXCJ2Y3NcIl0sXCJ0ZXh0L3gtdmNhcmRcIjpbXCJ2Y2ZcIl0sXCJ2aWRlby92bmQuZGVjZS5oZFwiOltcInV2aFwiLFwidXZ2aFwiXSxcInZpZGVvL3ZuZC5kZWNlLm1vYmlsZVwiOltcInV2bVwiLFwidXZ2bVwiXSxcInZpZGVvL3ZuZC5kZWNlLnBkXCI6W1widXZwXCIsXCJ1dnZwXCJdLFwidmlkZW8vdm5kLmRlY2Uuc2RcIjpbXCJ1dnNcIixcInV2dnNcIl0sXCJ2aWRlby92bmQuZGVjZS52aWRlb1wiOltcInV2dlwiLFwidXZ2dlwiXSxcInZpZGVvL3ZuZC5kdmIuZmlsZVwiOltcImR2YlwiXSxcInZpZGVvL3ZuZC5mdnRcIjpbXCJmdnRcIl0sXCJ2aWRlby92bmQubXBlZ3VybFwiOltcIm14dVwiLFwibTR1XCJdLFwidmlkZW8vdm5kLm1zLXBsYXlyZWFkeS5tZWRpYS5weXZcIjpbXCJweXZcIl0sXCJ2aWRlby92bmQudXZ2dS5tcDRcIjpbXCJ1dnVcIixcInV2dnVcIl0sXCJ2aWRlby92bmQudml2b1wiOltcInZpdlwiXSxcInZpZGVvL3gtZjR2XCI6W1wiZjR2XCJdLFwidmlkZW8veC1mbGlcIjpbXCJmbGlcIl0sXCJ2aWRlby94LWZsdlwiOltcImZsdlwiXSxcInZpZGVvL3gtbTR2XCI6W1wibTR2XCJdLFwidmlkZW8veC1tYXRyb3NrYVwiOltcIm1rdlwiLFwibWszZFwiLFwibWtzXCJdLFwidmlkZW8veC1tbmdcIjpbXCJtbmdcIl0sXCJ2aWRlby94LW1zLWFzZlwiOltcImFzZlwiLFwiYXN4XCJdLFwidmlkZW8veC1tcy12b2JcIjpbXCJ2b2JcIl0sXCJ2aWRlby94LW1zLXdtXCI6W1wid21cIl0sXCJ2aWRlby94LW1zLXdtdlwiOltcIndtdlwiXSxcInZpZGVvL3gtbXMtd214XCI6W1wid214XCJdLFwidmlkZW8veC1tcy13dnhcIjpbXCJ3dnhcIl0sXCJ2aWRlby94LW1zdmlkZW9cIjpbXCJhdmlcIl0sXCJ2aWRlby94LXNnaS1tb3ZpZVwiOltcIm1vdmllXCJdLFwidmlkZW8veC1zbXZcIjpbXCJzbXZcIl0sXCJ4LWNvbmZlcmVuY2UveC1jb29sdGFsa1wiOltcImljZVwiXX1cbn0se31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICBtb2R1bGUuZXhwb3J0cz17XCJhcHBsaWNhdGlvbi9hbmRyZXctaW5zZXRcIjpbXCJlelwiXSxcImFwcGxpY2F0aW9uL2FwcGxpeHdhcmVcIjpbXCJhd1wiXSxcImFwcGxpY2F0aW9uL2F0b20reG1sXCI6W1wiYXRvbVwiXSxcImFwcGxpY2F0aW9uL2F0b21jYXQreG1sXCI6W1wiYXRvbWNhdFwiXSxcImFwcGxpY2F0aW9uL2F0b21zdmMreG1sXCI6W1wiYXRvbXN2Y1wiXSxcImFwcGxpY2F0aW9uL2Jkb2NcIjpbXCJiZG9jXCJdLFwiYXBwbGljYXRpb24vY2N4bWwreG1sXCI6W1wiY2N4bWxcIl0sXCJhcHBsaWNhdGlvbi9jZG1pLWNhcGFiaWxpdHlcIjpbXCJjZG1pYVwiXSxcImFwcGxpY2F0aW9uL2NkbWktY29udGFpbmVyXCI6W1wiY2RtaWNcIl0sXCJhcHBsaWNhdGlvbi9jZG1pLWRvbWFpblwiOltcImNkbWlkXCJdLFwiYXBwbGljYXRpb24vY2RtaS1vYmplY3RcIjpbXCJjZG1pb1wiXSxcImFwcGxpY2F0aW9uL2NkbWktcXVldWVcIjpbXCJjZG1pcVwiXSxcImFwcGxpY2F0aW9uL2N1LXNlZW1lXCI6W1wiY3VcIl0sXCJhcHBsaWNhdGlvbi9kYXNoK3htbFwiOltcIm1wZFwiXSxcImFwcGxpY2F0aW9uL2Rhdm1vdW50K3htbFwiOltcImRhdm1vdW50XCJdLFwiYXBwbGljYXRpb24vZG9jYm9vayt4bWxcIjpbXCJkYmtcIl0sXCJhcHBsaWNhdGlvbi9kc3NjK2RlclwiOltcImRzc2NcIl0sXCJhcHBsaWNhdGlvbi9kc3NjK3htbFwiOltcInhkc3NjXCJdLFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdFwiOltcImVjbWFcIl0sXCJhcHBsaWNhdGlvbi9lbW1hK3htbFwiOltcImVtbWFcIl0sXCJhcHBsaWNhdGlvbi9lcHViK3ppcFwiOltcImVwdWJcIl0sXCJhcHBsaWNhdGlvbi9leGlcIjpbXCJleGlcIl0sXCJhcHBsaWNhdGlvbi9mb250LXRkcGZyXCI6W1wicGZyXCJdLFwiYXBwbGljYXRpb24vZm9udC13b2ZmXCI6W1wid29mZlwiXSxcImFwcGxpY2F0aW9uL2ZvbnQtd29mZjJcIjpbXCJ3b2ZmMlwiXSxcImFwcGxpY2F0aW9uL2dlbytqc29uXCI6W1wiZ2VvanNvblwiXSxcImFwcGxpY2F0aW9uL2dtbCt4bWxcIjpbXCJnbWxcIl0sXCJhcHBsaWNhdGlvbi9ncHgreG1sXCI6W1wiZ3B4XCJdLFwiYXBwbGljYXRpb24vZ3hmXCI6W1wiZ3hmXCJdLFwiYXBwbGljYXRpb24vZ3ppcFwiOltcImd6XCJdLFwiYXBwbGljYXRpb24vaHlwZXJzdHVkaW9cIjpbXCJzdGtcIl0sXCJhcHBsaWNhdGlvbi9pbmttbCt4bWxcIjpbXCJpbmtcIixcImlua21sXCJdLFwiYXBwbGljYXRpb24vaXBmaXhcIjpbXCJpcGZpeFwiXSxcImFwcGxpY2F0aW9uL2phdmEtYXJjaGl2ZVwiOltcImphclwiLFwid2FyXCIsXCJlYXJcIl0sXCJhcHBsaWNhdGlvbi9qYXZhLXNlcmlhbGl6ZWQtb2JqZWN0XCI6W1wic2VyXCJdLFwiYXBwbGljYXRpb24vamF2YS12bVwiOltcImNsYXNzXCJdLFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiOltcImpzXCIsXCJtanNcIl0sXCJhcHBsaWNhdGlvbi9qc29uXCI6W1wianNvblwiLFwibWFwXCJdLFwiYXBwbGljYXRpb24vanNvbjVcIjpbXCJqc29uNVwiXSxcImFwcGxpY2F0aW9uL2pzb25tbCtqc29uXCI6W1wianNvbm1sXCJdLFwiYXBwbGljYXRpb24vbGQranNvblwiOltcImpzb25sZFwiXSxcImFwcGxpY2F0aW9uL2xvc3QreG1sXCI6W1wibG9zdHhtbFwiXSxcImFwcGxpY2F0aW9uL21hYy1iaW5oZXg0MFwiOltcImhxeFwiXSxcImFwcGxpY2F0aW9uL21hYy1jb21wYWN0cHJvXCI6W1wiY3B0XCJdLFwiYXBwbGljYXRpb24vbWFkcyt4bWxcIjpbXCJtYWRzXCJdLFwiYXBwbGljYXRpb24vbWFuaWZlc3QranNvblwiOltcIndlYm1hbmlmZXN0XCJdLFwiYXBwbGljYXRpb24vbWFyY1wiOltcIm1yY1wiXSxcImFwcGxpY2F0aW9uL21hcmN4bWwreG1sXCI6W1wibXJjeFwiXSxcImFwcGxpY2F0aW9uL21hdGhlbWF0aWNhXCI6W1wibWFcIixcIm5iXCIsXCJtYlwiXSxcImFwcGxpY2F0aW9uL21hdGhtbCt4bWxcIjpbXCJtYXRobWxcIl0sXCJhcHBsaWNhdGlvbi9tYm94XCI6W1wibWJveFwiXSxcImFwcGxpY2F0aW9uL21lZGlhc2VydmVyY29udHJvbCt4bWxcIjpbXCJtc2NtbFwiXSxcImFwcGxpY2F0aW9uL21ldGFsaW5rK3htbFwiOltcIm1ldGFsaW5rXCJdLFwiYXBwbGljYXRpb24vbWV0YWxpbms0K3htbFwiOltcIm1ldGE0XCJdLFwiYXBwbGljYXRpb24vbWV0cyt4bWxcIjpbXCJtZXRzXCJdLFwiYXBwbGljYXRpb24vbW9kcyt4bWxcIjpbXCJtb2RzXCJdLFwiYXBwbGljYXRpb24vbXAyMVwiOltcIm0yMVwiLFwibXAyMVwiXSxcImFwcGxpY2F0aW9uL21wNFwiOltcIm1wNHNcIixcIm00cFwiXSxcImFwcGxpY2F0aW9uL21zd29yZFwiOltcImRvY1wiLFwiZG90XCJdLFwiYXBwbGljYXRpb24vbXhmXCI6W1wibXhmXCJdLFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI6W1wiYmluXCIsXCJkbXNcIixcImxyZlwiLFwibWFyXCIsXCJzb1wiLFwiZGlzdFwiLFwiZGlzdHpcIixcInBrZ1wiLFwiYnBrXCIsXCJkdW1wXCIsXCJlbGNcIixcImRlcGxveVwiLFwiZXhlXCIsXCJkbGxcIixcImRlYlwiLFwiZG1nXCIsXCJpc29cIixcImltZ1wiLFwibXNpXCIsXCJtc3BcIixcIm1zbVwiLFwiYnVmZmVyXCJdLFwiYXBwbGljYXRpb24vb2RhXCI6W1wib2RhXCJdLFwiYXBwbGljYXRpb24vb2VicHMtcGFja2FnZSt4bWxcIjpbXCJvcGZcIl0sXCJhcHBsaWNhdGlvbi9vZ2dcIjpbXCJvZ3hcIl0sXCJhcHBsaWNhdGlvbi9vbWRvYyt4bWxcIjpbXCJvbWRvY1wiXSxcImFwcGxpY2F0aW9uL29uZW5vdGVcIjpbXCJvbmV0b2NcIixcIm9uZXRvYzJcIixcIm9uZXRtcFwiLFwib25lcGtnXCJdLFwiYXBwbGljYXRpb24vb3hwc1wiOltcIm94cHNcIl0sXCJhcHBsaWNhdGlvbi9wYXRjaC1vcHMtZXJyb3IreG1sXCI6W1wieGVyXCJdLFwiYXBwbGljYXRpb24vcGRmXCI6W1wicGRmXCJdLFwiYXBwbGljYXRpb24vcGdwLWVuY3J5cHRlZFwiOltcInBncFwiXSxcImFwcGxpY2F0aW9uL3BncC1zaWduYXR1cmVcIjpbXCJhc2NcIixcInNpZ1wiXSxcImFwcGxpY2F0aW9uL3BpY3MtcnVsZXNcIjpbXCJwcmZcIl0sXCJhcHBsaWNhdGlvbi9wa2NzMTBcIjpbXCJwMTBcIl0sXCJhcHBsaWNhdGlvbi9wa2NzNy1taW1lXCI6W1wicDdtXCIsXCJwN2NcIl0sXCJhcHBsaWNhdGlvbi9wa2NzNy1zaWduYXR1cmVcIjpbXCJwN3NcIl0sXCJhcHBsaWNhdGlvbi9wa2NzOFwiOltcInA4XCJdLFwiYXBwbGljYXRpb24vcGtpeC1hdHRyLWNlcnRcIjpbXCJhY1wiXSxcImFwcGxpY2F0aW9uL3BraXgtY2VydFwiOltcImNlclwiXSxcImFwcGxpY2F0aW9uL3BraXgtY3JsXCI6W1wiY3JsXCJdLFwiYXBwbGljYXRpb24vcGtpeC1wa2lwYXRoXCI6W1wicGtpcGF0aFwiXSxcImFwcGxpY2F0aW9uL3BraXhjbXBcIjpbXCJwa2lcIl0sXCJhcHBsaWNhdGlvbi9wbHMreG1sXCI6W1wicGxzXCJdLFwiYXBwbGljYXRpb24vcG9zdHNjcmlwdFwiOltcImFpXCIsXCJlcHNcIixcInBzXCJdLFwiYXBwbGljYXRpb24vcHNrYyt4bWxcIjpbXCJwc2tjeG1sXCJdLFwiYXBwbGljYXRpb24vcmRmK3htbFwiOltcInJkZlwiXSxcImFwcGxpY2F0aW9uL3JlZ2luZm8reG1sXCI6W1wicmlmXCJdLFwiYXBwbGljYXRpb24vcmVsYXgtbmctY29tcGFjdC1zeW50YXhcIjpbXCJybmNcIl0sXCJhcHBsaWNhdGlvbi9yZXNvdXJjZS1saXN0cyt4bWxcIjpbXCJybFwiXSxcImFwcGxpY2F0aW9uL3Jlc291cmNlLWxpc3RzLWRpZmYreG1sXCI6W1wicmxkXCJdLFwiYXBwbGljYXRpb24vcmxzLXNlcnZpY2VzK3htbFwiOltcInJzXCJdLFwiYXBwbGljYXRpb24vcnBraS1naG9zdGJ1c3RlcnNcIjpbXCJnYnJcIl0sXCJhcHBsaWNhdGlvbi9ycGtpLW1hbmlmZXN0XCI6W1wibWZ0XCJdLFwiYXBwbGljYXRpb24vcnBraS1yb2FcIjpbXCJyb2FcIl0sXCJhcHBsaWNhdGlvbi9yc2QreG1sXCI6W1wicnNkXCJdLFwiYXBwbGljYXRpb24vcnNzK3htbFwiOltcInJzc1wiXSxcImFwcGxpY2F0aW9uL3J0ZlwiOltcInJ0ZlwiXSxcImFwcGxpY2F0aW9uL3NibWwreG1sXCI6W1wic2JtbFwiXSxcImFwcGxpY2F0aW9uL3NjdnAtY3YtcmVxdWVzdFwiOltcInNjcVwiXSxcImFwcGxpY2F0aW9uL3NjdnAtY3YtcmVzcG9uc2VcIjpbXCJzY3NcIl0sXCJhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlcXVlc3RcIjpbXCJzcHFcIl0sXCJhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlc3BvbnNlXCI6W1wic3BwXCJdLFwiYXBwbGljYXRpb24vc2RwXCI6W1wic2RwXCJdLFwiYXBwbGljYXRpb24vc2V0LXBheW1lbnQtaW5pdGlhdGlvblwiOltcInNldHBheVwiXSxcImFwcGxpY2F0aW9uL3NldC1yZWdpc3RyYXRpb24taW5pdGlhdGlvblwiOltcInNldHJlZ1wiXSxcImFwcGxpY2F0aW9uL3NoZit4bWxcIjpbXCJzaGZcIl0sXCJhcHBsaWNhdGlvbi9zbWlsK3htbFwiOltcInNtaVwiLFwic21pbFwiXSxcImFwcGxpY2F0aW9uL3NwYXJxbC1xdWVyeVwiOltcInJxXCJdLFwiYXBwbGljYXRpb24vc3BhcnFsLXJlc3VsdHMreG1sXCI6W1wic3J4XCJdLFwiYXBwbGljYXRpb24vc3Jnc1wiOltcImdyYW1cIl0sXCJhcHBsaWNhdGlvbi9zcmdzK3htbFwiOltcImdyeG1sXCJdLFwiYXBwbGljYXRpb24vc3J1K3htbFwiOltcInNydVwiXSxcImFwcGxpY2F0aW9uL3NzZGwreG1sXCI6W1wic3NkbFwiXSxcImFwcGxpY2F0aW9uL3NzbWwreG1sXCI6W1wic3NtbFwiXSxcImFwcGxpY2F0aW9uL3RlaSt4bWxcIjpbXCJ0ZWlcIixcInRlaWNvcnB1c1wiXSxcImFwcGxpY2F0aW9uL3RocmF1ZCt4bWxcIjpbXCJ0ZmlcIl0sXCJhcHBsaWNhdGlvbi90aW1lc3RhbXBlZC1kYXRhXCI6W1widHNkXCJdLFwiYXBwbGljYXRpb24vdm9pY2V4bWwreG1sXCI6W1widnhtbFwiXSxcImFwcGxpY2F0aW9uL3dpZGdldFwiOltcIndndFwiXSxcImFwcGxpY2F0aW9uL3dpbmhscFwiOltcImhscFwiXSxcImFwcGxpY2F0aW9uL3dzZGwreG1sXCI6W1wid3NkbFwiXSxcImFwcGxpY2F0aW9uL3dzcG9saWN5K3htbFwiOltcIndzcG9saWN5XCJdLFwiYXBwbGljYXRpb24veGFtbCt4bWxcIjpbXCJ4YW1sXCJdLFwiYXBwbGljYXRpb24veGNhcC1kaWZmK3htbFwiOltcInhkZlwiXSxcImFwcGxpY2F0aW9uL3hlbmMreG1sXCI6W1wieGVuY1wiXSxcImFwcGxpY2F0aW9uL3hodG1sK3htbFwiOltcInhodG1sXCIsXCJ4aHRcIl0sXCJhcHBsaWNhdGlvbi94bWxcIjpbXCJ4bWxcIixcInhzbFwiLFwieHNkXCIsXCJybmdcIl0sXCJhcHBsaWNhdGlvbi94bWwtZHRkXCI6W1wiZHRkXCJdLFwiYXBwbGljYXRpb24veG9wK3htbFwiOltcInhvcFwiXSxcImFwcGxpY2F0aW9uL3hwcm9jK3htbFwiOltcInhwbFwiXSxcImFwcGxpY2F0aW9uL3hzbHQreG1sXCI6W1wieHNsdFwiXSxcImFwcGxpY2F0aW9uL3hzcGYreG1sXCI6W1wieHNwZlwiXSxcImFwcGxpY2F0aW9uL3h2K3htbFwiOltcIm14bWxcIixcInhodm1sXCIsXCJ4dm1sXCIsXCJ4dm1cIl0sXCJhcHBsaWNhdGlvbi95YW5nXCI6W1wieWFuZ1wiXSxcImFwcGxpY2F0aW9uL3lpbit4bWxcIjpbXCJ5aW5cIl0sXCJhcHBsaWNhdGlvbi96aXBcIjpbXCJ6aXBcIl0sXCJhdWRpby8zZ3BwXCI6W10sXCJhdWRpby9hZHBjbVwiOltcImFkcFwiXSxcImF1ZGlvL2Jhc2ljXCI6W1wiYXVcIixcInNuZFwiXSxcImF1ZGlvL21pZGlcIjpbXCJtaWRcIixcIm1pZGlcIixcImthclwiLFwicm1pXCJdLFwiYXVkaW8vbXAzXCI6W10sXCJhdWRpby9tcDRcIjpbXCJtNGFcIixcIm1wNGFcIl0sXCJhdWRpby9tcGVnXCI6W1wibXBnYVwiLFwibXAyXCIsXCJtcDJhXCIsXCJtcDNcIixcIm0yYVwiLFwibTNhXCJdLFwiYXVkaW8vb2dnXCI6W1wib2dhXCIsXCJvZ2dcIixcInNweFwiXSxcImF1ZGlvL3MzbVwiOltcInMzbVwiXSxcImF1ZGlvL3NpbGtcIjpbXCJzaWxcIl0sXCJhdWRpby93YXZcIjpbXCJ3YXZcIl0sXCJhdWRpby93YXZlXCI6W10sXCJhdWRpby93ZWJtXCI6W1wid2ViYVwiXSxcImF1ZGlvL3htXCI6W1wieG1cIl0sXCJmb250L290ZlwiOltcIm90ZlwiXSxcImltYWdlL2FwbmdcIjpbXCJhcG5nXCJdLFwiaW1hZ2UvYm1wXCI6W1wiYm1wXCJdLFwiaW1hZ2UvY2dtXCI6W1wiY2dtXCJdLFwiaW1hZ2UvZzNmYXhcIjpbXCJnM1wiXSxcImltYWdlL2dpZlwiOltcImdpZlwiXSxcImltYWdlL2llZlwiOltcImllZlwiXSxcImltYWdlL2pwZWdcIjpbXCJqcGVnXCIsXCJqcGdcIixcImpwZVwiXSxcImltYWdlL2t0eFwiOltcImt0eFwiXSxcImltYWdlL3BuZ1wiOltcInBuZ1wiXSxcImltYWdlL3NnaVwiOltcInNnaVwiXSxcImltYWdlL3N2Zyt4bWxcIjpbXCJzdmdcIixcInN2Z3pcIl0sXCJpbWFnZS90aWZmXCI6W1widGlmZlwiLFwidGlmXCJdLFwiaW1hZ2Uvd2VicFwiOltcIndlYnBcIl0sXCJtZXNzYWdlL3JmYzgyMlwiOltcImVtbFwiLFwibWltZVwiXSxcIm1vZGVsL2dsdGYranNvblwiOltcImdsdGZcIl0sXCJtb2RlbC9nbHRmLWJpbmFyeVwiOltcImdsYlwiXSxcIm1vZGVsL2lnZXNcIjpbXCJpZ3NcIixcImlnZXNcIl0sXCJtb2RlbC9tZXNoXCI6W1wibXNoXCIsXCJtZXNoXCIsXCJzaWxvXCJdLFwibW9kZWwvdnJtbFwiOltcIndybFwiLFwidnJtbFwiXSxcIm1vZGVsL3gzZCtiaW5hcnlcIjpbXCJ4M2RiXCIsXCJ4M2RielwiXSxcIm1vZGVsL3gzZCt2cm1sXCI6W1wieDNkdlwiLFwieDNkdnpcIl0sXCJtb2RlbC94M2QreG1sXCI6W1wieDNkXCIsXCJ4M2R6XCJdLFwidGV4dC9jYWNoZS1tYW5pZmVzdFwiOltcImFwcGNhY2hlXCIsXCJtYW5pZmVzdFwiXSxcInRleHQvY2FsZW5kYXJcIjpbXCJpY3NcIixcImlmYlwiXSxcInRleHQvY29mZmVlc2NyaXB0XCI6W1wiY29mZmVlXCIsXCJsaXRjb2ZmZWVcIl0sXCJ0ZXh0L2Nzc1wiOltcImNzc1wiXSxcInRleHQvY3N2XCI6W1wiY3N2XCJdLFwidGV4dC9oanNvblwiOltcImhqc29uXCJdLFwidGV4dC9odG1sXCI6W1wiaHRtbFwiLFwiaHRtXCIsXCJzaHRtbFwiXSxcInRleHQvamFkZVwiOltcImphZGVcIl0sXCJ0ZXh0L2pzeFwiOltcImpzeFwiXSxcInRleHQvbGVzc1wiOltcImxlc3NcIl0sXCJ0ZXh0L21hcmtkb3duXCI6W1wibWFya2Rvd25cIixcIm1kXCJdLFwidGV4dC9tYXRobWxcIjpbXCJtbWxcIl0sXCJ0ZXh0L24zXCI6W1wibjNcIl0sXCJ0ZXh0L3BsYWluXCI6W1widHh0XCIsXCJ0ZXh0XCIsXCJjb25mXCIsXCJkZWZcIixcImxpc3RcIixcImxvZ1wiLFwiaW5cIixcImluaVwiXSxcInRleHQvcmljaHRleHRcIjpbXCJydHhcIl0sXCJ0ZXh0L3J0ZlwiOltdLFwidGV4dC9zZ21sXCI6W1wic2dtbFwiLFwic2dtXCJdLFwidGV4dC9zbGltXCI6W1wic2xpbVwiLFwic2xtXCJdLFwidGV4dC9zdHlsdXNcIjpbXCJzdHlsdXNcIixcInN0eWxcIl0sXCJ0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzXCI6W1widHN2XCJdLFwidGV4dC90cm9mZlwiOltcInRcIixcInRyXCIsXCJyb2ZmXCIsXCJtYW5cIixcIm1lXCIsXCJtc1wiXSxcInRleHQvdHVydGxlXCI6W1widHRsXCJdLFwidGV4dC91cmktbGlzdFwiOltcInVyaVwiLFwidXJpc1wiLFwidXJsc1wiXSxcInRleHQvdmNhcmRcIjpbXCJ2Y2FyZFwiXSxcInRleHQvdnR0XCI6W1widnR0XCJdLFwidGV4dC94bWxcIjpbXSxcInRleHQveWFtbFwiOltcInlhbWxcIixcInltbFwiXSxcInZpZGVvLzNncHBcIjpbXCIzZ3BcIixcIjNncHBcIl0sXCJ2aWRlby8zZ3BwMlwiOltcIjNnMlwiXSxcInZpZGVvL2gyNjFcIjpbXCJoMjYxXCJdLFwidmlkZW8vaDI2M1wiOltcImgyNjNcIl0sXCJ2aWRlby9oMjY0XCI6W1wiaDI2NFwiXSxcInZpZGVvL2pwZWdcIjpbXCJqcGd2XCJdLFwidmlkZW8vanBtXCI6W1wianBtXCIsXCJqcGdtXCJdLFwidmlkZW8vbWoyXCI6W1wibWoyXCIsXCJtanAyXCJdLFwidmlkZW8vbXAydFwiOltcInRzXCJdLFwidmlkZW8vbXA0XCI6W1wibXA0XCIsXCJtcDR2XCIsXCJtcGc0XCJdLFwidmlkZW8vbXBlZ1wiOltcIm1wZWdcIixcIm1wZ1wiLFwibXBlXCIsXCJtMXZcIixcIm0ydlwiXSxcInZpZGVvL29nZ1wiOltcIm9ndlwiXSxcInZpZGVvL3F1aWNrdGltZVwiOltcInF0XCIsXCJtb3ZcIl0sXCJ2aWRlby93ZWJtXCI6W1wid2VibVwiXX1cbn0se31dfSx7fSxbMl0pKDIpXG59KTsiLCIvLyBjb3B5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtbW9kdWxlcy91dGlsaXR5IGZvciBicm93c2VyXG5cbmV4cG9ydHMuZW5jb2RlVVJJQ29tcG9uZW50ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHRleHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbn07XG5cbmV4cG9ydHMuZXNjYXBlID0gcmVxdWlyZSgnZXNjYXBlLWh0bWwnKTtcblxuZXhwb3J0cy50aW1lc3RhbXAgPSBmdW5jdGlvbiB0aW1lc3RhbXAodCkge1xuICBpZiAodCkge1xuICAgIHZhciB2ID0gdDtcbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gTnVtYmVyKHYpO1xuICAgIH1cbiAgICBpZiAoU3RyaW5nKHQpLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHYgKj0gMTAwMDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKHYpO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciB1cmx1dGlsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd1cmxsaWInKTtcbnZhciBtcyA9IHJlcXVpcmUoJ2h1bWFuaXplLW1zJyk7XG5cbnZhciBfUHJvbWlzZTtcblxudmFyIFJFUVVFU1RfSUQgPSAwO1xudmFyIE1BWF9WQUxVRSA9IE1hdGgucG93KDIsIDMxKSAtIDEwO1xudmFyIFBST1RPX1JFID0gL15odHRwcz86XFwvXFwvL2k7XG5cbmZ1bmN0aW9uIGdldEFnZW50KGFnZW50LCBkZWZhdWx0QWdlbnQpIHtcbiAgcmV0dXJuIGFnZW50ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0QWdlbnQgOiBhZ2VudDtcbn1cblxuZnVuY3Rpb24gbWFrZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGVyciwgZGF0YSwgcmVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH1cbiAgICByZXNvbHZlKHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLFxuICAgICAgaGVhZGVyczogcmVzLmhlYWRlcnMsXG4gICAgICByZXM6IHJlc1xuICAgIH0pO1xuICB9O1xufVxuXG4vLyBleHBvcnRzLlRJTUVPVVQgPSBtcygnNXMnKTtcbmV4cG9ydHMuVElNRU9VVFMgPSBbbXMoJzMwMHMnKSwgbXMoJzMwMHMnKV07XG5cbnZhciBURVhUX0RBVEFfVFlQRVMgPSBbXG4gICdqc29uJyxcbiAgJ3RleHQnXG5dO1xuXG5leHBvcnRzLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KHVybCwgYXJncywgY2FsbGJhY2spIHtcbiAgLy8gcmVxdWVzdCh1cmwsIGNhbGxiYWNrKVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYXJncztcbiAgICBhcmdzID0gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMucmVxdWVzdFdpdGhDYWxsYmFjayh1cmwsIGFyZ3MsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFByb21pc2VcbiAgaWYgKCFfUHJvbWlzZSkge1xuICAgIF9Qcm9taXNlID0gcmVxdWlyZSgnYW55LXByb21pc2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBleHBvcnRzLnJlcXVlc3RXaXRoQ2FsbGJhY2sodXJsLCBhcmdzLCBtYWtlQ2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KSk7XG4gIH0pO1xufTtcblxuXG5leHBvcnRzLnJlcXVlc3RXaXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiByZXF1ZXN0V2l0aENhbGxiYWNrKHVybCwgYXJncywgY2FsbGJhY2spIHtcbiAgLy8gcmVxdWVzdFdpdGhDYWxsYmFjayh1cmwsIGNhbGxiYWNrKVxuICBpZiAoIXVybCB8fCAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHVybCAhPT0gJ29iamVjdCcpKSB7XG4gICAgdmFyIG1zZyA9IHV0aWwuZm9ybWF0KCdleHBlY3QgcmVxdWVzdCB1cmwgdG8gYmUgYSBzdHJpbmcgb3IgYSBodHRwIHJlcXVlc3Qgb3B0aW9ucywgYnV0IGdvdCAlaicsIHVybCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYXJncztcbiAgICBhcmdzID0gbnVsbDtcbiAgfVxuXG4gIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICBpZiAoUkVRVUVTVF9JRCA+PSBNQVhfVkFMVUUpIHtcbiAgICBSRVFVRVNUX0lEID0gMDtcbiAgfVxuICB2YXIgcmVxSWQgPSArK1JFUVVFU1RfSUQ7XG5cbiAgYXJncy5yZXF1ZXN0VXJscyA9IGFyZ3MucmVxdWVzdFVybHMgfHwgW107XG5cbiAgdmFyIHJlcU1ldGEgPSB7XG4gICAgcmVxdWVzdElkOiByZXFJZCxcbiAgICB1cmw6IHVybCxcbiAgICBhcmdzOiBhcmdzLFxuICAgIGN0eDogYXJncy5jdHgsXG4gIH07XG4gIGlmIChhcmdzLmVtaXR0ZXIpIHtcbiAgICBhcmdzLmVtaXR0ZXIuZW1pdCgncmVxdWVzdCcsIHJlcU1ldGEpO1xuICB9XG5cbiAgYXJncy50aW1lb3V0ID0gYXJncy50aW1lb3V0IHx8IGV4cG9ydHMuVElNRU9VVFM7XG4gIGFyZ3MubWF4UmVkaXJlY3RzID0gYXJncy5tYXhSZWRpcmVjdHMgfHwgMTA7XG4gIGFyZ3Muc3RyZWFtaW5nID0gYXJncy5zdHJlYW1pbmcgfHwgYXJncy5jdXN0b21SZXNwb25zZTtcbiAgdmFyIHJlcXVlc3RTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICB2YXIgcGFyc2VkVXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgIGlmICghUFJPVE9fUkUudGVzdCh1cmwpKSB7XG4gICAgICAvLyBTdXBwb3J0IGByZXF1ZXN0KCd3d3cuc2VydmVyLmNvbScpYFxuICAgICAgdXJsID0gJ2h0dHA6Ly8nICsgdXJsO1xuICAgIH1cbiAgICBwYXJzZWRVcmwgPSB1cmx1dGlsLnBhcnNlKHVybCk7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkVXJsID0gdXJsO1xuICB9XG5cbiAgdmFyIG1ldGhvZCA9IChhcmdzLnR5cGUgfHwgYXJncy5tZXRob2QgfHwgcGFyc2VkVXJsLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKTtcbiAgdmFyIHBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCA4MDtcbiAgdmFyIGh0dHBsaWIgPSBodHRwO1xuICB2YXIgYWdlbnQgPSBnZXRBZ2VudChhcmdzLmFnZW50LCBleHBvcnRzLmFnZW50KTtcbiAgdmFyIGZpeEpTT05DdGxDaGFycyA9IGFyZ3MuZml4SlNPTkN0bENoYXJzO1xuXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgaHR0cGxpYiA9IGh0dHBzO1xuICAgIGFnZW50ID0gZ2V0QWdlbnQoYXJncy5odHRwc0FnZW50LCBleHBvcnRzLmh0dHBzQWdlbnQpO1xuXG4gICAgaWYgKCFwYXJzZWRVcmwucG9ydCkge1xuICAgICAgcG9ydCA9IDQ0MztcbiAgICB9XG4gIH1cblxuICAvLyByZXF1ZXN0IHRocm91Z2ggcHJveHkgdHVubmVsXG4gIC8vIHZhciBwcm94eVR1bm5lbEFnZW50ID0gZGV0ZWN0UHJveHlBZ2VudChwYXJzZWRVcmwsIGFyZ3MpO1xuICAvLyBpZiAocHJveHlUdW5uZWxBZ2VudCkge1xuICAvLyAgIGFnZW50ID0gcHJveHlUdW5uZWxBZ2VudDtcbiAgLy8gfVxuXG4gIHZhciBvcHRpb25zID0ge1xuICAgIGhvc3Q6IHBhcnNlZFVybC5ob3N0bmFtZSB8fCBwYXJzZWRVcmwuaG9zdCB8fCAnbG9jYWxob3N0JyxcbiAgICBwYXRoOiBwYXJzZWRVcmwucGF0aCB8fCAnLycsXG4gICAgbWV0aG9kOiBtZXRob2QsXG4gICAgcG9ydDogcG9ydCxcbiAgICBhZ2VudDogYWdlbnQsXG4gICAgaGVhZGVyczogYXJncy5oZWFkZXJzIHx8IHt9LFxuICAgIC8vIGRlZmF1bHQgaXMgZG5zLmxvb2t1cFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvbmV0LmpzI0w5ODZcbiAgICAvLyBjdXN0b20gZG5zbG9va3VwIHJlcXVpcmUgbm9kZSA+PSA0LjAuMFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2FyY2hpdmVkLWlvLmpzLXYwLjEyL2xpYi9uZXQuanMjTDk1MlxuICAgIGxvb2t1cDogYXJncy5sb29rdXAsXG4gIH07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJncy50aW1lb3V0KSkge1xuICAgIG9wdGlvbnMucmVxdWVzdFRpbWVvdXQgPSBhcmdzLnRpbWVvdXRbYXJncy50aW1lb3V0Lmxlbmd0aCAtIDFdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzLnRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucy5yZXF1ZXN0VGltZW91dCA9IGFyZ3MudGltZW91dDtcbiAgfVxuXG4gIHZhciBzc2xOYW1lcyA9IFtcbiAgICAncGZ4JyxcbiAgICAna2V5JyxcbiAgICAncGFzc3BocmFzZScsXG4gICAgJ2NlcnQnLFxuICAgICdjYScsXG4gICAgJ2NpcGhlcnMnLFxuICAgICdyZWplY3RVbmF1dGhvcml6ZWQnLFxuICAgICdzZWN1cmVQcm90b2NvbCcsXG4gICAgJ3NlY3VyZU9wdGlvbnMnLFxuICBdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNzbE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBzc2xOYW1lc1tpXTtcbiAgICBpZiAoYXJncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgb3B0aW9uc1tuYW1lXSA9IGFyZ3NbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLy8gZG9uJ3QgY2hlY2sgc3NsXG4gIGlmIChvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gZmFsc2UgJiYgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3NlY3VyZU9wdGlvbnMnKSkge1xuICAgIG9wdGlvbnMuc2VjdXJlT3B0aW9ucyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpLlNTTF9PUF9OT19UTFN2MV8yO1xuICB9XG5cbiAgdmFyIGF1dGggPSBhcmdzLmF1dGggfHwgcGFyc2VkVXJsLmF1dGg7XG4gIGlmIChhdXRoKSB7XG4gICAgb3B0aW9ucy5hdXRoID0gYXV0aDtcbiAgfVxuXG4gIHZhciBib2R5ID0gYXJncy5jb250ZW50IHx8IGFyZ3MuZGF0YTtcbiAgdmFyIGRhdGFBc1F1ZXJ5U3RyaW5nID0gbWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdIRUFEJyB8fCBhcmdzLmRhdGFBc1F1ZXJ5U3RyaW5nO1xuICBpZiAoIWFyZ3MuY29udGVudCkge1xuICAgIGlmIChib2R5ICYmICEodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkpIHtcbiAgICAgIGlmIChkYXRhQXNRdWVyeVN0cmluZykge1xuICAgICAgICAvLyByZWFkOiBHRVQsIEhFQUQsIHVzZSBxdWVyeSBzdHJpbmdcbiAgICAgICAgYm9keSA9IGFyZ3MubmVzdGVkUXVlcnlzdHJpbmcgPyBxcy5zdHJpbmdpZnkoYm9keSkgOiBxdWVyeXN0cmluZy5zdHJpbmdpZnkoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29udGVudFR5cGUgPSBvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddIHx8IG9wdGlvbnMuaGVhZGVyc1snY29udGVudC10eXBlJ107XG4gICAgICAgIC8vIGF1dG8gYWRkIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCB3aGVuIHVzaW5nIHVybGVuY29kZSBmb3JtIHJlcXVlc3RcbiAgICAgICAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgICAgICAgIGlmIChhcmdzLmNvbnRlbnRUeXBlID09PSAnanNvbicpIHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gY29udGVudFR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VDb250ZW50VHlwZShjb250ZW50VHlwZSkudHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgICAgICAgYm9keSA9IGFyZ3MubmVzdGVkUXVlcnlzdHJpbmcgPyBxcy5zdHJpbmdpZnkoYm9keSkgOiBxdWVyeXN0cmluZy5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiBpdCdzIGEgR0VUIG9yIEhFQUQgcmVxdWVzdCwgZGF0YSBzaG91bGQgYmUgc2VudCBhcyBxdWVyeSBzdHJpbmdcbiAgaWYgKGRhdGFBc1F1ZXJ5U3RyaW5nICYmIGJvZHkpIHtcbiAgICBvcHRpb25zLnBhdGggKz0gKHBhcnNlZFVybC5xdWVyeSA/ICcmJyA6ICc/JykgKyBib2R5O1xuICAgIGJvZHkgPSBudWxsO1xuICB9XG5cbiAgdmFyIHJlcXVlc3RTaXplID0gMDtcbiAgaWYgKGJvZHkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYm9keS5sZW5ndGg7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGJvZHkpO1xuICAgIH1cbiAgICByZXF1ZXN0U2l6ZSA9IG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IGxlbmd0aDtcbiAgfVxuXG4gIGlmIChhcmdzLmRhdGFUeXBlID09PSAnanNvbicpIHtcbiAgICBvcHRpb25zLmhlYWRlcnMuQWNjZXB0ID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmdzLmJlZm9yZVJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyB5b3UgY2FuIHVzZSB0aGlzIGhvb2sgdG8gY2hhbmdlIGV2ZXJ5IHRoaW5nLlxuICAgIGFyZ3MuYmVmb3JlUmVxdWVzdChvcHRpb25zKTtcbiAgfVxuICB2YXIgY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgdmFyIHJlc3BvbnNlVGltZXIgPSBudWxsO1xuICB2YXIgX19lcnIgPSBudWxsO1xuICB2YXIgY29ubmVjdGVkID0gZmFsc2U7IC8vIHNvY2tldCBjb25uZWN0ZWQgb3Igbm90XG4gIHZhciBrZWVwQWxpdmVTb2NrZXQgPSBmYWxzZTsgLy8gcmVxdWVzdCB3aXRoIGtlZXBhbGl2ZSBzb2NrZXRcbiAgdmFyIHJlc3BvbnNlU2l6ZSA9IDA7XG4gIHZhciBzdGF0dXNDb2RlID0gLTE7XG4gIHZhciByZXNwb25zZUFib3J0ZWQgPSBmYWxzZTtcbiAgdmFyIHJlbW90ZUFkZHJlc3MgPSAnJztcbiAgdmFyIHJlbW90ZVBvcnQgPSAnJztcbiAgdmFyIHRpbWluZyA9IG51bGw7XG4gIGlmIChhcmdzLnRpbWluZykge1xuICAgIHRpbWluZyA9IHtcbiAgICAgIC8vIHNvY2tldCBhc3NpZ25lZFxuICAgICAgcXVldWluZzogMCxcbiAgICAgIC8vIGRucyBsb29rdXAgdGltZVxuICAgICAgZG5zbG9va3VwOiAwLFxuICAgICAgLy8gc29ja2V0IGNvbm5lY3RlZFxuICAgICAgY29ubmVjdGVkOiAwLFxuICAgICAgLy8gcmVxdWVzdCBzZW50XG4gICAgICByZXF1ZXN0U2VudDogMCxcbiAgICAgIC8vIFRpbWUgdG8gZmlyc3QgYnl0ZSAoVFRGQilcbiAgICAgIHdhaXRpbmc6IDAsXG4gICAgICBjb250ZW50RG93bmxvYWQ6IDAsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbENvbm5lY3RUaW1lcigpIHtcbiAgICBpZiAoY29ubmVjdFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29ubmVjdFRpbWVyKTtcbiAgICAgIGNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbFJlc3BvbnNlVGltZXIoKSB7XG4gICAgaWYgKHJlc3BvbnNlVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChyZXNwb25zZVRpbWVyKTtcbiAgICAgIHJlc3BvbnNlVGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUoZXJyLCBkYXRhLCByZXMpIHtcbiAgICBjYW5jZWxSZXNwb25zZVRpbWVyKCk7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY29uc29sZS53YXJuKCdbdXJsbGliOndhcm5dIFslc10gWyVzXSBbd29ya2VyOiVzXSAlcyAlcyBjYWxsYmFjayB0d2ljZSEhIScsXG4gICAgICAgIERhdGUoKSwgcmVxSWQsIHByb2Nlc3MucGlkLCBvcHRpb25zLm1ldGhvZCwgdXJsKTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLW1vZHVsZXMvdXJsbGliL3B1bGwvMzBcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdXJsbGliOndhcm5dIFslc10gWyVzXSBbd29ya2VyOiVzXSAlczogJXNcXG5zdGFjazogJXMnLFxuICAgICAgICAgIERhdGUoKSwgcmVxSWQsIHByb2Nlc3MucGlkLCBlcnIubmFtZSwgZXJyLm1lc3NhZ2UsIGVyci5zdGFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjYiA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcbiAgICAgIGhlYWRlcnMgPSByZXMuaGVhZGVycztcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgZGlnZXN0IGF1dGhcbiAgICBpZiAoc3RhdHVzQ29kZSA9PT0gNDAxICYmIGhlYWRlcnNbJ3d3dy1hdXRoZW50aWNhdGUnXVxuICAgICAgJiYgKCFhcmdzLmhlYWRlcnMgfHwgIWFyZ3MuaGVhZGVycy5BdXRob3JpemF0aW9uKSAmJiBhcmdzLmRpZ2VzdEF1dGgpIHtcbiAgICAgIHZhciBhdXRoZW50aWNhdGUgPSBoZWFkZXJzWyd3d3ctYXV0aGVudGljYXRlJ107XG4gICAgICBpZiAoYXV0aGVudGljYXRlLmluZGV4T2YoJ0RpZ2VzdCAnKSA+PSAwKSB7XG4gICAgICAgIGRlYnVnKCdSZXF1ZXN0IyVkICVzOiBnb3QgZGlnZXN0IGF1dGggaGVhZGVyIFdXVy1BdXRoZW50aWNhdGU6ICVzJywgcmVxSWQsIHVybCwgYXV0aGVudGljYXRlKTtcbiAgICAgICAgYXJncy5oZWFkZXJzID0gYXJncy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICBhcmdzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGRpZ2VzdEF1dGhIZWFkZXIob3B0aW9ucy5tZXRob2QsIG9wdGlvbnMucGF0aCwgYXV0aGVudGljYXRlLCBhcmdzLmRpZ2VzdEF1dGgpO1xuICAgICAgICBkZWJ1ZygnUmVxdWVzdCMlZCAlczogYXV0aCB3aXRoIGRpZ2VzdCBoZWFkZXI6ICVzJywgcmVxSWQsIHVybCwgYXJncy5oZWFkZXJzLkF1dGhvcml6YXRpb24pO1xuICAgICAgICBpZiAocmVzLmhlYWRlcnNbJ3NldC1jb29raWUnXSkge1xuICAgICAgICAgIGFyZ3MuaGVhZGVycy5Db29raWUgPSByZXMuaGVhZGVyc1snc2V0LWNvb2tpZSddLmpvaW4oJzsnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5yZXF1ZXN0V2l0aENhbGxiYWNrKHVybCwgYXJncywgY2IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0VXNlVGltZSA9IERhdGUubm93KCkgLSByZXF1ZXN0U3RhcnRUaW1lO1xuICAgIGlmICh0aW1pbmcpIHtcbiAgICAgIHRpbWluZy5jb250ZW50RG93bmxvYWQgPSByZXF1ZXN0VXNlVGltZTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnWyVzbXNdIGRvbmUsICVzIGJ5dGVzIEhUVFAgJXMgJXMgJXMgJXMsIGtlZXBBbGl2ZVNvY2tldDogJXMsIHRpbWluZzogJWonLFxuICAgICAgcmVxdWVzdFVzZVRpbWUsIHJlc3BvbnNlU2l6ZSwgc3RhdHVzQ29kZSwgb3B0aW9ucy5tZXRob2QsIG9wdGlvbnMuaG9zdCwgb3B0aW9ucy5wYXRoLFxuICAgICAga2VlcEFsaXZlU29ja2V0LCB0aW1pbmcpO1xuXG4gICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgc3RhdHVzOiBzdGF0dXNDb2RlLFxuICAgICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBzaXplOiByZXNwb25zZVNpemUsXG4gICAgICBhYm9ydGVkOiByZXNwb25zZUFib3J0ZWQsXG4gICAgICBydDogcmVxdWVzdFVzZVRpbWUsXG4gICAgICBrZWVwQWxpdmVTb2NrZXQ6IGtlZXBBbGl2ZVNvY2tldCxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICByZXF1ZXN0VXJsczogYXJncy5yZXF1ZXN0VXJscyxcbiAgICAgIHRpbWluZzogdGltaW5nLFxuICAgICAgcmVtb3RlQWRkcmVzczogcmVtb3RlQWRkcmVzcyxcbiAgICAgIHJlbW90ZVBvcnQ6IHJlbW90ZVBvcnQsXG4gICAgfTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHZhciBhZ2VudFN0YXR1cyA9ICcnO1xuICAgICAgaWYgKGFnZW50ICYmIHR5cGVvZiBhZ2VudC5nZXRDdXJyZW50U3RhdHVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGFkZCBjdXJyZW50IGFnZW50IHN0YXR1cyB0byBlcnJvciBtZXNzYWdlIGZvciBsb2dnaW5nIGFuZCBkZWJ1Z1xuICAgICAgICBhZ2VudFN0YXR1cyA9ICcsIGFnZW50IHN0YXR1czogJyArIEpTT04uc3RyaW5naWZ5KGFnZW50LmdldEN1cnJlbnRTdGF0dXMoKSk7XG4gICAgICB9XG4gICAgICBlcnIubWVzc2FnZSArPSAnLCAnICsgb3B0aW9ucy5tZXRob2QgKyAnICcgKyB1cmwgKyAnICcgKyBzdGF0dXNDb2RlXG4gICAgICAgICsgJyAoY29ubmVjdGVkOiAnICsgY29ubmVjdGVkICsgJywga2VlcGFsaXZlIHNvY2tldDogJyArIGtlZXBBbGl2ZVNvY2tldCArIGFnZW50U3RhdHVzICsgJyknXG4gICAgICAgICsgJ1xcbmhlYWRlcnM6ICcgKyBKU09OLnN0cmluZ2lmeShoZWFkZXJzKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGVyci5wYXRoID0gb3B0aW9ucy5wYXRoO1xuICAgICAgZXJyLnN0YXR1cyA9IHN0YXR1c0NvZGU7XG4gICAgICBlcnIuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICBlcnIucmVzID0gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgY2IoZXJyLCBkYXRhLCBhcmdzLnN0cmVhbWluZyA/IHJlcyA6IHJlc3BvbnNlKTtcblxuICAgIGlmIChhcmdzLmVtaXR0ZXIpIHtcbiAgICAgIC8vIGtlZXAgdG8gdXNlIHRoZSBzYW1lIHJlcU1ldGEgb2JqZWN0IG9uIHJlcXVlc3QgZXZlbnQgYmVmb3JlXG4gICAgICByZXFNZXRhLnVybCA9IHVybDtcbiAgICAgIHJlcU1ldGEuc29ja2V0ID0gcmVxICYmIHJlcS5jb25uZWN0aW9uO1xuICAgICAgcmVxTWV0YS5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHJlcU1ldGEuc2l6ZSA9IHJlcXVlc3RTaXplO1xuXG4gICAgICBhcmdzLmVtaXR0ZXIuZW1pdCgncmVzcG9uc2UnLCB7XG4gICAgICAgIHJlcXVlc3RJZDogcmVxSWQsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgIGN0eDogYXJncy5jdHgsXG4gICAgICAgIHJlcTogcmVxTWV0YSxcbiAgICAgICAgcmVzOiByZXNwb25zZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlZGlyZWN0KHJlcykge1xuICAgIHZhciBlcnIgPSBudWxsO1xuICAgIGlmIChhcmdzLmZvbGxvd1JlZGlyZWN0ICYmIHN0YXR1c2VzLnJlZGlyZWN0W3Jlcy5zdGF0dXNDb2RlXSkgeyAgLy8gaGFuZGxlIHJlZGlyZWN0XG4gICAgICBhcmdzLl9mb2xsb3dSZWRpcmVjdENvdW50ID0gKGFyZ3MuX2ZvbGxvd1JlZGlyZWN0Q291bnQgfHwgMCkgKyAxO1xuICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmhlYWRlcnMubG9jYXRpb247XG4gICAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICAgIGVyciA9IG5ldyBFcnJvcignR290IHN0YXR1c0NvZGUgJyArIHJlcy5zdGF0dXNDb2RlICsgJyBidXQgY2Fubm90IHJlc29sdmUgbmV4dCBsb2NhdGlvbiBmcm9tIGhlYWRlcnMnKTtcbiAgICAgICAgZXJyLm5hbWUgPSAnRm9sbG93UmVkaXJlY3RFcnJvcic7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MuX2ZvbGxvd1JlZGlyZWN0Q291bnQgPiBhcmdzLm1heFJlZGlyZWN0cykge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoJ0V4Y2VlZGVkIG1heFJlZGlyZWN0cy4gUHJvYmFibHkgc3R1Y2sgaW4gYSByZWRpcmVjdCBsb29wICcgKyB1cmwpO1xuICAgICAgICBlcnIubmFtZSA9ICdNYXhSZWRpcmVjdEVycm9yJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdVcmwgPSBhcmdzLmZvcm1hdFJlZGlyZWN0VXJsID8gYXJncy5mb3JtYXRSZWRpcmVjdFVybCh1cmwsIGxvY2F0aW9uKSA6IHVybHV0aWwucmVzb2x2ZSh1cmwsIGxvY2F0aW9uKTtcbiAgICAgICAgZGVidWcoJ1JlcXVlc3QjJWQgJXM6IGByZWRpcmVjdGVkYCBmcm9tICVzIHRvICVzJywgcmVxSWQsIG9wdGlvbnMucGF0aCwgdXJsLCBuZXdVcmwpO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGltZXIgc3RvcFxuICAgICAgICBjYW5jZWxSZXNwb25zZVRpbWVyKCk7XG4gICAgICAgIC8vIHNob3VsZCBjbGVhbiB1cCBoZWFkZXJzLkhvc3Qgb24gYGxvY2F0aW9uOiBodHRwOi8vb3RoZXItZG9tYWluL3VybGBcbiAgICAgICAgaWYgKGFyZ3MuaGVhZGVycyAmJiBhcmdzLmhlYWRlcnMuSG9zdCAmJiBQUk9UT19SRS50ZXN0KGxvY2F0aW9uKSkge1xuICAgICAgICAgIGFyZ3MuaGVhZGVycy5Ib3N0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhdm9pZCBkb25lIHdpbGwgYmUgZXhlY3V0ZSBpbiB0aGUgZnV0dXJlIGNoYW5nZS5cbiAgICAgICAgdmFyIGNiID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgZXhwb3J0cy5yZXF1ZXN0V2l0aENhbGxiYWNrKG5ld1VybCwgYXJncywgY2IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlZGlyZWN0OiB0cnVlLFxuICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWRpcmVjdDogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyXG4gICAgfTtcbiAgfVxuXG4gIC8vIHNldCB1c2VyLWFnZW50XG4gIGlmICghb3B0aW9ucy5oZWFkZXJzWydVc2VyLUFnZW50J10gJiYgIW9wdGlvbnMuaGVhZGVyc1sndXNlci1hZ2VudCddKSB7XG4gICAgb3B0aW9ucy5oZWFkZXJzWydVc2VyLUFnZW50J10gPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB9XG5cbiAgaWYgKGFyZ3MuZ3ppcCkge1xuICAgIGlmICghb3B0aW9ucy5oZWFkZXJzWydBY2NlcHQtRW5jb2RpbmcnXSAmJiAhb3B0aW9ucy5oZWFkZXJzWydhY2NlcHQtZW5jb2RpbmcnXSkge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzWydBY2NlcHQtRW5jb2RpbmcnXSA9ICdnemlwJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGVDb250ZW50KHJlcywgYm9keSwgY2IpIHtcbiAgICB2YXIgZW5jb2RpbmcgPSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuICAgIC8vIGlmIChib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgIC8vICAgcmV0dXJuIGNiKG51bGwsIGJvZHksIGVuY29kaW5nKTtcbiAgICAvLyB9XG5cbiAgICAvLyBpZiAoIWVuY29kaW5nIHx8IGVuY29kaW5nLnRvTG93ZXJDYXNlKCkgIT09ICdnemlwJykge1xuICAgICAgcmV0dXJuIGNiKG51bGwsIGJvZHksIGVuY29kaW5nKTtcbiAgICAvLyB9XG5cbiAgICAvLyBkZWJ1ZygnZ3VuemlwICVkIGxlbmd0aCBib2R5JywgYm9keS5sZW5ndGgpO1xuICAgIC8vIHpsaWIuZ3VuemlwKGJvZHksIGNiKTtcbiAgfVxuXG4gIHZhciB3cml0ZVN0cmVhbSA9IGFyZ3Mud3JpdGVTdHJlYW07XG5cbiAgZGVidWcoJ1JlcXVlc3QjJWQgJXMgJXMgd2l0aCBoZWFkZXJzICVqLCBvcHRpb25zLnBhdGg6ICVzJyxcbiAgICByZXFJZCwgbWV0aG9kLCB1cmwsIG9wdGlvbnMuaGVhZGVycywgb3B0aW9ucy5wYXRoKTtcblxuICBhcmdzLnJlcXVlc3RVcmxzLnB1c2godXJsKTtcblxuICBmdW5jdGlvbiBvblJlc3BvbnNlKHJlcykge1xuICAgIGlmICh0aW1pbmcpIHtcbiAgICAgIHRpbWluZy53YWl0aW5nID0gRGF0ZS5ub3coKSAtIHJlcXVlc3RTdGFydFRpbWU7XG4gICAgfVxuICAgIGRlYnVnKCdSZXF1ZXN0IyVkICVzIGByZXEgcmVzcG9uc2VgIGV2ZW50IGVtaXQ6IHN0YXR1cyAlZCwgaGVhZGVyczogJWonLFxuICAgICAgcmVxSWQsIHVybCwgcmVzLnN0YXR1c0NvZGUsIHJlcy5oZWFkZXJzKTtcblxuICAgIGlmIChhcmdzLnN0cmVhbWluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IGhhbmRsZVJlZGlyZWN0KHJlcyk7XG4gICAgICBpZiAocmVzdWx0LnJlZGlyZWN0KSB7XG4gICAgICAgIHJlcy5yZXN1bWUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICByZXMucmVzdW1lKCk7XG4gICAgICAgIHJldHVybiBkb25lKHJlc3VsdC5lcnJvciwgbnVsbCwgcmVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvbmUobnVsbCwgbnVsbCwgcmVzKTtcbiAgICB9XG5cbiAgICByZXMub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgZGVidWcoJ1JlcXVlc3QjJWQgJXM6IGByZXMgY2xvc2VgIGV2ZW50IGVtaXQsIHRvdGFsIHNpemUgJWQnLFxuICAgICAgICByZXFJZCwgdXJsLCByZXNwb25zZVNpemUpO1xuICAgIH0pO1xuXG4gICAgcmVzLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlYnVnKCdSZXF1ZXN0IyVkICVzOiBgcmVzIGVycm9yYCBldmVudCBlbWl0LCB0b3RhbCBzaXplICVkJyxcbiAgICAgICAgcmVxSWQsIHVybCwgcmVzcG9uc2VTaXplKTtcbiAgICB9KTtcblxuICAgIHJlcy5vbignYWJvcnRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlc3BvbnNlQWJvcnRlZCA9IHRydWU7XG4gICAgICBkZWJ1ZygnUmVxdWVzdCMlZCAlczogYHJlcyBhYm9ydGVkYCBldmVudCBlbWl0LCB0b3RhbCBzaXplICVkJyxcbiAgICAgICAgcmVxSWQsIHVybCwgcmVzcG9uc2VTaXplKTtcbiAgICB9KTtcblxuICAgIGlmICh3cml0ZVN0cmVhbSkge1xuICAgICAgLy8gSWYgdGhlcmUncyBhIHdyaXRhYmxlIHN0cmVhbSB0byByZWNpZXZlIHRoZSByZXNwb25zZSBkYXRhLCBqdXN0IHBpcGUgdGhlXG4gICAgICAvLyByZXNwb25zZSBzdHJlYW0gdG8gdGhhdCB3cml0YWJsZSBzdHJlYW0gYW5kIGNhbGwgdGhlIGNhbGxiYWNrIHdoZW4gaXQgaGFzXG4gICAgICAvLyBmaW5pc2hlZCB3cml0aW5nLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEUgdGhhdCB3aGVuIHRoZSByZXNwb25zZSBzdHJlYW0gYHJlc2AgZW1pdHMgYW4gJ2VuZCcgZXZlbnQgaXQganVzdFxuICAgICAgLy8gbWVhbnMgdGhhdCBpdCBoYXMgZmluaXNoZWQgcGlwaW5nIGRhdGEgdG8gYW5vdGhlciBzdHJlYW0uIEluIHRoZVxuICAgICAgLy8gbWVhbndoaWxlIHRoYXQgd3JpdGFibGUgc3RyZWFtIG1heSBzdGlsbCB3cml0aW5nIGRhdGEgdG8gdGhlIGRpc2sgdW50aWxcbiAgICAgIC8vIGl0IGVtaXRzIGEgJ2Nsb3NlJyBldmVudC5cbiAgICAgIC8vXG4gICAgICAvLyBUaGF0IG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBhcHBseSBjYWxsYmFjayB1bnRpbCB0aGUgJ2Nsb3NlJyBvZiB0aGVcbiAgICAgIC8vIHdyaXRhYmxlIHN0cmVhbSBpcyBlbWl0ZWQuXG4gICAgICAvL1xuICAgICAgLy8gU2VlIGFsc286XG4gICAgICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9UQkVEUC91cmxsaWIvY29tbWl0Lzk1OWFjMzM2NTgyMWUwZTAyOGMyMzFhNWU4ZWZjYTZhZjQxMGVhYmJcbiAgICAgIC8vIC0gaHR0cDovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9ldmVudF9lbmRcbiAgICAgIC8vIC0gaHR0cDovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9ldmVudF9jbG9zZV8xXG4gICAgICB2YXIgcmVzdWx0ID0gaGFuZGxlUmVkaXJlY3QocmVzKTtcbiAgICAgIGlmIChyZXN1bHQucmVkaXJlY3QpIHtcbiAgICAgICAgcmVzLnJlc3VtZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIHJlcy5yZXN1bWUoKTtcbiAgICAgICAgLy8gZW5kIHRocyBzdHJlYW0gZmlyc3RcbiAgICAgICAgd3JpdGVTdHJlYW0uZW5kKCk7XG4gICAgICAgIHJldHVybiBkb25lKHJlc3VsdC5lcnJvciwgbnVsbCwgcmVzKTtcbiAgICAgIH1cbiAgICAgIC8vIHlvdSBjYW4gc2V0IGNvbnN1bWVXcml0ZVN0cmVhbSBmYWxzZSB0aGF0IG9ubHkgd2FpdCByZXNwb25zZSBlbmRcbiAgICAgIGlmIChhcmdzLmNvbnN1bWVXcml0ZVN0cmVhbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVzLm9uKCdlbmQnLCBkb25lLmJpbmQobnVsbCwgbnVsbCwgbnVsbCwgcmVzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub2RlIDAuMTAsIDAuMTI6IG9ubHkgZW1pdCByZXMgYWJvcnRlZCwgd3JpdGVTdHJlYW0gY2xvc2Ugbm90IGZpcmVkXG4gICAgICAgIGlmIChpc05vZGUwMTAgfHwgaXNOb2RlMDEyKSB7XG4gICAgICAgICAgZmlyc3QoW1xuICAgICAgICAgICAgWyB3cml0ZVN0cmVhbSwgJ2Nsb3NlJyBdLFxuICAgICAgICAgICAgWyByZXMsICdhYm9ydGVkJyBdLFxuICAgICAgICAgIF0sIGZ1bmN0aW9uKF8sIHN0cmVhbSwgZXZlbnQpIHtcbiAgICAgICAgICAgIGRlYnVnKCdSZXF1ZXN0IyVkICVzOiB3cml0ZVN0cmVhbSBvciByZXMgJXMgZXZlbnQgZW1pdHRlZCcsIHJlcUlkLCB1cmwsIGV2ZW50KTtcbiAgICAgICAgICAgIGRvbmUoX19lcnIgfHwgbnVsbCwgbnVsbCwgcmVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZVN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlYnVnKCdSZXF1ZXN0IyVkICVzOiB3cml0ZVN0cmVhbSBjbG9zZSBldmVudCBlbWl0dGVkJywgcmVxSWQsIHVybCk7XG4gICAgICAgICAgICBkb25lKF9fZXJyIHx8IG51bGwsIG51bGwsIHJlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucGlwZSh3cml0ZVN0cmVhbSk7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBqdXN0IGNvbmNhdCB0aG9zZSBidWZmZXJzLlxuICAgIC8vXG4gICAgLy8gTk9URSB0aGF0IHRoZSBgY2h1bmtgIGlzIG5vdCBhIFN0cmluZyBidXQgYSBCdWZmZXIuIEl0IG1lYW5zIHRoYXQgaWZcbiAgICAvLyB5b3Ugc2ltcGx5IGNvbmNhdCB0d28gY2h1bmsgd2l0aCBgK2AgeW91J3JlIGFjdHVhbGx5IGNvbnZlcnRpbmcgYm90aFxuICAgIC8vIEJ1ZmZlcnMgaW50byBTdHJpbmdzIGJlZm9yZSBjb25jYXRpbmcgdGhlbS4gSXQnbGwgY2F1c2UgcHJvYmxlbXMgd2hlblxuICAgIC8vIGRlYWxpbmcgd2l0aCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuXG4gICAgLy9cbiAgICAvLyBUaGUgc29sdXRpb24gaXMgdG8gc3RvcmUgZWFjaCBjaHVuayBpbiBhbiBhcnJheSBhbmQgY29uY2F0IHRoZW0gd2l0aFxuICAgIC8vICdidWZmZXItY29uY2F0JyB3aGVuIGFsbCBjaHVua3MgaXMgcmVjaWV2ZWQuXG4gICAgLy9cbiAgICAvLyBTZWUgYWxzbzpcbiAgICAvLyBodHRwOi8vY25vZGVqcy5vcmcvdG9waWMvNGZhZjY1ODUyZThmYjViYzY1MTEzNDAzXG5cbiAgICB2YXIgY2h1bmtzID0gW107XG5cbiAgICByZXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIGRlYnVnKCdSZXF1ZXN0IyVkICVzOiBgcmVzIGRhdGFgIGV2ZW50IGVtaXQsIHNpemUgJWQnLCByZXFJZCwgdXJsLCBjaHVuay5sZW5ndGgpO1xuICAgICAgcmVzcG9uc2VTaXplICs9IGNodW5rLmxlbmd0aDtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9KTtcblxuICAgIHJlcy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJvZHkgPSBCdWZmZXIuY29uY2F0KGNodW5rcywgcmVzcG9uc2VTaXplKTtcbiAgICAgIGRlYnVnKCdSZXF1ZXN0IyVkICVzOiBgcmVzIGVuZGAgZXZlbnQgZW1pdCwgdG90YWwgc2l6ZSAlZCwgX2R1bXBlZDogJXMnLFxuICAgICAgICByZXFJZCwgdXJsLCByZXNwb25zZVNpemUsIHJlcy5fZHVtcGVkKTtcblxuICAgICAgaWYgKF9fZXJyKSB7XG4gICAgICAgIC8vIHJlcS5hYm9ydCgpIGFmdGVyIGByZXMgZGF0YWAgZXZlbnQgZW1pdC5cbiAgICAgICAgcmV0dXJuIGRvbmUoX19lcnIsIGJvZHksIHJlcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBoYW5kbGVSZWRpcmVjdChyZXMpO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICByZXR1cm4gZG9uZShyZXN1bHQuZXJyb3IsIGJvZHksIHJlcyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LnJlZGlyZWN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGVjb2RlQ29udGVudChyZXMsIGJvZHksIGZ1bmN0aW9uIChlcnIsIGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZShlcnIsIGJvZHksIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYm9keSBub3QgZGVjb2RlLCBkb250IHRvdWNoIGl0XG4gICAgICAgIGlmICghZW5jb2RpbmcgJiYgVEVYVF9EQVRBX1RZUEVTLmluZGV4T2YoYXJncy5kYXRhVHlwZSkgPj0gMCkge1xuICAgICAgICAgIC8vIHRyeSB0byBkZWNvZGUgY2hhcnNldFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gZGVjb2RlQm9keUJ5Q2hhcnNldChkYXRhLCByZXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdkZWNvZGVCb2R5QnlDaGFyc2V0IGVycm9yOiAlcycsIGUpO1xuICAgICAgICAgICAgLy8gaWYgZXJyb3IsIGRvbnQgdG91Y2ggaXRcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwsIGRhdGEsIHJlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFyZ3MuZGF0YVR5cGUgPT09ICdqc29uJykge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByID0gcGFyc2VKU09OKGRhdGEsIGZpeEpTT05DdGxDaGFycyk7XG4gICAgICAgICAgICAgIGlmIChyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gci5lcnJvcjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gci5kYXRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlQWJvcnRlZCkge1xuICAgICAgICAgIC8vIGVyciA9IG5ldyBFcnJvcignUmVtb3RlIHNvY2tldCB3YXMgdGVybWluYXRlZCBiZWZvcmUgYHJlc3BvbnNlLmVuZCgpYCB3YXMgY2FsbGVkJyk7XG4gICAgICAgICAgLy8gZXJyLm5hbWUgPSAnUmVtb3RlU29ja2V0Q2xvc2VkRXJyb3InO1xuICAgICAgICAgIGRlYnVnKCdSZXF1ZXN0IyVkICVzOiBSZW1vdGUgc29ja2V0IHdhcyB0ZXJtaW5hdGVkIGJlZm9yZSBgcmVzcG9uc2UuZW5kKClgIHdhcyBjYWxsZWQnLCByZXFJZCwgdXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbmUoZXJyLCBkYXRhLCByZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY29ubmVjdFRpbWVvdXQsIHJlc3BvbnNlVGltZW91dDtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJncy50aW1lb3V0KSkge1xuICAgIGNvbm5lY3RUaW1lb3V0ID0gbXMoYXJncy50aW1lb3V0WzBdKTtcbiAgICByZXNwb25zZVRpbWVvdXQgPSBtcyhhcmdzLnRpbWVvdXRbMV0pO1xuICB9IGVsc2UgeyAgLy8gc2V0IGJvdGggdGltZW91dCBlcXVhbFxuICAgIGNvbm5lY3RUaW1lb3V0ID0gcmVzcG9uc2VUaW1lb3V0ID0gbXMoYXJncy50aW1lb3V0KTtcbiAgfVxuICBkZWJ1ZygnQ29ubmVjdFRpbWVvdXQ6ICVkLCBSZXNwb25zZVRpbWVvdXQ6ICVkJywgY29ubmVjdFRpbWVvdXQsIHJlc3BvbnNlVGltZW91dCk7XG5cbiAgZnVuY3Rpb24gc3RhcnRDb25uZWN0VGltZXIoKSB7XG4gICAgZGVidWcoJ0Nvbm5lY3QgdGltZXIgdGlja2luZywgdGltZW91dDogJWQnLCBjb25uZWN0VGltZW91dCk7XG4gICAgY29ubmVjdFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25uZWN0VGltZXIgPSBudWxsO1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IC0xKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSAtMjtcbiAgICAgIH1cbiAgICAgIHZhciBtc2cgPSAnQ29ubmVjdCB0aW1lb3V0IGZvciAnICsgY29ubmVjdFRpbWVvdXQgKyAnbXMnO1xuICAgICAgdmFyIGVycm9yTmFtZSA9ICdDb25uZWN0aW9uVGltZW91dEVycm9yJztcbiAgICAgIGlmICghcmVxLnNvY2tldCkge1xuICAgICAgICBlcnJvck5hbWUgPSAnU29ja2V0QXNzaWduVGltZW91dEVycm9yJztcbiAgICAgICAgbXNnICs9ICcsIHdvcmtpbmcgc29ja2V0cyBpcyBmdWxsJztcbiAgICAgIH1cbiAgICAgIF9fZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICBfX2Vyci5uYW1lID0gZXJyb3JOYW1lO1xuICAgICAgX19lcnIucmVxdWVzdElkID0gcmVxSWQ7XG4gICAgICBkZWJ1ZygnQ29ubmVjdFRpbWVvdXQ6IFJlcXVlc3QjJWQgJXMgJXM6ICVzLCBjb25uZWN0ZWQ6ICVzJywgcmVxSWQsIHVybCwgX19lcnIubmFtZSwgbXNnLCBjb25uZWN0ZWQpO1xuICAgICAgYWJvcnRSZXF1ZXN0KCk7XG4gICAgfSwgY29ubmVjdFRpbWVvdXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRSZXNwb3NuZVRpbWVyKCkge1xuICAgIGRlYnVnKCdSZXNwb25zZSB0aW1lciB0aWNraW5nLCB0aW1lb3V0OiAlZCcsIHJlc3BvbnNlVGltZW91dCk7XG4gICAgcmVzcG9uc2VUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVzcG9uc2VUaW1lciA9IG51bGw7XG4gICAgICB2YXIgbXNnID0gJ1Jlc3BvbnNlIHRpbWVvdXQgZm9yICcgKyByZXNwb25zZVRpbWVvdXQgKyAnbXMnO1xuICAgICAgdmFyIGVycm9yTmFtZSA9ICdSZXNwb25zZVRpbWVvdXRFcnJvcic7XG4gICAgICBfX2VyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgX19lcnIubmFtZSA9IGVycm9yTmFtZTtcbiAgICAgIF9fZXJyLnJlcXVlc3RJZCA9IHJlcUlkO1xuICAgICAgZGVidWcoJ1Jlc3BvbnNlVGltZW91dDogUmVxdWVzdCMlZCAlcyAlczogJXMsIGNvbm5lY3RlZDogJXMnLCByZXFJZCwgdXJsLCBfX2Vyci5uYW1lLCBtc2csIGNvbm5lY3RlZCk7XG4gICAgICBhYm9ydFJlcXVlc3QoKTtcbiAgICB9LCByZXNwb25zZVRpbWVvdXQpO1xuICB9XG5cbiAgdmFyIHJlcTtcbiAgLy8gcmVxdWVzdCBoZWFkZXJzIGNoZWNrZXIgd2lsbCB0aHJvdyBlcnJvclxuICBvcHRpb25zLm1vZGUgPSBhcmdzLm1vZGUgPyBhcmdzLm1vZGUgOiAnJztcbiAgdHJ5IHtcbiAgICByZXEgPSBodHRwbGliLnJlcXVlc3Qob3B0aW9ucywgb25SZXNwb25zZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBkb25lKGVycik7XG4gIH1cblxuICAvLyBlbnZpcm9ubWVudCBkZXRlY3Rpb246IGJyb3dzZXIgb3Igbm9kZWpzXG4gIGlmICh0eXBlb2Yod2luZG93KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBzdGFydCBjb25uZWN0IHRpbWVyIGp1c3QgYWZ0ZXIgYHJlcXVlc3RgIHJldHVybiwgYW5kIGp1c3QgaW4gbm9kZWpzIGVudmlyb25tZW50XG4gICAgc3RhcnRDb25uZWN0VGltZXIoKTtcbiAgfSBlbHNlIHtcbiAgICByZXEub24oJ3JlcXVlc3RUaW1lb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IC0xKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSAtMjtcbiAgICAgIH1cbiAgICAgIHZhciBtc2cgPSAnQ29ubmVjdCB0aW1lb3V0IGZvciAnICsgY29ubmVjdFRpbWVvdXQgKyAnbXMnO1xuICAgICAgdmFyIGVycm9yTmFtZSA9ICdDb25uZWN0aW9uVGltZW91dEVycm9yJztcbiAgICAgIF9fZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICBfX2Vyci5uYW1lID0gZXJyb3JOYW1lO1xuICAgICAgX19lcnIucmVxdWVzdElkID0gcmVxSWQ7XG4gICAgICBhYm9ydFJlcXVlc3QoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0UmVxdWVzdCgpIHtcbiAgICBkZWJ1ZygnUmVxdWVzdCMlZCAlcyBhYm9ydCwgY29ubmVjdGVkOiAlcycsIHJlcUlkLCB1cmwsIGNvbm5lY3RlZCk7XG4gICAgLy8gaXQgd29udCBjYXNlIGVycm9yIGV2ZW50IHdoZW4gcmVxIGhhdmVuJ3QgYmVlbiBhc3NpZ25lZCBhIHNvY2tldCB5ZXQuXG4gICAgaWYgKCFyZXEuc29ja2V0KSB7XG4gICAgICBfX2Vyci5ub1NvY2tldCA9IHRydWU7XG4gICAgICBkb25lKF9fZXJyKTtcbiAgICB9XG4gICAgcmVxLmFib3J0KCk7XG4gIH1cblxuICBpZiAodGltaW5nKSB7XG4gICAgLy8gcmVxdWVzdCBzZW50XG4gICAgcmVxLm9uKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRpbWluZy5yZXF1ZXN0U2VudCA9IERhdGUubm93KCkgLSByZXF1ZXN0U3RhcnRUaW1lO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uY2UoJ3NvY2tldCcsIGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICBpZiAodGltaW5nKSB7XG4gICAgICAvLyBzb2NrZXQgcXVldWluZyB0aW1lXG4gICAgICB0aW1pbmcucXVldWluZyA9IERhdGUubm93KCkgLSByZXF1ZXN0U3RhcnRUaW1lO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvbmV0LmpzI0wzNzdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MC4xMC40MC1yZWxlYXNlL2xpYi9uZXQuanMjTDM1MlxuICAgIC8vIHNob3VsZCB1c2Ugc29ja2V0LnNvY2tldCBvbiAwLjEwLnhcbiAgICBpZiAoaXNOb2RlMDEwICYmIHNvY2tldC5zb2NrZXQpIHtcbiAgICAgIHNvY2tldCA9IHNvY2tldC5zb2NrZXQ7XG4gICAgfVxuXG4gICAgdmFyIHJlYWR5U3RhdGUgPSBzb2NrZXQucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gJ29wZW5pbmcnKSB7XG4gICAgICBzb2NrZXQub25jZSgnbG9va3VwJywgZnVuY3Rpb24oZXJyLCBpcCwgYWRkcmVzc1R5cGUpIHtcbiAgICAgICAgZGVidWcoJ1JlcXVlc3QjJWQgJXMgbG9va3VwOiAlcywgJXMsICVzJywgcmVxSWQsIHVybCwgZXJyLCBpcCwgYWRkcmVzc1R5cGUpO1xuICAgICAgICBpZiAodGltaW5nKSB7XG4gICAgICAgICAgdGltaW5nLmRuc2xvb2t1cCA9IERhdGUubm93KCkgLSByZXF1ZXN0U3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcCkge1xuICAgICAgICAgIHJlbW90ZUFkZHJlc3MgPSBpcDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzb2NrZXQub25jZSgnY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltaW5nKSB7XG4gICAgICAgICAgLy8gc29ja2V0IGNvbm5lY3RlZFxuICAgICAgICAgIHRpbWluZy5jb25uZWN0ZWQgPSBEYXRlLm5vdygpIC0gcmVxdWVzdFN0YXJ0VGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbmNlbCBzb2NrZXQgdGltZXIgYXQgZmlyc3QgYW5kIHN0YXJ0IHRpY2sgZm9yIFRURkJcbiAgICAgICAgY2FuY2VsQ29ubmVjdFRpbWVyKCk7XG4gICAgICAgIHN0YXJ0UmVzcG9zbmVUaW1lcigpO1xuXG4gICAgICAgIGRlYnVnKCdSZXF1ZXN0IyVkICVzIG5ldyBzb2NrZXQgY29ubmVjdGVkJywgcmVxSWQsIHVybCk7XG4gICAgICAgIGNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGlmICghcmVtb3RlQWRkcmVzcykge1xuICAgICAgICAgIHJlbW90ZUFkZHJlc3MgPSBzb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZW1vdGVQb3J0ID0gc29ja2V0LnJlbW90ZVBvcnQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWJ1ZygnUmVxdWVzdCMlZCAlcyByZXVzZSBzb2NrZXQgY29ubmVjdGVkLCByZWFkeVN0YXRlOiAlcycsIHJlcUlkLCB1cmwsIHJlYWR5U3RhdGUpO1xuICAgIGNvbm5lY3RlZCA9IHRydWU7XG4gICAga2VlcEFsaXZlU29ja2V0ID0gdHJ1ZTtcbiAgICBpZiAoIXJlbW90ZUFkZHJlc3MpIHtcbiAgICAgIHJlbW90ZUFkZHJlc3MgPSBzb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICB9XG4gICAgcmVtb3RlUG9ydCA9IHNvY2tldC5yZW1vdGVQb3J0O1xuXG4gICAgLy8gcmV1c2Ugc29ja2V0LCB0aW1lciBzaG91bGQgYmUgY2FuY2VsZWQuXG4gICAgY2FuY2VsQ29ubmVjdFRpbWVyKCk7XG4gICAgc3RhcnRSZXNwb3NuZVRpbWVyKCk7XG4gIH0pO1xuXG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgLy9UeXBlRXJyb3IgZm9yIGJyb3dzZXIgZmV0Y2ggYXBpLCBFcnJvciBmb3IgYnJvd3NlciB4bWxodHRwcmVxdWVzdCBhcGlcbiAgICBpZiAoZXJyLm5hbWUgPT09ICdFcnJvcicgfHwgZXJyLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICBlcnIubmFtZSA9IGNvbm5lY3RlZCA/ICdSZXNwb25zZUVycm9yJyA6ICdSZXF1ZXN0RXJyb3InO1xuICAgIH1cbiAgICBlcnIubWVzc2FnZSArPSAnIChyZXEgXCJlcnJvclwiKSc7XG4gICAgZGVidWcoJ1JlcXVlc3QjJWQgJXMgYHJlcSBlcnJvcmAgZXZlbnQgZW1pdCwgJXM6ICVzJywgcmVxSWQsIHVybCwgZXJyLm5hbWUsIGVyci5tZXNzYWdlKTtcbiAgICBkb25lKF9fZXJyIHx8IGVycik7XG4gIH0pO1xuXG4gIGlmICh3cml0ZVN0cmVhbSkge1xuICAgIHdyaXRlU3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgZXJyLm1lc3NhZ2UgKz0gJyAod3JpdGVTdHJlYW0gXCJlcnJvclwiKSc7XG4gICAgICBfX2VyciA9IGVycjtcbiAgICAgIGRlYnVnKCdSZXF1ZXN0IyVkICVzIGB3cml0ZVN0cmVhbSBlcnJvcmAgZXZlbnQgZW1pdCwgJXM6ICVzJywgcmVxSWQsIHVybCwgZXJyLm5hbWUsIGVyci5tZXNzYWdlKTtcbiAgICAgIGFib3J0UmVxdWVzdCgpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFyZ3Muc3RyZWFtKSB7XG4gICAgYXJncy5zdHJlYW0ucGlwZShyZXEpO1xuICAgIGFyZ3Muc3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgZXJyLm1lc3NhZ2UgKz0gJyAoc3RyZWFtIFwiZXJyb3JcIiknO1xuICAgICAgX19lcnIgPSBlcnI7XG4gICAgICBkZWJ1ZygnUmVxdWVzdCMlZCAlcyBgcmVhZFN0cmVhbSBlcnJvcmAgZXZlbnQgZW1pdCwgJXM6ICVzJywgcmVxSWQsIHVybCwgZXJyLm5hbWUsIGVyci5tZXNzYWdlKTtcbiAgICAgIGFib3J0UmVxdWVzdCgpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlcS5lbmQoYm9keSk7XG4gIH1cblxuICByZXEucmVxdWVzdElkID0gcmVxSWQ7XG4gIHJldHVybiByZXE7XG59OyJdfQ==

